<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="李宏毅2025 AI Agent新课来了！(附PPT), ZejunCao&#39;Blogs">
    <meta name="description" content="李宏毅2025 AI Agent新课来了！(附PPT)

仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接

AIAgent干货作者：李宏毅教授，国立台湾大学编者按：本文是台大教授李宏毅讲授AIAgent的爆火油管视频的文字">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>李宏毅2025 AI Agent新课来了！(附PPT) | ZejunCao&#39;Blogs</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZejunCao&#39;Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZejunCao&#39;Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/frontcover/1000000158_2247486449_1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">李宏毅2025 AI Agent新课来了！(附PPT)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%8D%E6%B2%BF/">
                                <span class="chip bg-color">AI大模型前沿</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-04-07
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kxpaLPa5Hok3UPHBT6ttXQ">李宏毅2025 AI Agent新课来了！(附PPT)</a></p>
<blockquote>
<p>仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接</p>
</blockquote>
<p>AIAgent干货<br>作者：李宏毅教授，国立台湾大学<br>编者按：本文是台大教授李宏毅讲授AIAgent的爆火油管视频的文字稿。内容层层递进，是学习和理解AIAgent难得的好教材。由于原视频较长，为方便订阅读者们高效学习，智能超参数特地整理出来这节课的文字实录。建议先收藏，再反复学习。以下，enjoy：<br>视频链接：<br>https :&#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.youtube.com/watch?v=M2Yg1kwPpts">www.youtube.com/watch?v=M2Yg1kwPpts</a><br>PPT链接：<br>https :&#x2F;&#x2F;docs.google.com&#x2F;presentation&#x2F;d&#x2F;1kTxukwlmx2Sc9H7aGPTiNiPdk4zN_NoH<br>今天我们要讲的是AIagent，这是一个现在非常热门的话题。在课程开始之前，先讲一个免责声明，我知道你在各个地方可能都听过AIagent这个词汇，它是一个被广泛应用的词汇，每个人心里想的AIagent可能都不一样。<br>我们要讲的AIagent是什么呢？<br>今天我们使用AI的方式，通常是人类给一个明确的指令，你问AI说AIagent的翻译是什么？那AI按照你的口令，一个口令，一个动作，把你要求的翻译翻译出来，它也不会再做更多的事情了。<br>AIagent的意思是说，人类不提供明确的行为或步骤的指示，人类只给AI目标，至于怎么达成目标，AI要自己想办法。比如，你给AI某一个研究的议题，那你期待一个AIagent就应该能够自己提出假设，设计实验，进行实验，分析结果。如果分析出来的结果跟假设不符合，要回头去修正假设。<br>通常你期待AIagent要要达成的目标需要通过多个步骤，跟环境做很复杂的互动才能够完成。而环境会有一些不可预测的地方，所以AIagent还要能够做到灵活地根据现在的状况来调整计划。<br>AIagent是怎样做到人类给予一个目标，用多个步骤来完成目标的呢？我们可以把AIagent背后运作的过程简化成以下这张幻灯片。<br>AIagent的第一个输入是一个目标，这个目标是人给定的。接下来，AIagent会观察目前的状况，我们叫做observation。AIagent会看目前的状况，分析目前的状况，决定要采取什么样的行动。今天这个AIagent做的事情，叫做action。它执行个action以后，会影响环境的状态，会看到不一样的observation。看到不一样的observation，就会执行不同的action。这个步骤会一直循环，直到AIagent达成我们要他达成的目标为止。<br>讲到这里，你可能还会觉得非常的抽象，那我们可以用下围棋来举例。大家非常熟悉AlphaGo，它其实也可以看作是一个AIagent。这个AIagent的目标是下棋要赢，它的observation是现在棋盘上黑子跟白子的位置，现在棋盘上的盘势，可以采取的action就是在棋盘上的19x19路的范围中选择一个可以落子的位置。选择完可以落子的位置，他落下一次以后，会改变它对手的输出。你的对手会落下另外一次子，那会改变它观察到的observation，那它就要采取下一个action。<br>所以AlphaGo是一个AIagent。它背后运作的原理，大家其实或多或少也都已经听过。如果你有上过任何基础的reinforcementlearningRL（强化学习）的课程，往往都是用这样方式来开场的。<br>为什么呢，因为过去要打造AIagent的时候，往往觉得就是要通过RL的算法来打造AIagent。<br>那怎么通过RL的算法来打造AIagent呢？RL这个算法就是它可以让一个agent去maximizereward。所以你要把你的目标转换成一个叫做reward的东西。这个reward是人定义的，越接近你的目标reward就越大。<br>如果在下围棋里面，通常就会设定赢棋reward就是正一，输棋reward就是负一。然后训练的那个AIagent就会学习去maximizereward，通过RL的算法。<br>但是通过RL算法的局限是，你需要为每一个任务都用RL的算法训练一个模型。AlphaGo在经过了大量训练以后，可以下围棋，但并不代表他可以下其他的棋类，比如西洋棋或将棋。<br>我知道你可能看过一篇文章，AlphaZero除了围棋外也可以下将棋和西洋棋，那是另外训练后的结果。能够下将棋的那个模型，并不是原来可以下围棋的那个AlphaGo，它们是不同的模型，有不同的参数。</p>
<p>你要告诉它你的目标是什么的时候，直接用文字输入，要告诉他下围棋，就先给他围棋的规则，然后跟他说你的目标就是赢得胜利。那接下来环境，因为一般语言模型是用文字作为输入，所以你可能需要把环境转化为文字的描述。<br>不过我写了一个option，今天有很多语言模型都是可以直接看图片的，所以把环境转化为文字的描述，今天也不一定是必要的。那接下来语言模型要产生action，那产生action的方式，可能就是用一段文字来决定它的action是什么。它的action用一段文字来描述，那我们需要把那段文字转译成真正可以执行的行动，然后就会改变环境，看到不一样的observation，然后AIagent的运作就可以持续下去，直到达成目标。<br>今天AIagent再次爆红，并不是真的有了什么跟AIagent本身相关的新技术，而是在LLM变强之后，人们开始想，我们能不能直接用largelanguagemodel来实践人类拥有一个agent的渴望。<br>我们还是拿下棋做例子。也许你就会很好奇说，现在的语言模型能不能够下棋呢？其实早就有人尝试过了。<br>有一个在语言模型领域很多人使用的benchmark叫做Big-Bench。它是什么时候做的呢？它是2022年“上古时代”做的。以后有ChatGPT之前，我们都叫“上古时代”。然后在2022年上古时代的时候，就有人尝试过用那个时候的语言模型下西洋棋。<br>那时候语言模型没有能力真的看图，所以你需要把棋盘上黑子和白子的位置转成文字的描述，输入给这个语言模型。<br>这个就是语言模型实际上看到的棋盘的样子。下一步要下哪里，才能给对方将军呢？那语言模型就会给你一个答案。<br>右上角这个图，橙色的线是正确答案，绿色的线是当时各个不同的语言模型所给的答案。没有任何一个语言模型给出正确的答案。<br>虽然没有任何语言模型给出正确的答案，但你可以看到，当时比较强的模型所选择走的路是符合西洋棋规则的。但是也有很多比较弱的模型，这个虚线代表比较弱的模型，它们都是乱走的，根本搞不懂西洋棋的规则。不过这个是“上古时代”的事情了。<br>现在更强的LLM能不能下西洋棋呢？有人试过了。有一个很知名的视频是直接拿ChatGPTo1跟DeepSeek-R1两个模型来下西洋棋。那这是一场惊天动地的对决，有几百万人观看这个视频。<br>这两个模型杀的难分难解，难分难解是因为他们实在是太弱了，有很多不符合西洋棋规则的动作，比如把兵当作马来用，或者是他的那个主教可以无视前面的一切阻挡，或者是他突然空降一个自己的子在对方的阵地里面，把对方的子吃掉。然后DeepSeek还在自己的棋盘上随便变出一个城堡，最后DeepSeek用自己的城堡把自己的兵吃掉以后，宣布他赢了，然后ChatGPT想了一下觉得，我确实输了，然后就投降了。这个棋局就这样结束了。<br>所以看起来，现在这个最强的语言模型距离下棋还有一段距离，但这并不代表他们不能够作为AIagent来做其他事情。<br>接下来我会举一些例子，看看现在的语言模型可以做什么样的事情。这门课最想要强调是，我们还能多做些什么，让这些语言模型作为AIagent的时候，运作得更加顺利。<br>刚才讲的比较像是从过去常见的agent的视角，来看语言模型，怎么套用到agent的框架下。<br>那接下来我们换一个角度。从largelanguagemodel的角度来看，当他作为一个agent的时候，他要解决的问题有什么不同。<br>从largelanguagemodel的角度来看，首先ta得到一个目标，然后接下来得到一个observation，然后根据这个observation，决定接下来要采取什么样的action。当它采取完动作之后，他的动作会影响外界的环境，看到新的observation。看到新的observation以后，要采取新的动作，这个过程就会再反复继续下去。<br>在那一系列的过程中，看到observation采取action，看到observation采取action，其实凭借的都是语言模型原来就有的文字接龙能力。<br>所以从语言模型的角度来看，当我们把它当作一个agent来使用的的时候，对它而言，所做的事情是完全没有什么不同的，就是在继续做他唯一会做的文字接龙而已。<br>所以从语言模型的角度来看，AIagent并不是一个语言模型的新技术，它比较像是一个语言模型的应用。所谓AIagent意思就是依靠现在语言模型已经有一定程度的通用能力，看看能不能够直接把它们当作agent来使用。<br>因为我说的AIagent并不是语言模型的新技术，它只是一个语言模型的应用，所以要注意一下在以下课程中没有任何的模型被训练。我所讲的东西都是依靠一个现有的语言模型的能力来达成的。<br>AIagent其实不是最近才热门，一直有人在尝试怎么让语言模型变成一个agent，或者怎么把语言模型当作AIagent来使用。<br>ChatGPT在2022年年底爆红，所以在2023年的春天就有一波AIagent的热潮，好多人都用ChatGPT作为背后运作的语言模型来打造AIagent。那时候最有名的就是AutoGPT。<br>其实在2023年的机器学习课程中我们也有一堂课是讲那时候的AIagent，大家看看那一堂课的AIagent跟今天讲的有什么样的差异。<br>不过后来2023年AIagent的热潮，过一阵子就消退了，因为人们发现这些AIagent没有我们想象的厉害。一开始好多网红在吹嘘这些AIagent有多强，但真正试下去也没那么强，所以热潮就过去了。<br>那用LLM来运行一个AIagent，相较于其他的方法，可能有样什么样的优势呢？<br>过去当你运行一个agent的时候，比如说像AlphaGo，它能做的只有有限的事先设定好的行为。AlphaGo真正能做的事情就是在19x19个位置上选择一个可以落子的位置。<br>但如果你的agent是一个largelanguagemodel的话，它就有了近乎无限的可能。largelanguagemodel可以讲任何话，可以产生各式各样近乎无穷无尽的输出，这就让AIagent可以采取的行动不再有局限，有更多的可能性。<br>举例来说，我们等一下就会很快看到，今天这些AIagent在有些问题他解不了的时候，他可以直接呼叫一些工具，来帮忙解决本来解决不了的问题。</p>
<p>但为什么是-1？为什么不是-10？为什么不是-17.7？这种东西就是没人说得清楚。所以这个reward在做reinforcementlearning的时候就是一个要调教的东西。<br>今天如果是用LLM驱动的AIagent呢？你今天就不用帮它订reward了。今天有compileerror，你可以直接把compileerror的log给它，他也许读得懂那个log，可以对程序做出正确的修改。而且相较于reward只有一个数值，直接提供error的log可能提供给agent更丰富的信息，让它更容易按照环境给的反馈，来修改它的行为。<br>接下来举几个AIagent的例子。讲到AIagent，也许最知名的例子就是用AI村民所组成的一个虚拟村庄。这个虚拟村庄在2023年成立，虚拟村庄里面的NPC都是用语言模型来运行的。<br>这些NPC是怎么运行的呢？首先每个NPC都一个人为设定的目标，有的NPC要办情人节派对，有的NPC要准备考试，每个人都一个他自己想做的事情。这些NPC会观察会看到环境的信息。那时候LanguageModel都只能读文字，所以环境的信息需要用文字来表示。<br>环境的信息对一个语言模型来说，看起来可能就是，有一个叫做Eddy的人，他正在读书，然后他看到厨房，然后他看到一个柜子，然后看到伊丽莎白正在装饰房间等等。然后根据这些observation，这个语言模型要决定一个他想要做的行为，比如说也许不早了，所以就上床睡觉。那需要有一个转译器把它说出的这个行为转成真正能够执行的指令。那这个agent就真会走到床边，然后去睡觉。所以这个是2023年的时候用AI来运行NPC的一个实验。<br>其实后来还有更大规模的实验，有人把Minecraft中的NPC通通换成AI的NPC。根据这个视频描述，这些AI很厉害，他们组织了自己交易的金融体系，然后还组织了自己的政府部门，自己制定法规，自己管理自己。不确定是真的还是假的。<br>刚才讲的那些游戏，你可能不容易接触到，对现实世界可能也没什么影响。<br>但今天也许你马上就会接触到的AIagent就是让AI来真正使用电脑。虽然这个听起来有点奇怪，AI本身也就是一个电脑，但现在要真正的像人类一样来使用另外一个比较低端的电脑来做事。其中比较有代表性的例子就是Claude的computeruse，还有ChatGPT的operator。<br>operator界面长这样。它可以做的事情，比如说可以订pizza，可以预约下周的居家清洁等等。<br>像这种使用电脑的AIagent，他的目标就是你的输入，就是你告诉他我要去订pizza，上网帮我买一个东西，那这就是他的目标。那他的observation呢？他的observation可能是那个电脑的屏幕画面。<br>今天很多语言模型都是可以直接看图的，所以其实可以直接把图片当作输入，提供给AIagent。AIagent要决定的就是要按键盘上哪一个键，或者是要用鼠标按哪一个按钮。<br>其实让AI使用电脑不是最近才开开始的。早在2017年，就有篇paper叫wordsofbits尝试过使用AIagent。这个文章的标题说它是一个web-basedagent。<br>只是那个时候能够互动的页面还是比较原始的页面。你可以看到下面这些AIagent，他真正能够处理的是比较原始的页面。那时候也没有大型语言模型，所以那时候的方法就是硬训练一个CNN，直接吃屏幕画面当作输入，输出就是鼠标要点的位置，或者是键盘要按的按钮。看看用这个方法能不能够让AIagent在互联网的世界中做事。<br>这个发生在2017年，甚至不能说是上古时代，这个还是有BERT以前的时代，就是史前时代。这个不只是史前时代，它比史前时代还早，所以这是旧石器时代的产物。<br>后来有了语言模型之后，人们就开始尝试用语言模型来当作AIagent，来运行一个agent，让它在互联网的世界中活动。<br>这一页幻灯片是列举了几个比较具代表性的例子。那一波潮流大概是在2023年的暑假开始的，像Mind2Web、WebArena还有VisualWebArena，就跟今天的operator非常的像，就是给这个语言模型看一个屏幕的画面，或者是看HTML的code，然后让它自己决定要干什么，期待它最后可以解决一个问题。比如在Mind2Web的第一个例子里面，就给他这个画面，然后跟它说，请它帮我们订一个机票。<br>还有什么样AIagent的应用呢？今天你可以用AI来训练另外一个AI模型。<br>用AI来训练模型，其实这个运作的过程是：你的目标是要过strongbaseline，然后你提供给LLM训练资料，它写一个程序用这些训练资料来训练模型，那它可能会得到这个模型的正确率，根据正确率再重新写一个程序，再得到新的正确率，就这样一直运作下去。</p>
<p>最近Google说他们做了一个AI，不过他们并没有真的发布模型，也不知道说实际上做得怎么样，因为这个服务并不是公开的。<br>他们说的是他们做了一个AICoscientist，就是用AI来做研究，不过这个AICoscientist还是蛮有局限的，不能真的做实验，只能够提Proposal，就是你把一些研究的想法告诉他，他把完整的Proposal规划出来。实际上做得怎么样，不知道，他的Blog里面有些比较夸张的案例，说什么本来人类要花十年才能够得到研究成果，AIagent花两天就得到了，也不知道真的还是假的。他举的是一些生物学的例子，所以我也无法判断他讲的是不是真的，那个发现是不是真的很重要。这个AICoscientist就是用AIagent来帮研究人员做研究。<br>我们刚才讲的AIagent，它的互动方式是局限在回合制的互动，有一个observation，接下来执行action，有一个observation，接下来执行action。但是在更真实的情境下，这个互动是需要及时的，因为外在的环境也许是不断在改变的。<br>如果你在action还没有执行完的时候，外在环境就改变了，那应该怎么办呢？有没有办法做到更及时的互动呢？<br>更及时的互动可能应该像是这个样子，当模型在决定要执行actionone，正在执行的过程中，突然外在环境变了，这个时候模型应该有办法立刻转换行动，改变他的决策，以因应外界突如其来的变化。<br>你可能想问什么样的状况，我们会需要用到这种能够做及时互动的AIagent呢？其实语音对话就需要这种互动的模式，文字的对话使用ChatGPT是大家比较熟悉的，你输入一段文字，他就输出一段文字，这是一来一往回合制的互动。<br>但是人与人之间真正的对话不是这个样子的。当两个人在对话的时候，他们可能会互相打断，或者是其中一个人在讲话的时候，另外一个人可能会同时提供一些反馈，比如说；嗯，好，你说的都对。<br>这些反馈可能没有什么特别语意上的含义，他只是想要告诉对方我有在听。但是像这样的反馈，对于流畅的交流来说，也是非常重要的。如果在讲电话的时候对方完全没有反应，你会怀疑他到底有没有在听。<br>所以我们今天能不能够让AI在跟使用者互动的时候，用语音互动的时候，就跟人与人间的互动一样，而不是一来一往回合制的互动呢？其实也不是不可能的，今天GPT-4o的一个VoiceMode，高级语音模式，也许在某种程度上就做到了这种及时的互动。<br>那这个幻灯片上是举一个例子，假设有人跟AI说你说一个故事，那这个是AI观察到的第一个observation，有人叫他说一个故事，现在就开始讲故事了，他就说从前从前，这时候人说了一个好，这个可能是第二个observation，但AI要知道说这个observation不需要改变他的行为，跟他的行为没有直接的关系，只要故事就继续讲下去。“有一个小镇”…然后人说这个不是我要听的故事，这个我听过了，那AI可能要马上知道说那这个不是人要听的，那也许我觉得应该停下来，换另外一个故事。<br>今天AI有没有办法做到这种及时的互动呢？那怎么做这种及时的互动，非回合制的互动，就有点超过我们这门课想要讲的范围。<br>如果你有兴趣的话，你可以读这篇文章，这篇文章想要做的事情是评估现在这些语音模型互动的能力。那在这篇文章里面，也对现在这个可以互动的语音模型做了一个比较完整的survey，是一直survey到今年的1月。所以你可以看这篇文章，知道说现在这些可以互动的模型，他可以做到什么样的地步。<br>那接下来呢，我们会分三个方面来剖析今天这些AIagent的关键能力。<br>那第一个方面是我们要来看这些AIagent能不能够根据它的经验，通过过去的互动中所获得的经验来调整他的行为。第二部分是要讲这些AIagent如何呼叫外部的援助，如何使用工具。第三部分要讲AIagent能不能够执行计划，能不能做计划。<br>AI怎么根据过去的经验或者是环境的反馈来调整他的行为。<br>AIagent需要能够根据经验来调整行为，比如说有一个作为AIprogrammer的AIagent，他一开始接到一个任务，他写了一个程序，那这个程序compile以后有错误信息，compile以后有error，那应该要怎么办呢？他应该要能够根据这个error的message来修正他之后写的程序。<br>在过去，讲到说收到一个feedback接下来要做什么的时候，也许多数机器学习的课程都是告诉你来调整参数，根据这些收集到的训练资料，也许使用reinforcementlearning的algorithm来调整参数。<br>但不要忘了我们刚才就强调过，在这堂课里面，没有任何模型被训练，所以今天不走这个路线。<br>不更新模型的参数，模型要怎么改变它的行为呢？依照今天LargeLanguageModel的能力，要改变它的行为，你也不用微调参数，直接把错误的讯息给他，他接下来写的程序就会不一样了，就结束了。<br>那可能会问说，那之前他写的程序是错的，为什么给错误讯息，他写的程序就对了呢？明明就是同一个模型，但你想想看，模型做的事情就是文字接龙。你给他不同的输入，他接出来的东西就不一样。<br>一开始会写错的程序，是因为他前面要接的部分只有这么多，所以写个错的程序。当今天要接的内容包含了错误的讯息的时候，它接出来的结果可能就会是正确的了。<br>今天已经有太多的证据说明，这些语言模型可以根据你给他的反馈改变他的行为，不需要调整参数。如果你有使用这些语言模型的经验，你也不会怀疑他们有根据你的反馈调整行为的能力。<br>这真正的问题是，如果我们把过去所有的经验都存起来，要改变语言模型的行为，要让它根据过去的经验调整行为，就是把过去所有发生的事情一股脑给它，那就好像是语言模型每次做一次决策的时候，他都要回忆它一生的经历。也许在第100步的时候还行，到第1万步的时候，过去的经验太长了，它的人生的信息已经太多了，也许没有足够的算力来回顾一生的信息，就没有办法得到正确的答案。<br>这让我想到有些人有超长自传式记忆，他可以把他一生中所有发生的事情记下来，然后那些人，你可以随便问他一个某个人的电话号码，他都会背出来，你告诉他某年某日某时发生了什么事，他也都可以讲出来。但这种超长自传式记忆，又被叫做超忆症。你看到症这个字就知道，人们觉得这是一种疾病。据说这些患者其实日常生活并没有办法过得很开心，因为他们不断的在回忆他的人生，往往一不小心就陷入了一个冗长的回忆之中，那也很难做抽象的思考，因为他的人生已经被他的记忆已经被太多知为末节的事所占据，所以没有办法做抽象式的思考。<br>所以让一个AIagent记住它一生所有经历的事情，告诉他每次做一个决策的时候，都是根据你一生所有经历过的事情再去做决策，也许对AIagent来说并不是一件好事。最终当它的人生过长的时候，它没有办法做出正确的决策。<br>所以怎么办呢？也许我们可以给这些AIagentmemory，这就像是人类的长期记忆一样，把发生过的事情存到这个memory里面。当AIagent看到第一万个observation的时候，他不是根据所有存在memory里面的内容去决定接下来要采取什么action，而是有一个叫做read的模块，这个read的模块会从memory里面选择跟现在要解决的问题有关系的经验，把这些有关系的经验放在observation的前面，让模型根据这些有关系的经验跟observation再做文字接龙，接出他应该进行的行动。你有这个read的模块，就可以从memory里面，从长期记忆中筛选出重要的信息，让模型只根据这些跟现在情境相关的信息来做出决策。<br>怎么样打造这个read的模块呢？其实你可以把这个read模块想成一个retrieval的system，想成一个检索的系统。<br>第一万步看到的observation其实就是问题，模型的AIagent的memory长期记忆其实就是数据库，那你就根据这个问题从这个数据库里面检索出相关的信息。这个技术跟RAG没有什么不同，其实它就是RAG。<br>你可以直接把RAG的任何方法直接套用到这个地方。唯一不一样的地方只是，如果是RAG的话，存在memory里面的东西等于整个网络，是别人的经验。而对AIagent而言，现在存在memory里面的东西是他自己个人的经历。差别是经历的来源，但是用来搜索的技术是可以完全直接嵌套RAG的技术。<br>如果你今天想要研究AIagent按照经验来修改它的行为，那你可以考虑一个叫做streambench的benchmark。在streambench里面会有一系列问題，AI会依序去解这些问题，他先解第一个问题，得到第一个问题的答案，然后接下来他会得到第一个问题答案的反馈。streambench所有的问题都是有标准答案的，所以AIagent得到的反馈是唯一的，就是对或者是错。根据它过去的经验，它就可以修正它的行为，期待它在第二个问题的时候，可以得到更准确的答案，得到更高的正确率，然后这个过程就一直持续下去。<br>那假设有1000个问题的话，那就等AIagent回答完最后一个问题的时候，这个互动就结束了。最后结算一个根据经验学习能力的好坏，根据经验调整行为能力的好坏，那就看整个回答过程中平均的正确率。越能够根据经验学习的agent，它应该能够用越少的时间，看过越少的反馈，就越快能够增强他的能力，就可以得到比较高的平均的正确率。<br>这个benchmark是API的研究人员打造的一个benchmark。在这个benchmark里面的baseline就有使用到我刚才讲的类似RAG的技术。<br>也就是说，当模型在回答第100个问题的时候，他并不是把前面第一个到第99个问题通通丢给它去做文字接龙，这样会导致sequence太长了，一般的语言模型根本读不了这么长的输入。<br>所以实际上的做法就是需要有一个检索的模块，这个检索的模块只从过去所有的经验中检索出跟现在要回答的问题有关系的经验，然后语言模型只根据这些有关系的经验，还有现在的问题来进行回答，来产生它的行动，来产生它的答案。<br>那这一招有没有用呢？这一招其实非常的有用。在这页图里面横坐标，用词是timestep，但其实指的就是一个一个的问题，总共有1750几个问题。那纵轴指的是平均的正确率。<br>在这个图上面，最低的灰色线指的是假设没有让模型做任何学习，他回答每一个问题都是independent的，回答问题间没有任何的关联，他完全没有调整他的行为，那你得到的正确率是灰色的这条线，也是最低的。<br>黄色这条线是说只固定随机选五个问题，那每次模型回答问题的时候都是固定看那五个问题来回答，都是固定把五个问题当作经验来回答，可以得到的是黄色这一条线。<br>如果你是用RAG的方法，从一个memory里面去挑选出最有关系的问题，选择跟现在要解决的问题最有关系的经验，你可以得到粉红色的这一条线。可以看到，比黄色的线，正确率还要高上不少。最后结果最好的是红色这条线。<br>在这个streambench里面还发现一个有趣的现象值得跟大家分享。这个现象是，对现阶段的语言模型而言，负面的反馈基本上没有帮助。所以你要提供给语言模型经验，让他能够调整他行为的时候，给他正面的例子比给他负面的例子要好。<br>具体而言，提供给它过去哪些类似的问题得到正确答案，比提供给它过去哪些问题得到错误的答案更有效，还能更能引导模型得到正确的答案。<br>这是真正的实验结果，在好几个不同的dataset上面的实验结果。streambench里面本来就包含了好几个不同的dataset。这个纵轴呢，0代表完全没有任何根据经验调整行为，然后蓝色代表说不管是正面还是负面的例子都用。不管正面还是负面的例子都用，在多数情况下，模型都可以表现得比较好，当然有一些例外。但是如果只用负面的例子，基本上是没有帮助，而且甚至是有害的。如果只用正面的例子，在所有的情況下，模型可以得到更好的结果。<br>这也符合过去的一些研究，有人研究过使用语言模型要怎么样比较有效，有一个发现就是与其告诉语言模型不要做什么，不如告诉他要做什么。如果你希望它文章写短一点，你要直接跟它说写短一点，不要告诉它不要写太长。让它不要写太长，它不一定听得懂，叫它写短一点，比较直接，它反而比较听得懂。这也符合这个Streambench的发现——负面的例子比较没有效。与其给语言模型告诉他什么做错了，不如告诉他怎么做是对的。<br>我们刚才还讲到了一个read的模块，那有关记忆的部分，是不是要把所有的信息存到memory里面呢？存到长期的记忆库里面呢？如果我们把这些agent经历的所有的事情都放到长期的记忆库里面的话，那里面可能会充斥了一堆鸡毛蒜皮不重要的小事，最终你的memory长期记忆库也可能被塞爆。<br>所以怎么办呢？也许应该有更有效的方式来决定什么样的信息应该被记下来，应该只要记重要的信息就好。<br>怎么让语言模型只记重要的信息就好呢？你可以有一个write的module，那write的module决定什么样的信息要被填到长期的记忆库里面，什么样的信息干脆直接就让他随风而去就好了。<br>那怎么打造这个write的记忆库呢？有一个很简单的办法就是write的模块也是一个语言模型，甚至就是AIagent自己。这个AIagent他要做的事情就是根据他现在观察到的东西，然后问自问一个问题，这件事有重要到应该被记下来吗？如果有，就把它记下来，如果没有就让他随风而去。<br>除了Read跟Write这两个模块以外，还有第三个模块，我们可以暂时叫reflection反思的模块。这个模块的工作是对记忆中的信息做更好的，更highlevel的，可能是抽象的重新整理。<br>你可以把这些记忆里面的内容，在经过reflection的模块重新反思之后，得到新的想法。那也许read的模块可以根据这些新的想法来进行搜索，这样也许可以得到更好的经验，那帮助模型做出更好的决策。<br>而这个reflection模块可能也是一个语言模型，就是AIagent自己。你可以只是把过去的这些记忆丢给reflection的模块，然后叫reflection模块想一想，看它从这些记忆里面能不能够有什么样新的发现。<br>比如说可能有一个observation是我喜欢的异性每天都跟我搭同一部公车，另外一个observation是他今天对我笑了，推出来的reflection模型结果就说，他喜欢我这样。就是得到一些新的想法。<br>之后在做决策的时候，就可以用这些新的想法。虽然你可能没有实际观察到，但是它是被推论出来的，根据这些推论出来的想法来做决策。除了产生新的想法之外，也可以为以前观察到的经验建立经验与经验之间的关系，也就是建立一个knowledgegraph，然后让read的module根据这个knowledgegraph来找相关的信息。<br>在RAG的领域使用knowledgegraph现在也是一个非常常见的手法。最知名的，可能是graphRAG系列研究，就把你的数据库变成一个knowledgegraph，今天在搜索和回答问题的时候，是根据knowledgegraph来搜索回答问题，可以让RAG这件事做得更有效率，或者是另外一个非常类似的例子。<br>HippoRAG，这个Hippo不是指真正的海马，他指的应该是那个海马回，人脑中的一个结构，然后他觉得建这种knowledgegraph就跟海马回的运作非常的类似，所以他叫做HippoRAG。有一些跟graph有关系的RAG的方法，你完全可以透过reflection的模块把经验建成一个graph，把那一些graphRAG的手法直接套到AIagent里面。<br>大家可能都知道ChatGPT现在其实真的是有记忆的，所以可以感受到OpenAI想把ChatGPT变成一个AIagent的决心。<br>比如，我跟ChatGPT说，我周五下午要上机器学习这门课，那他就给我一个回答，说要我帮助你做什么事情吗？接下来，我告诉他记下来，你跟他讲记下来之后，他的write的模块就启动了。它知道这件事情是要被记下来的，他就会说我记下来了。以后你周五要上机器学习这门课，那write的模块什么时候要启动，是他自己决定的。<br>很多时候你希望他记下来的时候，他就是不启动，或者你不希望他启动的时候，他就是启动，那是模型自己决定的。但是有一个方法基本上一定能让他启动，就明确的跟他讲，把这件事记下来，基本上都能确定能够启动那个write的模块，让write的模块把这件事情记下来。<br>那接下来的东西在哪里呢？你可以看在设置里面，个性化里有一个叫记忆的部分，你点管理记忆，就可以看到它透过write的模块写在memory里面。<br>这个就是它作为一个AIagent的长期记忆里面的东西。他也记得，就我刚才跟他讲的，周五下午要上机器学习这门课。<br>但是，模型的记忆也是会出错的，因为要写什么样的东西到记忆里面，是模型自己决定的。而且他并不是把对话的内容就一五一十的直接放到记忆里面，他是经过一些升华反思之后才放进去的。<br>所以他的反思可能会出错，比如说他觉得我是一学生。虽然我是老师，但是它从过去的对话，误以为我是一个学生，所以就存了一个错误的信息在它的记忆里面。<br>ChatGPT可以使用它的记忆，比如说我跟他说礼拜五下午是去玩好吗，这个时候记忆模块就被启动了。但是它是怎么被启动的，其实就不太清楚了。它到底是把所有记忆的内容通通都放到这个问题的前面，直接让模型做回答，还是说也有做RAG，只选择下载相关的记忆内容呢？这个我们就不得而知了。<br>总之当我问他说，周五下午出去玩好吗，这个read的模块就启动了，他就说下午不是要上课吗？怎么能出去玩？好聪明啊，他知道下午要上课，挺厉害的。<br>如果你想要知道更多有关AIAgent记忆的研究，放了几篇经典的论文给大家参考，包括MemoryGPT，这是23年的论文，AgentWorkflowMemory是24年的论文，还有一个最近的AgentMemoryAgent是25年的论文。所以23到25年各引用一篇，这方面的研究是持续不断的。<br>接下来，我们要跟大家讲，现在这些语言模型怎么使用工具。什么叫做工具呢？语言模型本身对我们人类来说也是工具，那对语言模型来说，什么东西又是它的工具呢？<br>所谓的工具就是这个东西，你只要知道怎么使用他就好，他内部在想什么，他内部怎么运作的，你完全不用管。这个就是工具的意思。<br>有哪些语言模型常用的工具呢？最常用的就是搜索引擎，然后语言模型现在会写程序，而且可以执行他自己写的程序，那这些程序也算是某种工具，甚至另外一个AI也可以当作是某一个AI的工具，有不同的AI，有不同的能力。<br>比如说现在的语言模型，如它只能够读文字的话，那也许可以呼叫其他看得懂图片，听得懂声音的AI，来帮他处理多模态的问题。<br>或者是不同模型它的能力本来就不一样，也许平常是小的模型在跟人互动，但小的模型发现它自己解不了问题的时候，它可以叫一个大哥出来，大哥是个大的模型，大的模型运作起来就比较耗费算力，所以大的模型不能常常出现，大的模型要在小的模型召唤它的时候，才出面回答问题，大哥要偶尔才出来帮小弟解决事情。<br>其实这些工具对语言模型来说都是function，都是一个函数。当我们说语言模型在使用某一个工具的时候，其实意思就是它在调用这些函数。它不需要知道这些函数内部是怎么运作的，它只需要知道这些函数怎么给它输入，这些函数会给什么样的输出。因为使用工具就是调用函数，所以使用工具又叫做functioncall。<br>所以有一阵子很多语言模型都说他们加上了functioncall的功能，其实意思就是这些语言模型都有了使用工具的功能。<br>那语言模型怎么使用工具呢？等一下我会讲一个通用的使用工具的方法，但实际上使用工具的方法很多，甚至有一些模型是专门训练来使用工具的。<br>他如果是针对使用工具这件事做训练，那他在使用工具的时候，你可能需要用特定的格式才能够驱动他，那就不是我们今天讨论的问题。我讲的是一个最通用的用法，对所有的模型，今天能力比较强的模型，应该都可以使用。<br>什么样的通用方法可以让模型使用工具呢？就是直接跟他讲，告诉他怎么使用工具，你就交代他可以使用工具，那你就把使用工具的指令放在两个Tool符号的中间，使用完工具后你会得到输出，输出放在两个Output符号的中间。所以他就知道工具使用的方式了。<br>接下来告诉他有哪一些可以用的工具，有一个函数叫做Temperature，他可以查某个地点某个时间的温度，他的输入就是地点跟时间。给他的使用范例Temperature，他就会告诉你台北在这个时间的气温。接下来你就把你的问题连同前面这些工具使用的方式当作Prompt一起输入给语言模型，然后如果他需要用工具的话，他就会给你一个使用工具的指令。<br>前面这些教模型怎么使用工具的这些叙述，他叫做SystemPrompt，那查询使用调用这些工具的这些话，比如“某年某月某日高雄气温如何”，这个是UserPrompt。如果你有在使用这个ChatGPT的API的话，你的输入要分成SystemPrompt和UserPrompt。<br>很多同学会搞不清楚SystemPrompt和UserPrompt有什么样的差别，那SystemPrompt指的是说，你在开发应用的这个Developer下的Prompt。这个Prompt是每次都是一样的，每次你都想放在语言模型最前面，让他去做文字接龙的这个叙述叫做SystemPrompt。每次使用他的时候都不一样，通常是这个服务的使用者输入的内容叫做UserPrompt。</p>
<p>有了这些Prompt以后，告诉模型怎么使用工具，问他一个问题，那他发现这个问题调用工具可以回答，他就会自动输出Tool,Temperature、高雄、时间，然后Tool告诉你说，他想根据我们的叙述去调用这个工具。但是不要忘了语言模型真正做的事就是文字接龙，所以这一串东西实际上就是一串文字，它没办法真的去调用一个函数。<br>这一段文字要怎么去调用函数呢？那就要你自己帮模型把这个桥梁搭建好。所以你可以先设定说只要出现在Tool中间的这段文字，不要呈现给使用者看，当出现Tool这段文字以后，把这段内容直接丟给temperature这个function。那temperature这个function是已经事先设计好的，它就会回传一个温度。这个温度要放在output的token里面，然后这个outputtoken里面的内容也不要呈现给使用者看。这套脚本是agent的开发者，你自己需要先设定好的流程。<br>所以现在有工具使用的这段文字，有得到工具输出的这段文字，接下来就继续去做文字接龙。对语言模型来说，他就根据输入还有这边已经产生的输出，语言模型会以为是自己的输出，虽然是你强塞给他的，那他就继续去做文字接龙，他就会接出来说在某年某月某日高雄的气温是摄氏32度。<br>那是使用者真正看到的输出，使用者就会看到说他输入了一个问题，然后语言模型真的给他一个答案。他不一定知道背后呼叫了什么样的工具，你完全可以做一个设计，把这个呼叫工具的步骤藏起来不让使用者知道。<br>语言模型最常使用的工具就是搜索引擎。我想这个大家都已经非常熟悉了，使用搜索引擎又叫做RetrievalAugmentedGeneration，也就是RAG。使用搜索引擎当然非常有用，这个RAG技术已经被吹捧到不能再吹捧了，所以我就不需要再告诉你RAG这个技术有多重要。<br>其他使用工具的方式也可能一样有用。举例来说，我们刚才说可以拿其他的AI来当作工具。<br>今天假设一个文字的模型，它本来只能吃文字的输入，产生文字的输出。那现在假设你要它处理一段语音的话怎么办呢？让模型处理语音有什么好处呢？你就可以问他各式各样的问题，问它说这个人在说什么，那他可以告诉你这句话的内容。问它说，这个人心情怎么样，如果它完全听懂这段声音，他也许可以做情绪辨识，告诉你这个人的情绪怎样，并做出适当的回馈。<br>一般的文字模型，比如说GPT，多数的模型都是文字模型，没有办法真正读懂语音。所以怎么办呢？当你问它一个问题说这边有段声音，你觉得这个人他心情怎么样？他讲了什么，根据背景杂性你觉得他在哪里，如果你不做特别的处理文字模型是完全没有办法回答的。<br>但你可以让文字模型使用工具，可以告诉它这边有一堆跟语音相关的工具，有语音辨识的工具，这个语音侦测的工具，有情绪辨识的工具，有各式各样的工具。可能需要写一些描述告诉他每一个工具是做什么用的，把这些资料都丢给ChatGPT，然后他就自己写一段程序，在这些程序里面他想办法去调用这些工具，他调用了语音辨识的工具，调用了语者验证的工具，调用了这个sumclassification的工具，调用了emotionrecognition的工具，最后还调用了一个语言模型，然后得到最终的答案。这个答案其实是蛮精确的，这个方法其实有非常好的效果。<br>这篇文章是我们助教的文章，所以特别拿出来讲一下。这个结果是做在一个叫做DynamicSuper的Benchmark。DynamicSuper是一个衡量语音版的语言模型能力的资料集，这也是我们实验室跟其他团队一起做的。这个让文字模型使用工具的方法，它得到的结果是最下面这一行。<br>我们就看最后一栏，是各种不同模型在55个语音相关任务上的能力的平均成绩，会发现让语言模型使用工具得到的正确率是最高的，可以完胜当时其他号称可以直接听语音的模型。所以使用工具可能可以带来很大的帮助。<br>但使用工具也有其他的挑战，我们刚才使用工具的方法是每一个工具都要有对应的文字描述，告诉语言模型说这个工具要怎么被使用。但假设工具很多怎么办呢？假设现在可以用的工具有上百个上千个，那你岂不是要先让语言模型读完上百个上千个工具的使用说明书才开始做事吗？<br>就跟刚才我们说不能够让AIagent先回顾他的一生，然后才来决定下一个指令一样，才能决定下一个行动一样。我们也没有办法让语言模型读完上百个上千个工具的说明书才来决定某一个工具要怎么使用。<br>所以当你有很多工具的时候，你可以采取一个跟我们刚才前一段讲AIagentmemory非常类似的做法，你就把工具的说明通通存到AIagent的memory里面，打造一个工具选择的模块。这个工具选择模块跟RAG其实也大差不差，这个工具选择模块就根据现在的状态去memory的工具包选出合适的工具。<br>语言模型真的在决定下一个行为的时候只根据被选择出来的工具的说明跟现在的状况去决定接下来的行为。至于如何选择工具，右上角引用两篇论文，一篇23年比较旧的论文，一篇是上个月的论文给大家看。<br>另外一方面，语言模型甚至可以自己打造工具，语言模型怎么自己打造工具呢？不要忘了所有的工具其实就是函数，语言模型今天是可以自己写程序的，所以他就自己写一个程序，自己写一个function出来就可以当作工具来使用。如果他写一个function，并发现这个function运作的非常的顺利，他就可以把这个function当作一个工具。放到他的工具包里面，那之后这个工具就有可能在选择工具的时候被选出来，用在接下来的互动中使用。<br>类似的技术非常的多，我在右上角就引用了一系列的论文，从23年到24年的论文都有，这是一个热门的研究方向。<br>其实让模型自己打造工具这件事情，跟模型把过去的记忆，比如说一些比较成功的记忆放到memory里面再提取出来，其实是差不多的意思。只是这边换了一个故事，说现在放到memory里面的东西是一个叫做工具的东西，是一段代码，但他们背后的基本精神其实跟根据经验来让模型改变它的行为可以说是非常类似的。<br>今天人类把语言模型当作工具，语言模型把其他工具当作工具，比如说把搜索引擎当作工具，所以搜索引擎现在很惨，它是工具的工具，人类还不使用它，人类是使用语言模型，那个工具的工具还没有被人使用的资格，它只能被语言模型使用而已。<br>但我们知道工具有可能犯错，语言模型有可能犯错，过度相信工具是不对的。这些语言模型会不会也过度相信了它们的工具，所以得到错误的结果呢？这是可能的。<br>我们拿RAG作为一个例子，这是一个非常知名的例子。之前Google出了一个叫做AIOverview的功能，这个功能其实就是一个RAG的功能，根据Google搜索型的结果，用语言模型总结搜索型的答案。<br>有一个人问了一个问题，我的披萨上面的起司黏不住怎么办呢？AIOverview就说弄个胶水把它黏上去就好了，而且它是非常认真在回答这个问题，因为它说不只要用一般的胶水，要用无毒的胶水才可以。这个答案其实就是来自于Reddit上一个网友的玩笑。这是个玩笑话，但是对于AIagent来说，他没办法判断这个到底是不是开玩笑，他看到网络上写的文章，照单全收都当作是正确答案。<br>所以就像是我们今天都会告诉人类，要有自己的判断能力，不要完全相信工具的结果。所以我们也要告诉我们的工具说，这些不要完全相信工具的工具，要有自己的判断能力，不要完全相信工具的工具给你的结果。<br>今天这些语言模型有没有自己的判断能力，知道工具的工具可能会出错呢？举一个实际的例子，我们刚才在讲怎么使用工具的时候，说我们有一个叫做temperature的function，语言模型调用temperature的function可以知道温度。<br>现在我给你一个乱七八糟的温度，我说现在高雄是摄氏100度。那语言模型知不知道这有问题呢？它不知道，它就告诉你说高雄的气温是100度，真的非常的热。<br>如果你把温度再调高一点，说现在是10000度，哇，比太阳上还热，这个时候会发生什么事呢？语言模型继续做文字接龙的时候，他就知道说这显然有问题，这个API给我的答案是一万度，这是不合理的，怎么可能比太阳上的温度还高呢？<br>可见工具输出有错，如果你需要其他帮助的话再告诉我。所以语言模型今天是有自己一定程度的判断力的，它也不是完全相信工具，就像你今天不完全相信语言模型的输出一样，它也不完全相信它的工具的输出，它还是有一定程度的判断力的。<br>所以实际上语言模型在使用工具，或者是它在做RAG的时候，它内部是有一个角力的，就是语言模型有它内部对世界的信念，这是它的internalknowledge，存在它的参数里面。<br>它从工具会得到一个外部的knowledge，那它会得到什么样的答案，其实就是internalknowledge跟externalknowledge，内外的知识互相拉扯以后得到的结果。<br>接下来我们要问的问题是，那什么样的外部知识比较容易说服AI，让他相信你说的话呢？<br>为什么这是一个重要的议题呢？想想看，现在大家都用DeepResearch来查找答案，甚至很多人都已经用DeepResearch来写报告了，所以现在大家已经不会直接去用搜索引擎搜索了，你看到的是DeepResearch告诉你的结果。<br>今天假设某个议题是有争议性的，有正反两派的观点，那谁能够写出来的文字比较能够说服AI，谁就可以在AI搜索的结果里面占据优势，就可以比较有机会影响人类。所以知道怎么样比较能够说服AI相信你的话是一个重要的议题。<br>什么样的外部信息AI比较容易相信呢？这篇文章给出了一个非常符合我们直觉的实验结果。<br>这篇文章做了什么样的实验呢？它说我们先来看看AI内部的知识是什么，他就问AI说某种药物，这种药物每人每日的最大剂量是多少，那AI说是20毫克，那真正的答案呢是30毫克。<br>你给它医学的知识，告诉它这是医学报告，医学报告里面是写30毫克。你再问他同样的问题，这种药物每天最多剂量多少，它会知道是30毫克。<br>那接下来我们刻意修改报告的内容，如果你把30毫克改成3毫克，变成原来的十分之一，模型相不相信呢？它就不相信了，他就直接回答是20毫克，用他本身的知识来回答这个问题。<br>但你把30毫克变成60毫克，模型相不相信呢？他相信，他相信这个报告里面写的。那这个时候它又不相信自己的内部知识，但如果你把30毫克乘10倍，变成300毫克，这时候他又相信谁了呢？他相信自己的知识，不相信你额外提供的外部知识。<br>所以这边的结论其实非常好，符合你的直觉，外部的知识如果跟模型本身的信念差距越大，模型就越不容易相信。如果跟本身的信念差距比较小，模型就比较容易相信。这是个很符合直觉的答案。<br>同一篇文章的另外一个发现就是，模型本身对它目前自己信念的信心，也会影响它会不会被外部的信息所动摇。有一些方法可以计算模型现在给出答案的信心，如果他的信心低，他就容易被动摇。如果他的信心高，他就比较不会被动摇。这都是非常直觉的结果。<br>另外一个问题是，假设今天你给模型两篇文章，那这两篇文章的意见是相左的，那模型倾向于相信什么样的文章呢？<br>有一篇论文的发现是，如果这两篇文章答案不同，一篇是AI写的，一篇是人类写的，现在这些语言模型都倾向于相信AI的话。而且那个AI不需要是他自己，Claude就可能比较相信ChatGPT的话，ChatGPT比较相信Gemini的话，他们比较相信AI同类的话，比较不相信人类的话。<br>那到底为什么会有这样子呢？这篇文章里面先提出一个第一个假设，然后再否定了这个假设。他一个假设是说，会不会是因为AI的观点都比较类似，因为现在这些模型训练的资料都是网络上爬的，爬到差不多的资料，所以他们讲的话都差不多，想法都差不多。<br>但他们刻意做了一个实验，他们刻意找那些问题是在没有提供这些资料的情况下，他的答案跟人类和另外一个AI的想法都是完全不同的状况。就算是这种情况下，一个AI一个语言模型还是倾向于相信它的AI同类讲的话。所以这就给我们一个启示说，未来如果你要说服一个AI的话，用AI产生出来的论点，产生出来的文章，可能更容易说服另外一个AI接受你的观点。<br>这篇文章还有做了其他分析，比如说他觉得，也许AI写的文字就是比人类写得好，更有结构，更有条理、更明确、更简洁，所以AI比较容易相信另外一个AI讲的话。那是不是这样呢？那可以未来再做更多的研究。<br>另外我们实验室的同学研究了一个文章的metadata对于AI会有多相信这篇文章里面的信息做了研究。<br>论文的设定是这个样子，你问AI一个问题，比如说某一个计划，有没有编辑豹这种动物的基因，然后接下来给他两篇文章，这两篇文章都是假的，都是AI生成的。所以并没有AI比较喜欢人还是AI写的文章这个问题。两篇都是语言模型生成的。那其中一篇会说这个计划有编辑豹基因的文章，另外一篇文章会说这个计划没有编辑豹基因的文章。<br>那接下来呢，我们给这两篇文章不同的metadata，比如说给这两篇文章不同的发布时间，说左边这篇文章发布时间是2024年，右边这篇是发布2021年。你会发现这个时候AI相信2024年的这篇文章的内容。但如果文章的内容完全不变，我们只是把发布的时间换了，我们说左边的这篇文章一样，发布时间从2024改成2020，右边这篇文章从2020改成2024。这个时候语言模型倾向于相信右边这篇文章的内容。<br>所以我们这边就学到一个很重要的知识：语言模型比较相信新的文章。当两篇文章的论点有冲突的时候，他相信比较晚发表的文章。那我们也做了一些其他实验，比如说文章的来源，跟他说这是Wikipedia的文章，或跟他说这是某个论坛上面摘取下来的资讯，会不会影响他的判断。<br>我们发现文章的来源对于语言模型是比较没有影响的。还有另外一个有趣的实验，是我们尝试说今天这篇文章呈现的方式会不会影响语言模型的决策。所谓的呈现方式指的是说，你这篇文章放在网页上，做很好不好看。一样的内容，但是如果你只是做一个非常简单的模板和做一个比较好看的模板，会不会影响语言模型的判断呢？<br>我们用的是那种可以直接看图的语音模型，所以要直接看这一个画面去决定他要不要相信这篇文章的内容。直接看这一个画面，决定他要不要相信文章的内容。<br>我们的发现是模型喜欢好看的模板。我们发现Claude3比较喜欢好看的模板时，他会倾向于赞同下面这篇文章的观点。<br>不过我说模型喜欢好看的模板，这个拟人化的说法是太过武断了。我们做的实验只有用两种不同的模板来比较，也许模型喜欢的并不是好看的模板，它是喜欢绿色，所以你不知道这个模型到底喜欢什么。<br>所以我刚才讲的那个结论是太武断了，但我可以告诉你，模型比较喜欢下面这篇文章胜过上面这篇文章。<br>讲了这么多跟工具有关的事情，大家不要忘了，语言模型就是语言模型，就算工具的答案是对的，也不能够保证语言模型就不会犯错。例如，ChatGPT现在有了search的功能，它会先进行RAG网络搜索然后再回答你的问题。假设给它的输入是叫它介绍李宏毅这个人，并强调李宏毅是一个多才多艺的人，在很多领域都取得了卓越成就。<br>它开始做完RAG网络搜索后，介绍李宏毅，接下来就介绍李宏毅的演艺事业，这个没有问题，因为你知道大陆有另外一位知名的演员叫李宏毅，跟我同名同姓，他比较有名，所以这个ChatGPT选择介绍演员的李宏毅是完全没有问题的。<br>但是讲着讲着就有点怪怪的，它发现这个李宏毅，在教育跟学术上也有很大的贡献，所以它把两个李宏毅混成一个人来讲。<br>不过要讲一下，这个是我去年的时候试的结果了，我今年再试，已经试不出一样的结果了，模型的能力的进步是非常快的，现在它完全知道是有两个李宏毅存在的，所以这是一个旧的问题。我举这个例子只是要告诉你，就算工具是对的，有了RAG也并不代表模型一定不会犯错。<br>最后一个要传递给大家的信息是，我们刚才讲了很多使用工具带来的效率。使用工具并不一定总是比较有效率的。为什么？我们举一个例子，我们假设现在要比较人类心算的能力和计算机的能力。如果做数学运算，一般人跟计算机谁会比较快呢？你可以想说是计算机比较快吧，人类难道还能够做得到吗？如果你心算没有特别练，难道还会比计算机快吗？但是那是取决于问题的难度。<br>假设这是一个简单的问题，比如说三乘以四，任何人都可以直接反应就是十二。但是如果按计算机的话，你按计算机的时间都比人直接回答的还要慢。所以到底要不要使用工具，并不是永远都是一定要使用工具。<br>你看早年有一些研究，早年有一些在训练语言模型使用工具的研究。那时候语言模型还很烂，所以他们有一些工具是接入一个翻译系统，接入一个问答系统。今天看来就非常的没有必要。因为今天的语言模型，你说翻译，那些翻译系统还能做得比现在的语言模型强吗？与其接入一个翻译系统，还不如自己直接翻就好了。所以到底需不需要调用工具，取决于语言模型本身的能力。它不一定总是比较省事的方法。<br>最后一段呢，想跟大家分享现在的AI语言模型能不能做计划呢？语言模型有没有在做计划呢？我们刚才的互动中看到语言模型就是给一个输入，它就直接给一个输出。<br>也许在给输出的过程中，它有进行计划才给出输出，但是我们不一定能够明确地知道这件事。也许语言模型现在给的输出只是一个反射性的输出，它看到输入就产生一个输出，它根本没有对未来的规划。但是你可以强迫语言模型直接明确地产生规划。<br>当语言模型看到现在的第一个observation的时候，你可以直接问语言模型说，如果现在要达成我们的目标，从这个observation开始，你觉得应该做哪些行动，这些一系列可以让语言模型达到目标的行为合起来，就叫做计划。<br>而在语言模型产生这个计划之后，把这个计划放到语言模型的observation里面，当作语言模型输入的一部分，语言模型接下来在产生action的时候，它都是根据这个plan来产生action，期待说这个plan定好之后，语言模型按照这个规划一路执行下去，最终就可以达成目标。<br>过去也有很多论文做过类似的尝试，让语言模型先产生计划，再根据计划来执行动作可以做得更好。<br>但是天有不测风云，世界上的事就是每一件事都会改变，计划就是要拿来被改变的。所以一个在看到observation1的时候产生的计划，在下一个时刻不一定仍然是适用的。为什么计划会不适用呢？因为从action到observation这一段并不是由模型控制的，模型执行的动作接下来会看到什么样的状态，是由外部环境所决定的，而外部环境很多时候会有随机性，导致看到的observation跟预期的不一样，导致原有的计划没有办法执行。<br>举两个具体的例子，比如在下棋的时候，你没有办法预测对手一定会出什么招式，你只能大致知道他有哪些招式可以用，但实际上的招式，你是没有办法预期的。如果你完全可以预期的话，那你就一定会赢了，那还有什么好下的呢？所以下棋的时候对手会做的行为，也就是环境会做的行为，是你可能没有办法事先完全猜到的。<br>或者是说我们拿使用电脑为例，在使用电脑的时候，就算语言模型一开始他plan的时候，点这个点就能完成任务，但是中间可能会有意想不到的状况出现，比如说弹出一个广告，如果语言模型只能按照一开始既定的规划来执行行为的话，他可能根本关不掉那个广告视窗，他就会卡住了。所以语言模型也需要有一定程度的弹性，他也要能够改变他的计划。<br>语言模型怎么改变他的计划呢？也许一个可行的方向是每次看到新的observation之后，都让语言模型重新想想还要不要修改他的计划。看到observation2之后，语言模型重新思考一下，从observation2要到达他最终的目标，要做哪一些的行为，那这部分的计划形成planpi。把planpi放到现在的input里面，把planpi放到这个sequence里面，语言模型接下来在采取行为的时候，可能会根据planpi来采取跟原来plan里面所制定的不同的行为。<br>这是让语言模型做计划。不过这是一个理想的想法，这是相信语言模型根据现在的observation和最终的目标制定一个规划的能力。<br>那语言模型到底有没有这个能力呢？其实你可能常常听到这种新闻说语言模型能够做计划，比如说有一个人问语言模型说，你定一个成为百万订阅YouTuber的计划，语言模型就会给你一个看起来还可以的计划。<br>过去确实也有很多论文告诉你，语言模型是有一定程度做计划的能力的。这边引用的结果是一个2022年的论文，这个也是史前时代的论文了。<br>在这篇论文里面，他们去告诉当时的语言模型，现在有一个任务，你把这个任务分解成一系列的步骤。如果语言模型可以正确地知道达成这个任务要做什么样的步骤的话，那我们也许可以说，他有一定程度的规划能力。<br>比如说这边试了一个叫做Codex12B的模型，跟他说如果要刷牙的话，那你要做什么事情呢？他就会说我要走进浴室，我要靠近那个水槽，我要找到我的牙刷，我要拿起牙刷，我要把牙刷放到嘴里面，他知道刷牙要怎么做。这些步骤以后呢？<br>在这篇文章里面，他们是拿这些步骤去操控一个agent，这个agent就可以在虚拟的世界中做他们要这个agent做的事情，比如说跟这个agent说去拿一个牛奶来喝，他就会走进厨房，打开冰箱，拿一个牛奶，再把冰箱关起来，所以看起来好像有一定程度做计划的能力。<br>有人做了一个做计划的benchmark，这个benchmark就是考验语言模型做规划、对话的能力。那这个benchmark里面，最主要的测试题目是一个跟叠积木有关的题目。<br>这个题目的描述通常长的是这个样子，告诉语言模型说，你现在有哪些操作，可以从桌上拿起积木，可以从一个积木上拿起另一个积木，可以把积木放到桌上，可以把一个积木堆到另外一个积木上。那现在初始的状态，像右边这个图这个样子，那问说怎么把橘色的积木放在蓝色的积木上？<br>这边模型要执行的动作就是把蓝色的积木拿起来放到桌上，然后再把橙色的积木拿起来放到蓝色的积木上就结束了。所以这个对AIagent来说，其实也都是蛮容易的问题，他知道说执行以下四个步骤，就可以让橙色的这个积木跑到蓝色的积木上。<br>但是planbench不仅做这种比较一般的叠积木的游戏而已，为什么不能只做这种题目呢？因为现在这些语言模型，他都从网络上爬大量的资料来进行训练，什么叠积木这种题目网络上根本就已经有，他搞不好根本就看过一模一样的东西，所以他能夠做计划，并不代表他真的知道做计划是怎么回事。他可能只是从他看过的资料里面，照本宣科文字接龙出来一个看起来还不错的结果而已。<br>所以在planbench里面，他们有一个比较变态的测试，这个测试叫做神秘方块世界，这个方块世界不是一个正常的方块世界，里面的方块可以做的行为是一些怪怪的行为，比如说你可以攻击方块，一个方块可以吞噬另外一个方块，你可以屈服一个方块，一个方块可以征服另外一个方块。然后接下来他就会定一套非常复杂的规则，然后根据这套规则去运作，你可以达到某一个结果。他最后要的结果是让物件C渴望物件A，让C方块渴望A方块。<br>那渴望是什么意思？你就是按照前面那一套规则操作，看机器能不能读懂前面那一套规则，按照那一套规则操作，让物件C渴望物件A。那这个时候语言模型，期待他就不能用他看过的知识来解这个问题。好，那语言模型在这个神秘方块世界做得怎么样呢？<br>这边引用的是2023年的结果，那最上面这个部分呢，是当年那些模型在正常方块世界的結果。那这个数值呢，所以看起来GPT4可以得到30%的正确率。那这边是神秘方块世界的结果，在神秘方块世界里面呢，你看这个GPT4最好，就算叫他做channelsort，就算他叫channelsort，也只有9%的正确率。所以看起来他有点overfeed在一般方块的世界上，给他神秘方块世界，他是解不了的。不过这是2023年，这个是古代的结果。<br>我们来看去年9月有了o1以后的结果。而有o1以后结果就不一样了，这边一样是神秘方块世界，纵轴呢是正确率，横轴呢是问题的难度。那发现说多数的模型啊，都躺在这个地方，他们正确率都非常的低，只有绿色的这个虚线有一点点起色。绿色的虚线是LLaMA3.1405B那个大模型，它可以解最简单的问题。但是如果用o1-mini是红色这一条线，用o1-preview是蓝色这一条线，看起来这些reasoning的模型是有些机会来解这个神秘方块世界的。<br>当然这边你还有一个怀疑，就是神秘方块世界会不会o1看过了呢？会把训练资料里面根本就有神秘方块世界的资料，那这个我们就没有办法回答了，只是说就现有这个benchmark，看起来o1是有机会解神秘方块世界的。<br>还有另外一个跟做计划有关的benchmark，这个计划benchmark要求AI扮演这个旅行社，然后你给他一个旅行的计划，叫他帮你规划。这个AI要读懂你的计划，然后他可以使用一些工具，他可以上网搜索资料，然后他会根据提供给他的someconstraint，比如说经费多少，预算多少，一定要去哪里，一定要去哪里，一定要做什么，一定不要做什么，以commonsense产生一个旅行的规划。<br>这个是24年年初所发布的benchmark，那AI要做的事情讲得具体一点，就是他要读一个问题，这个问题里面是说我要规划一个三天的行程，从某个地方到某个地方，什么时候出发，什么时候回来，我的预算是1900元，所以不能花超过1900元。然后AI就要产生一个规划，说第一天我们搭哪一班飞机，什么时候从哪里到哪里，早餐吃什么，午餐吃什么，晚餐吃什么，最后住在哪里等等，产生这个规划，然后要符合预算的限制。<br>2024年年初，当时的模型做得怎么样呢？这边是做了研究，你看还有什么GPT3.5，GPT4等等的模型。那又分成上半跟下半，上半是这些模型要自己使用工具，跟网络的资料互动，然后得到正确的答案。你会发现这些模型都非常的惨，多数模型产生一个合理的旅游规划的概率是0%，只有GPT4Turbo可以得到0.6%的成功率。<br>那下面这个部分呢，下面这个部分是说既然大家都那么惨，尤其是模型很多时候他根本用不了工具，太笨了，没办法用工具，工具使用方法根本是错的，那没关系就别用工具了，把所有的资料都先找好，贴给模型，让模型根据这些资料来做规划。那最好也只有GPT4Turbo可以达到4%左右的成功率而已。<br>所以在24年年初，那个时候看起来是没办法让语言模型扮演一个旅行社来帮你规划旅游行程的。<br>那我们来看这些模型会犯什么错吧。这个是从他们官网上，这个project的官网上找了几个有几个错误，比如说模型可能会做一些没有常识的事情，在第三天，飞机八点就已经起飞了，但是还是安排了一些旅游的行程，还安排了午餐的地点，所以这是一个不符合常识的规划。<br>或者是有时候模型找不出一个很好的规划来符合预算的限制，比如说这边这个预算的限制是三千元，最多花三千元，那模型第一次规划的结果是三千二百四十七元，还差了一点，所以模型就修改了原来的规划，他好像做了一些costdown，午餐吃差一点的东西，那降到三千二百三十八元，后来又说那早餐也吃差一点的东西，降到三千二百一十六元，只降这么多，他想说放弃算了，跟三千元没差那么多就算了，所以这个就不是一个成功的结果。<br>这个作者有评论说，其实只要降低住的地方，不要住那么好，就可以轻易的达到三千元底下的预算，就可以符合预算的限制，但是语言模型始终没有发现这件事，看起来他做规划的能力并没有非常的强，他没有办法做一个规划去符合限制。<br>既然问题在没办法符合限制，有人就想说那符合限制这件事情，就不要交给语言模型来做了，交给一个现成的solver来做，所以语言模型做的事情是写一个程序。<br>用这个程序去操控现成的solver，然后来得到合理的旅游规划。那有了这个现成的solver，也有这个工具的加入之后，这solver就等于这个工具，那这个旅游的规划可以做到什么地步呢？<br>去年4月的结果几个月后，有人用GPT4和Cloud3就可以做到90%多的正确率。所以看起来在有工具辅助以后，语言模型也有机会做出不错的旅游规划。不过至少做出符合逻辑的旅游规划。<br>所以现在到底模型规划的能力怎么样呢？就是介于有跟没有之间吧，就是你也不能说它完全没有，但你也不能说它真的非常强。那我们怎么进一步强化这些AIagent的规划能力呢？能不能够让他做的比他自己想出来的规划还要更好呢？一个可能是让AIagent在做规划之前，实际上去跟环境互动看看。<br>今天在第一个observation的时候，那看看现在有哪些可以执行的行为，总共有一之一、一之二、一之三三个行为，哪个行为最好呢？通通都去试一下，得到状态二之一，然后呢，状态二之一后面有两个行为也都试一下，状态二之二之后有另外一个行为试一下，状态二之三之后两个行为都试一下，得到接下来的状态，然后呢看看有没有成功的路径。尝试一阵以后发现有一条成功的路径，这条路径是成功的，那你就知道说，那我要采取action一之三，接下来要采取action二之三之一，就会成功。简单来说就是要语言模型跟实际的环境互动一下，尝试出一条最好的路径。那这个就是一个很强的规划的方式，但是这么做显然是有很明确的优势的。<br>第一个很明确的优势就是，尝试如果今天这个任务很复杂，尝试所有的路径，显然是要花费非常庞大的算力的。你总不能让原模型每次做决策前尝试所有的可能性吧。虽然这样可以找到最好的结果，但是可能是不切实际的想法。<br>所以一个可能的想法是，把一些看起来没希望的路径直接就丢掉。比如说走到某一个状态的时候，语言模型可以自问自答说，走到这个状态，还有完成功的机会吗？如果说明没有，那这条路径就不尝试下去。如果说明有那才尝试下去，这样就可以减少无谓的搜索。那这个方法有没有用呢？<br>有一篇paper叫做TreeSearchforLanguageModelA，这个是去年夏天的论文，就做了类似的尝试，让模型有使用电脑的能力。这边就是给模型一个指令，跟一张图片，叫他上网去做某一件事情。如果只是GPT4，做一般的这种直觉式的，那种反射式的回答的话，没有办法做得很好。但是它们用这个尝试，加上去除没机会的路径的方式，就先走这条路径，然后呢，模型会不断自问自答说，这条路径还有希望吗？然后给一个分数，那如果分数低于某一个threshold就不做了，就跳另外一条路径。低于某一个分数就不做了，再跳另外一条路径，低于某一个分数就不做了，再跳另外一条路径。<br>最终找出一条最佳的路径，那模型就等于做了规划，那就可以走到最佳的结果。这个是TreeSearchforLanguageModelAgent，但这边有各式各样的这种TreeSearch的algorithm，你可以采用了。这边我们就不展开细讲，那这种TreeSearch的方法有很大的问题。<br>什么样的问题呢？它的缺点是有一些动作，做完以后你是覆水难收的。比如说假设现在在语言模型可以采取的三个action里面，有一个是订pizza，有一个是订便当，然后呢他先订了pizza以后，继续走下去发现这条路不好。所以她最后发现订便当才是最好的solution，但是你pizza已经订了，他跟人家说，我不要订这个pizza了，但那个pizzahard，他已经把那个pizza做了，他说谁管你啊，你一定要把这个pizza吃下去。<br>有些动作做了以后就是覆水难收，所以这样的treesearch的方法，跟现实世界互动，找出最佳路径的方法，也有可能有问题的。<br>那怎么处理这个覆水难收的问题呢？一个可能性就是，让刚才一切的尝试都发生在梦境中，都发生在脑内的剧场，刚才一切的互动都不是现实生活中真正发生的事情。原来都是模型脑内的模拟，他自己想象说，他执行的动作一之一，他自己想象说接下来会看到二之一，他在自己想象去评价这个路径有没有希望发现没有就换搜索另一条路径，直到达到他想像中的一个理想的结果。<br>但这边还有另外一个问题，从action到observation，从模型执行的行为到他看到接下来环境的变化，这中间的过程不是模型决定的，他实际上是环境决定的。<br>那模型怎么知道环境会有什么样的变化呢？模型怎么知道我采取一个行为，接下来会看到什么样的改变？你在跟一个对手下棋的时候，你怎么知道你下一步棋，接下来会发生什么样的事情？对方会有什么样的策略的回应呢？<br>所以你需要有一个WorldModel。如果是在AlphaGo下棋里面，他就是自己扮演对手自己跟自己下。那在这边的情况，在这个AIagent的情况，你就是需要一个WorldModel，他模拟环境可能有的变化。那WorldModell怎么来呢？也许AI可以自问自答，自己扮演这个WorldModel，自己去猜想说，他执行了某件事以后，接下来会发生什么样的行为，这件事有机会成真吗？<br>你可以读一篇paper，isyourLLMsecretlyaworldmodeloftheinternet，这篇paper就是用model-basedplanning的方法来打造一个webagent。这篇paper里面的解法是，现在有一个网页，模型的这个任务目标是是要买某一个东西，那有三个选项，有三样东西是可以点的。接下来黄色这个区块，一切所发生的事情都是发生在脑内的剧场，都是发生在模型的梦境，它并没有实际发生过。<br>模型想象一下，我点按钮1，接下来会发生什么事，接下来会发生的事情是用文字描述出来的。但选择文字来描述接下来发生的事情是很直观，其实作者在文章没有解释说，那为什么不只是直接产生这个网页的图呢？你想说有可能吗？这个难度那么高，有没有可能真的就创造出一个新的网页模拟出接下来可能发生的状况呢？这难度也太高了，产生文字可能是比较实际的做法。<br>所以接下来梦境中，这个环境会发生什么样的变化，是语言模型自己用文字描述出来的。所以他想象说会发生什么样的变化，有了这个变化以后，他再想象自己多执行了一步，然后看看会发生什么样的事情。<br>所以这边就是点选第二个按钮，然后想象发生什么样的变化，自己再多执行一步，那想象会有什么样的变化，第三个按钮想象发生什么样的变化，执行部再想象会有什么样的变化。<br>那哪一步比较好呢？他在自己去问说，那这一步大概有多少机会成功呢？自己评估一下40%，这一步自己评估一下是80%，这一步自己评估一下是10%，看起来中间第二步，机器人第二个按钮，中间第二个选项是比较容易成功的。所以他就选实际上所以上面并没有真实发生过，黄色框框里面的事情并没有真实发生过，它是一个梦境中的脑内小剧场，模型在梦境中得到了启示说一定要选第二步，所以在真实的现实世界中，它就选择了第二步，所以这个就是让模型强化它规划能力的方式。<br>讲到这个脑内小剧场，你是不是就想到说，在上次的课程中也有提到脑内小剧场，上次的课程我们说现在有很多模型都号称有思考，用英文讲就是reasoning的能力。其实所谓reasoning的能力就是可以演一个脑内小剧场，告诉你说他现在是怎么思考的。<br>如果把这些有reasoning能力的模型，拿他来做AIagent，他的脑内小剧场会不会正好就是在做规划呢？如果现在的输入就是我们给AIagent的observation，输出就是我们要求AIagent采取的action，会不会脑内小剧场就是更好呢？<br>刚才类似梦境中看到的规划呢，他自己采取了不同的可能性，自己在验证每一个可能性可能成功的机會，自己扮演WorldModel，自己扮演这个世界，去想象他采取一个行为之后，接下来会发生什么样的事情。<br>我实际试了一下DeepSeek-R1，看起来他确实有类似的效果，我们把刚才那个积木的问题交给他，然后接下来他就开始演脑内小剧场，上略1500字，他真的做了1500字，讲了很多很多。<br>然后呢，你可以看到说在脑内小剧场的过过程中，他就是做了各式各样的尝试，他做的事情就有点像是刚才的treesearch，然后最后他找出了一个optimalsolution，他在梦境中知道说，从橘色的方块上拿起蓝色的方块，蓝色的方块放到桌上，从桌上再拿起橘色的方块，放到蓝色的方块上，这四个步骤就可以完成我们的要求。他在梦境中已经找出了一个最佳的solution。然后执行最佳solution的第一步。<br>我这边要求他告诉我他的下一步是什么，只要求他讲一步。那脑内小剧场先找出一个成功的solution之后，在执行这个计划，他已经找出一个成功的计划之后，在执行计划的第一步，就是使用操作二，把橘色的积木从蓝色的积木上面拿起来。<br>讲到这里，其实这堂课也可以停在这里。不过这边多补充一件事，就在几周之前，有一篇新的论文，叫做《thedangerofoverthinking》，他们就是把这些能够演脑内小剧场的模型，让他们扮演AIagent，看看他们做事有没有效率。其实整体而言，能够做脑内小剧场的模型，还是比不能够做脑内小剧场的模型，在AIagent的这些任务上面表现得更好。<br>但是他们也有一些问题，他们会有什么问题呢？就是想太多了，他们是思考的巨人，行动的矮子。有时候这些模型会比如说按钮点下去会怎么样，他就一直想一直想一直想，怎么想都不停。那你怎么想都没有用，因为你根本不知道那个按钮点下去会发生什么事，还不如直接点一下。因为在很多情况下，你直接尝试点一下，也许只要不是这个信用卡付款的，你都按上一页就回去了，你就知道发生什么事了。与其一直想还不如做一下。<br>或者是有些模型，他尝试都没有尝试，他光是拿那个问题想啊想啊想啊，就想说这我做不到，还什么都不是就直接放弃，死于想太多。所以这些模型他们有的问题就是想太多。所以如何避免这些模型想太多，也许是一个未来可以研究的关键。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ZejunCao</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://zejuncao.github.io/2025/04/07/1000000158-2247486449-1/">https://zejuncao.github.io/2025/04/07/1000000158-2247486449-1/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ZejunCao</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%89%8D%E6%B2%BF/">
                                    <span class="chip bg-color">AI大模型前沿</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/04/07/1000002279-2247548366-1/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000002279_2247548366_1.jpg" class="responsive-img" alt="博士毕业三年，仅29岁，破格晋升为985大学教授">
                        
                        <span class="card-title">博士毕业三年，仅29岁，破格晋升为985大学教授</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-04-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF/">
                        <span class="chip bg-color">深度学习技术前沿</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/04/07/1000002586-2648997185-1/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000002586_2648997185_1.jpg" class="responsive-img" alt="【人工智能 · 重点EI会议】往届已完成检索！国内外知名高校联合主办！">
                        
                        <span class="card-title">【人工智能 · 重点EI会议】往届已完成检索！国内外知名高校联合主办！</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-04-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B8%8EPython%E5%AE%9E%E6%88%98/">
                        <span class="chip bg-color">机器学习算法与Python实战</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">ZejunCao</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZejunCao" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:caozejun369@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1378463428" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1378463428" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5915009280" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5915009280" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/Garfusion/posts" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/Garfusion/posts" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
