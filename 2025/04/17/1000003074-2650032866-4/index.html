<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="大语言模型复杂推理的自我进化机制：研究综述与前沿展望, ZejunCao&#39;Blogs">
    <meta name="description" content="大语言模型复杂推理的自我进化机制：研究综述与前沿展望

仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接

摘要OpenAI的O1及其后续竞争者（如DeepSeekR1）的发布显著推动了大语言模型（LargeLanguage">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>大语言模型复杂推理的自我进化机制：研究综述与前沿展望 | ZejunCao&#39;Blogs</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZejunCao&#39;Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZejunCao&#39;Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/frontcover/1000003074_2650032866_4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">大语言模型复杂推理的自我进化机制：研究综述与前沿展望</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E5%AE%B6/">
                                <span class="chip bg-color">人工智能学家</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-04-17
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/W2DpXeJqLlDsr0VvyqE_ig">大语言模型复杂推理的自我进化机制：研究综述与前沿展望</a></p>
<blockquote>
<p>仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接</p>
</blockquote>
<p>摘要<br>OpenAI的O1及其后续竞争者（如DeepSeekR1）的发布显著推动了大语言模型（LargeLanguageModels，LLMs）在复杂推理方面的研究，引发学术界与工业界的双重关注。此项进展激发了相关技术成果的复现和在此基础上的创新。为系统构建该领域的研究框架，本文从自我进化（self-evolution）的角度系统地分类了现有技术。我们的调查发现分为三个相互关联的部分：数据进化（dataevolution）、模型进化（modelevolution）和自我进化（self-evolution）。<br>数据进化部分改进推理训练数据，这包括任务进化和增强思维链（Chain-of-Thought，CoT）推理的推理时间计算。<br>模型进化部分通过在训练过程中优化模型模块，以增强复杂推理能力。<br>自我进化部分则探讨其进化策略和模式。包括自我进化的规模法则（scalinglaw）与对O1类研究工作的分析。<br>通过系统梳理相关研究，我们总结了前沿方法，并提供了对未来研究方向的前瞻性展望。本文旨在激励LLM复杂推理社区进一步研究，并促进对LLM推理能力提升的深入探索。<br>关键词：大语言模型、复杂推理、自我进化、数据进化、模型进化、专家迭代、推理计算、强化学习<br>来源：集智俱乐部<br>作者：TaoHe,HaoLi,JingchangChen等<br>译者：Azure<br>论文题目：ASurveyonComplexReasoningofLargeLanguageModelsthroughtheLensofSelf-Evolution</p>
<p>目录<br>2.预备知识<br>3.数据演化<br>4.模型演化<br>5.自我进化<br>6.在自我进化框架内重新解读代表性O1类研究<br>7.未来挑战和方向<br>8.结论<br>摘要<br>OpenAI的O1及其后续竞争者（如DeepSeekR1）的发布显著推动了大语言模型（LargeLanguageModels，LLMs）在复杂推理方面的研究，引发学术界与工业界的双重关注。此项进展激发了相关技术成果的复现和在此基础上的创新。为系统构建该领域的研究框架，本文从自我进化（self-evolution）的角度系统地分类了现有技术。我们的调查发现分为三个相互关联的部分：数据进化（dataevolution）、模型进化（modelevolution）和自我进化（self-evolution）。<br>数据进化部分改进推理训练数据，这包括任务进化和增强思维链（Chain-of-Thought，CoT）推理的推理时间计算。<br>模型进化部分通过在训练过程中优化模型模块，以增强复杂推理能力。<br>自我进化部分则探讨其进化策略和模式。包括自我进化的规模法则（scalinglaw）与对O1类研究工作的分析。<br>通过系统梳理相关研究，我们总结了前沿方法，并提供了对未来研究方向的前瞻性展望。本文旨在激励LLM复杂推理社区进一步研究，并促进对LLM推理能力提升的深入探索。<br>1.引言<br>近年来，大语言模型（LLMs）的发展令人瞩目。它们不仅在阅读理解、故事生成和对话能力等领域超出了预期，还在需要复杂逻辑推理的任务中表现出色，包括代码生成和数学问题解决。2024年下半年，LLM研究迎来了一个关键时刻，OpenAI发布了O1[OpenAI,2024a]，这标志着复杂推理研究的一个重要里程碑。O1系列模型能够生成衍生的推理过程，灵活地分解问题，并在面临挑战时自主澄清、反思和纠正潜在错误，以及探索替代解决方案——模拟了人类思维特有的细致、反思性推理过程[OpenAI,2024b]。<br>工业界和学术界都致力于复现O1，掀起了一股技术报告的热潮。<br>在工业界，一系列类似的产品涌现，例如DeepSeekR1[DeepSeek-AIetal.,2025]（简称R1）、Kimik1.5[Teametal.,2025]和QwQ[Team,2024b]，它们都发布了自己的模型或技术报告。这些产品不仅达到甚至超越了O1，而且其开源贡献也值得称赞。此外，这些技术报告中强调的扩展强化学习（ScalingReinforcementLearning）等技术，进一步拓展了研究类O1工作的方向。<br>在学术界，研究者从不同角度进行了多项复现研究。例如，O1Journey[Qin等，2024;Huang等，2024]广泛讨论了思维链格式化和蒸馏，但对持续优化方法的见解有限。与此同时，OpenR[Wang等，2024e]、O1-Coder[Zhang等，2024j]等工作主要通过强化学习的视角研究O1，但忽略了对反思和纠正推理操作的讨论。另一方面，SlowThinking系列工作[Jiang等，2024a;Min等，2024]专注于推理时计算，尝试通过树搜索技术提升推理性能。此外，rStar-Math[Guan等，2025]通过使用自我进化框架联合训练推理器和过程奖励模型（ProcessRewardModel,PRM），实现了接近O1的性能，突显了迭代优化在提升推理能力方面的潜力。<br>尽管这些技术报告提供了宝贵的见解，但它们往往仅聚焦于特定技术领域，缺乏整体性的技术架构和统一的分类标准。因此，我们需要对这些方法进行系统性的高层次综述。O1博客[OpenAI,2024a]和系统卡片[OpenAI,2024b]提示O1采用了强化学习（RL）和推理时计算。这使我们联想到另一个杰出的人工智能——AlphaGoZero[Silver等，2017]。AlphaGoZero通过自我对弈、蒙特卡洛树搜索（MCTS）和策略模型的迭代学习实现了自我进化[Silveretal.,2017]。这一过程在无人干预的情况下提升了其性能，启发我们采用类似技术或许能将复杂推理能力提升至超越人类的水平。在这个类比中，训练策略模型对应于推理优化，而MCTS搜索则对应于推理时计算。自我进化通过循环这两个阶段，实现推理能力的自主提升。此外，高质量数据的匮乏凸显了自动化数据合成框架的迫切需求[Sutskever,2024;Wangetal.,2024f]，由于推理任务对逻辑严谨性要求更高，这一挑战尤为突出。因为推理任务对逻辑严谨性有更高要求。在无人干预的情况下，自我进化不仅能利用合成数据来增强系统能力，还可以利用改进的系统合成更高质量的数据，创造一个良性循环推进过程。<br>鉴于这些考虑，本文希望从自我进化的视角对大语言模型的复杂推理提供全面综述。大语言模型复杂推理的自我进化，亦称自我改进（self-improvement），其需要在闭环推理系统中自主合成训练数据并持续提升推理能力[Tao等，2024;Hu等，2024]。专家迭代（Expertiteration）[Polu等，2022;Zhao等，2024b]被视为典型的自我进化范式。其核心思想是：模型首先生成推理轨迹，再基于标准答案筛选出正确解决方案，最后利用这些解决方案对模型进行微调，以提升其推理能力。这一过程进行迭代，直至模型收敛。此外，在线强化学习框架同样体现了自我进化的理念。智能体首先进行探索并生成轨迹，然后利用这些轨迹进行自我优化，从而在后续的学习周期中发现更高质量的轨迹。<br>图1：大语言模型中自我进化复杂推理能力的概念框架。我们在完整的自我进化框架中识别出三个组成部分：数据进化、模型进化以及进化策略和模式。<br>如图1所示，本综述的结构由三个部分组成：数据进化、模型进化和自我进化。数据进化探索合成高质量数据，包含两个阶段：（1）任务进化生成推理系统尚未能有效处理的任务，（2）思维链（CoT）进化通过扩展推理时计算[Snell等，2024]扩展大语言模型的性能边界，并通过思维链（Chain-of-Thought,CoT）[Wei等，2022]推理生成更好的解决方案。然而，性能的提升可能源于启发式搜索算法而非模型的固有能力，这从模型无法持续生成高质量思维链的证据可见一斑。模型进化通过提升系统模块来解决这些问题。一方面，模型专门针对它们曾经困难的任务进行训练；另一方面，它们从收集的数据中有选择地学习，以真正扩展其能力边界。前两种进化代表了探索性和发散性努力，旨在研究实现数据和模型进化的有前景技术和挑战。这为自我进化奠定了数据合成策略和优化方法的技术基础。在第三部分，我们专注于推理系统的自我进化框架。通过迭代进行数据进化和模型进化，推理系统实现自我进化：数据进化基于当前模型生成更有针对性、更高质量的数据，而模型进化则利用收集的数据进一步强化模型，为下一轮数据进化提供更坚实的基础。<br>我们的贡献可总结如下：（1）全面综述：这是首个聚焦于推理自我进化的大语言模型综述；（2）分类体系：我们在图2中构建了一个详细的分类体系；（3）理论基础：我们整理了相关的基础理论，并探讨了自我进化的规模法则；（4）前沿与未来：我们分析了自我进化框架内的最新开源研究，并为未来研究指明方向。<br>图2：先进方法的分类，包括数据进化、模型进化和自我进化。<br>2.预备知识<br>本综述聚焦于大语言模型促成的复杂推理任务。具体而言，我们关注思维链推理，即大语言模型在预测最终答案之前生成逐步推理过程（即思维链，Chain-of-Thought,CoT）。<br>为便于后续讨论，我们将任务及其解决过程形式化如下：<br>给定任务q，大语言模型PLLM首先生成逐步思维链y，然后基于y预测最终答案z。这一过程可以用数学表达式表示为：<br>由于在实践中y和z通常按顺序出现，我们有时会用y来表示解决方案，或者同时代表思维链和最终答案。<br>借鉴现有推理研究的见解，我们首先描述了闭环自我进化推理（closed-loopself-evolutionreasoning）框架的基本组件。具体而言，我们确定了以下四个关键模块：<br>任务创建器（TaskCreator）：推理系统需要任务作为输入。任务创建器最直接的实现方式是从固定任务集中抽样。然而，与单轮推理改进不同，自我进化需要通过迭代优化持续提升推理能力。固定任务集可能导致性能快速收敛[Jiang等，2024a]，因为系统学会识别针对特定任务的”捷径”，从而降低模型泛化能力。因此，生成多样化任务对缓解这一问题并促进自我进化至关重要。<br>推理器（Reasoner）：推理器是系统的核心角色，负责接收来自任务创建器的输入并通过逐步推理生成解决方案。在本研究中，推理器由大语言模型实现。<br>评估器（Evaluator）：评估器负责评估和验证推理器生成的推理过程。这一辅助模块有几个关键功能：在训练阶段，它提供基于分数的反馈来微调推理器，例如拒绝微调或强化学习；在推理阶段，它评估推理过程，从而指导推理时计算和后处理步骤。<br>后处理器（Post-Processor）：后处理器基于评估器反馈，处理推理器生成的解决方案。最简单的操作是直接过滤掉错误的解决方案；然而，这种方法可能导致数据浪费，且与人类处理错误的方式不尽相同。后处理分为两个阶段：在生成过程中，它可以通过修正错误的步骤或回溯来优化部分思维链；在生成后，它利用系统的纠正能力来完善完整的解决方案。<br>值得注意的是，这些模块在逻辑上是不同的，而非物理上。由于大语言模型强大的指令遵循能力，单个模型可以在实现过程中同时履行多个角色。在接下来的章节中，我们将探讨它们在数据进化（共同生成高质量数据）、模型进化（优化每个模块）和自我进化（模块的联合进化）中的重要作用。<br>3.数据进化<br>图3：数据进化流程由任务进化和思维链进化组成。在思维链进化中，我们定义了三种元操作符，使两种搜索范式能够生成更高质量的思维链。<br>如图3所示，数据进化分为两个不同阶段：任务进化和思维链进化。任务进化的核心是通过解决关键因素来提高推理任务的质量，如：难度、多样性和有效性等。通过优化这些维度，该系统不被局限于任务范围，从而显著提升泛化能力。思维链进化（推理时计算）旨在提高推理阶段的推理过程质量。这种提升主要体现在推理的准确性、逻辑连贯性以及系统自主评估和修正错误的能力上。<br>任务进化（Taskevolution）专注于生成新任务，提高训练数据的多样性和难度，以增强模型的推理和泛化能力。这种方法类似于学生通过练习各种习题来提高技能。尽管任务进化至关重要，但我们观察到现有研究很少探索这一维度。因此，我们将任务进化作为起点。作为数据合成的关键组成部分，任务进化通常涉及创建新任务，例如利用更先进的大语言模型来制定新挑战[Li等2024a]。在本节中，我们专注于增强任务多样性（taskdiversity）、复杂性（taskcomplexity）和可靠性（taskreliability），以有效支持任务进化。<br>任务多样性：为了增强任务多样性，Haluptzok等[2022]、Madaan等[2023a]使用大语言模型修改参考问题的数据类型和逻辑操作，生成结构相似但逻辑不同的任务。Yu等[2023b]则使用大语言模型重新表述参考问题来创建新问题。然而，此类方法受限于对参考数据的依赖，从而限制了全新任务的生成，并削弱了多样性和创造性。为突破这一局限，有人提出从高方差分布中采样数据或引入聚焦多样性的提示词。例如，Liu等[2023]采用温度采样和注重多样性的提示词来生成多样化的问题，而Xu等[2023]则明确指示大语言模型创建罕见的、特定领域的问题。此外，Self-Instruct[Wang等，2022]通过结合人工编写和模型生成的任务来生成新的任务指令，并使用特定的提示模板引导生成过程。<br>任务复杂性：Xu等[2023]提出了几种基于示例问题生成复杂任务的方法：1）添加约束：通过引入额外的约束或要求来提高任务难度，从而增强模型的灵活性和适应性；2）深化：扩展示例中查询的深度和广度，以提升模型的推理能力；3）具体化：将问题中的一般概念替换为具体概念，使指令更加清晰，从而提高响应的准确性和相关性；4）增加推理步骤：重新制定简单问题，要求额外的推理步骤，从而增强模型的逻辑思维能力；5）增加输入复杂性：通过修改问题条件，引入结构化数据或特定输入格式（如代码、表格、XML等），将问题从直接可计算转变为需要额外数据解析或操作的形式，从而提升模型的鲁棒性和泛化能力。<br>此外，Shi等[2023]通过引入无关条件来增加推理难度，迫使模型识别并聚焦于关键条件，而Mitra等[2024]则通过在问题中嵌入答案，将问题重新表述为陈述性语句，并借助自动化建议（如引入额外变量）来指导生成更复杂的问题。<br>任务可靠性：自动生成任务可能会产生无法解决的任务或不正确的答案。为解决这一问题，Li等[2023a]采用微调的大语言模型（LLMs）对任务进行评分并筛选高质量任务。类似地，Liu等[2024a]和Xu等[2023]基于原始问题生成多种任务，并通过验证答案来过滤不一致的任务。Haluptzok等[2022]和Liu等[2023]则利用Python解释器和预定义规则（如检查任务长度或数值内容）来验证正确性，从而确保任务质量。Kreber和Hahn[2021]提出了一种基于Transformer编码器的生成对抗网络（GAN）[Goodfellow等，2014]，通过随机噪声生成符号任务。评判器评估生成任务与真实数据之间的相似性，并提供反馈以优化生成器，从而提高任务可靠性。此外，Wei等[2023]和Lu等[2024b]探索了反向任务生成方法，利用大语言模型从解决方案中推导问题。具体而言，Lu等[2024b]从数学参考解决方案中迭代生成新答案，定义约束条件和逻辑关系，并将这些答案转化为任务，从而确保生成问题的可靠性。类似地，Wei等[2023]利用高质量的开源代码，通过大语言模型生成编程任务。<br>在开始推理过程之前，需要构思推理链（ChainofThoughts,CoT）的理想形态，以及它应该包含哪些元操作。推理链的格式决定了系统推理能力的上限。在本节中，我们首先定义三个元操作，以构建更强大的推理链，包括逐步推理（Step-by-StepReasoning）、评估（Evaluation）和后处理（Post-Processing）。<br>我们回顾了推理中的计算方法，这些方法通常通过搜索生成更高质量的思维链，分为显式树搜索（explicittreesearch）和隐式试错搜索（implicittrial-and-errorsearch）两类。早期研究集中在显式树搜索上，但随着O1及其后续开源项目（如R1[DeepSeek-AI等，2025]、Kimik1.5[Team等，2025]和T1[Hou等，2025]），研究逐渐转向试错搜索。O1提供的思维链示例表明，它能在发现错误时自我纠正或回溯，并记录整个推理过程，模仿人类在回答前的深思熟虑。O1Journey[Qin等，2024]早期探讨了这一点，提出了“捷径学习”（ShortcutLearning）[Geirhos等，2020]概念，描述追求每一步都正确的思维链，并通过“旅程学习”（JourneyLearning）[Qin等，2024]表示推理过程中的自我验证、错误检测和修正。Kimik1.5[Team等，2025]和Redstar[Xu等，2025]进一步研究这一概念，并称之为“长思维链”（LongCoT）。与此一致，我们将捷径学习的结果称为“短思维链”（ShortCoT）。<br>思维链推理的潜力已被广泛探索。虽然普通思维链（vanillaCoT）在简单任务上表现良好，但在更复杂任务中表现不佳。增强思维链推理的一种方法是设计受人类认知启发的更复杂且高效的推理链。对类O1系统[Qin等，2024;Zeng等，2024b]的观察引发了对分解、逐步推理、自我评估、自我纠正和回溯等操作的讨论。因此，我们总结并归纳了三个关键元操作：逐步推理（Step-by-stepReasoning）、评估（Evaluation）和后处理（Post-processing）。<br>我们聚焦这三个元操作符，并回顾前一节（§2.2）中提到的模块，可以将思维链格式与推理系统模块相连接。推理器（Reasoner）通过逐步分解生成推理过程，搜索算法作为其扩展技术。评估器（Evaluator）和后处理器（Post-Processor）分别管理思维链中的评估和纠正过程。整合这三个模块后，我们可以构建一个全面且稳健的推理系统。<br>逐步推理<br>逐步推理将问题分解为依序步骤，这需要强大的规划能力，然后通过基于链的推理过程逐步解决问题[Chu等，2023]。此外，分解过程应该是递归的，从而使系统能够迭代地分解复杂的子问题。<br>思维链<br>[Wei等，2022]代表了一种直接的线性搜索方法，利用少样本（few-shot）或零样本（zero-shot）提示来逐步解决问题。Plan-and-Solve[Wang等，2023b]采用零样本提示引导模型在单一生成过程中生成计划，随后基于生成的计划进行链式推理。从少到多提示（Least-to-MostPrompting）[Zhou等，2022]采用两阶段方法：第一阶段，问题被明确分解为多个子问题；第二阶段，这些子问题被顺序解决。前一步的结果被添加至上下文，引导模型继续解决后续子问题。。与基于规划的方法不同，连续提示（SuccessivePrompting）[Dua等，2022]采用迭代分解过程。在每次迭代中，一个新的子问题被提出并在当前步骤中解决。这一两步过程重复进行，直到整个问题被解决。ReACT[Yao等，2022]将迭代推理与行动相结合。在每一步中，模型基于其推理生成一个行动。该行动可能涉及调用外部工具（如计算器）或与环境交互。随后，模型使用来自这些外部工具或环境的反馈进行下一步，直到达到最终目标。通过引入行动，ReACT使模型能够与外部系统交互，从而增强大语言模型的推理过程。<br>评估<br>一个稳健的推理系统须具备自我评估能力，使其能够在任务执行期间和之后评估其推理过程。在推理过程中，系统应识别并终止错误的探索路径以进行后处理。在启发式搜索中，评估结果进一步用于指导搜索。完成推理过程后，可能会生成多个候选答案，这就需要进行彻底评估，以有效地评估和验证不同的解决方案。我们从三个粒度回顾现有研究：结果级（outcome-level）、步骤级（step-level）和词元级（token-level）。<br>结果级评估早期工作主要关注结果级评估，即在推理完成后对完整解决方案进行评估[Cobbe等，2021;Wang等，2023c;Lee等，2024a]。这些方法的主要区别在于评估的形式和目的。在训练阶段，当正确答案可用时，一些工作对照标准答案对解决方案进行直接的正确性评估[Cobbe等，2021;Hosseini等，2024]。除了单纯的答案准确性外，R1[DeepSeek-AI等，2025]和T1[Hou等，2025]还融入了基于格式的结果奖励来指导推理格式学习。在推理阶段，Cobbe等[2021]、Hosseini等[2024]利用训练好的验证器对候选解决方案进行评分和排名，从而选择最优解。此外，一些方法使用大语言模型对解决方案提供自然语言反馈。例如，Madaan等[2023b]、Zhang等[2024b]直接生成批评，而Peng等[2023]、Shinn等[2023]、Gou等[2024]在批评生成中包含内部和外部环境信息。此外，Ankner等[2024b]、Yu等[2024b]将自然语言批评与评分机制相结合，以提高评估的可靠性和可解释性。一些研究还采用基于一致性的评估框架。例如，Wang等[2023c]采用投票系统从多个解决方案候选中确定最终答案，而Jiang等[2024b]、Weng等[2023]通过确保前向和后向推理过程之间的一致性来评估答案质量。<br>步骤级评估虽然结果级评估实施简单，但在实践中应用有限，往往需要更细致的评估。其中，步骤级评估已成为一种特别突出的方法，强调对单个推理步骤的评估[Lightman等，2024;Wang等，2024g,m;Gao等，2024a;Lu等，2024a;Li等，2023b]。在树搜索算法中，过程评估被广泛用于指导搜索轨迹。例如，Tian等[2024]在蒙特卡洛树搜索（MCTS）中使用状态评分来指导搜索过程，而Xie等[2023]在束搜索中实现状态评分以优化路径选择。此外，步骤级评估在错误纠正和推理步骤总结方面都证明了其有效性。值得注意的是，Zheng等[2024]、Xi等[2024]已开发出能够精确定位特定推理步骤中的不准确之处的方法，从而提供更精确和可操作的反馈，用于全面评估。<br>词元级评估一些研究认为，步骤级评估的粒度对于全面的推理评估仍然不足[Yoon等，2024;Chen等，2024h]。这促使了词元级评估框架的发展，提供了更高细粒度的分析。Yoon等[2024]引入了一种方法，利用强大的大语言模型在词元级别上迭代修改思维链推理。他们的方法根据修改操作为词元分配不同的奖励，并利用这些奖励来训练词元级奖励模型。类似地，Chen等[2024h]提出了一个两阶段框架，首先训练一个纠正模型来识别和纠正错误的推理步骤。通过将低生成概率与错误词元关联，将高概率与正确词元关联，他们的方法能够构建精确的词元级奖励信号。此外，Lee等[2024d]提出了一个词元监督的价值模型，该模型监督单个词元以提供对解决方案正确性的更准确评估。同时，Yang等[2024b]基于最大熵强化学习原理推导出了一种词元级评估方案。他们的方法通过基于排名的截断计算词元级价值，为每个词元分配+1、0或-1的离散奖励，从而实现对推理过程的细粒度优化。<br>基于评估反馈的呈现格式，现有的评估方法可分为两种不同范式：验证器（verifier）和评论器（critic）。验证器专注于通过标量评分量化解决方案质量，而评论器则以自然语言提供口头反馈。<br>验证器验证器范式通过分配量化分数来评估解决方案的正确性。例如，Cobbe等[2021]使用验证器来估计解决方案正确的概率，而Hosseini等[2024]利用经过训练的DPO验证器生成反映解决方案有效性的似然分数。此外，[Lightman等，2024;Wang等，2024g;Lu等，2024a]采用步骤级评分机制，对单个推理步骤分配分数，并使用最小值或平均值等指标聚合它们，以得出整体解决方案质量评估。[Tian等，2024;Xie等，2023]为树搜索过程中的每个状态分配分数，以优化搜索路径。为了更细的粒度，[Yoon等，2024;Chen等，2024h;Lee等，2024d;Yang等，2024b]引入了词元级评分机制，为单个词元分配连续或离散分数（如中性、正确或错误）。<br>评论器评论器范式生成自然语言反馈，以促进错误澄清并提高评分机制的可解释性。例如，Madaan等[2023b]利用模型固有的能力对其自身解决方案产生批判性反馈，实现迭代改进。同时，[Peng等，2023;Shinn等，2023;Gou等，2024]通过结合内部模型状态和外部环境信息来扩展这种方法，生成全面的批评，不仅识别错误，还指导后续改进。进一步推进这一工作，[Zheng等，2024;Xi等，2024]进行粒度化、逐步的批判性分析，以更详细地定位和纠正错误。[Ankner等，2024b;Yu等，2024b]将批评生成与评分机制整合。通过在分配分数之前生成自然语言批评，这些方法增强了评估过程的透明度和可靠性，为评估解决方案质量提供了更可解释和稳健的框架。此外，MCTS-JudgeWang等[2025b]也将自我评估建模为一系列子任务，并使用蒙特卡洛树搜索将问题分解为更简单的多角度评估任务。<br>图4：评估后的三种后处理方法：过滤（Filter）、总结（Summary）和纠正（Correction）。<br>评估的挑战：奖励欺骗奖励欺骗被定义为策略模型利用奖励定义中的模糊性或漏洞获得高奖励，而实际上并未学习所需能力的情况[Weng，2024]。针对特定阶段，有两条主要路径可以缓解奖励欺骗。在奖励建模阶段，设计更复杂的过程奖励可能有助于缓解这一问题。然而，过于复杂的奖励信号也可能改变收敛目标。另一种方法是放弃细粒度的过程奖励模型（PRM）而仅依赖结果奖励模型（ORM），这对推理任务尤为适用。例如，R1[DeepSeek-AI等，2025]和T1[Hou等，2025]仅采用基于答案正确性和格式合规性的规则型结果奖励，有效缓解了使用过程奖励模型时的奖励欺骗问题。此外，使用更大规模的大语言模型作为基础奖励模型可以提高其泛化能力并降低利用漏洞的风险。同时，在强化学习训练过程中，裁剪和奖励塑造等机制可以在一定程度上帮助缓解这一问题[Gao等，2024b]。<br>评估的挑战：泛化性此外，奖励模型的泛化能力同样至关重要。参数化评估器（如奖励模型）通常在特定数据分布上训练，这限制了它们在分布外（out-of-distribution,OOD）任务上的适用性。这种限制可能导致对新任务的评估出现偏差或不稳定，进一步阻碍任务泛化[DeepSeek-AI等，2025;Cui等，2025]。因此，增强奖励模型的泛化能力，以在更广泛的任务范围内提供可靠反馈，对于提高任务泛化至关重要。一方面，可以优先考虑非参数化评估器，如答案正确性或格式准确性，以缓解这些问题[DeepSeek-AI等，2025;Hou等，2025]。另一方面，如果必须使用参数化评估器，确保其持续更新至关重要。一个关键挑战在于高效且经济地构建这些评估器的训练数据。<br>尽管像R1[DeepSeek-AI等，2025]这样的工作通过基于规则的结果奖励规避了现有评估器中的奖励欺骗和泛化限制问题，但也暴露了新的挑战，如过长的思维链、低效的反思和过度思考。这些问题表明，仅依赖结果奖励可能不足。更高细粒度的步骤级评估可能有助于解决这些缺点。结合过程奖励模型（PRMs）和结果奖励模型（ORMs）的优势，既能缓解奖励欺骗并确保泛化，又能实现细粒度评估，仍然是未来研究中的重要挑战。<br>后处理<br>如图4所示，评估后的推理解决方案可以进一步处理以提高其质量和可靠性。首先，可以使用总结知识（SummaryKnowledge）从推理过程中提炼和总结关键信息。对于低质量的推理解决方案，常见的处理方法包括过滤（Filtering）和纠正（Correcting）。过滤直接移除不可靠的解决方案，而纠正通过修正错误或恢复到正确状态来优化推理过程。这两种方法各有优势，其中纠正在提高推理准确性的同时特别有效地保留有用信息。通过纳入这些后处理操作，系统可以有效避免陷入逻辑死角和重复失败的推理路径，从而在复杂问题解决场景中增强整体稳健性和可靠性。以下讨论将更详细地深入探讨这些核心策略。<br>从思维链中总结知识<br>为提高模型在推理任务中的表现，一些研究专注于总结先前解决方案的经验来指导后续推理。例如，Zhang等[2024k]在训练实例中纳入反思组件，如通过类比和推理的替代解决方案或问题扩展，引导模型从不同角度理解问题并积累多样化的推理经验。而Wang等[2024l]通过训练对齐将反思见解整合到代码本模块中，使模型能够主动检索相关反思来辅助推理过程。在树搜索推理中，Hui等[2024]识别重要节点并反思后续行动和结果，生成任务级指导方针以优化搜索效率并避免重复错误。同时，Liu等[2024c]引入了用于行动选择的文本原则，通过迭代反思不断完善这些原则，灵活指导行动执行。此外，Zhang等[2025a]提出了基于思维链的合成器（CoT-basedSynthesizer），通过结合多个候选解决方案的互补信息来改进推理，即使所有候选解决方案都有缺陷也能生成更好的解决方案。<br>过滤低质量思维链<br>当在评估阶段识别出低质量解决方案时，最简单的方法是直接过滤。例如，当标准答案可用时，可以基于答案正确性过滤低质量解决方案[Singh等，2023;Gulcehre等，2023]。在没有标准答案的情况下，过滤策略可以基于一致性进行完善，如困惑度（perplexity）[Min等，2024]、基于投票的一致性[Wang等，2023c;Chen等，2023a]、前向-后向一致性[Jiang等，2024b;Weng等，2023]，或通过构建针对多项选择题性质的后续问题来评估解决方案一致性[Ankner等，2024a;Lee等，2024b]。此外，可学习的验证器[Cobbe等，2021;Yu等，2023a;Stiennon等，2020]可以用来进一步增强过滤过程。虽然简单过滤既高效又易于实施，但通常会导致大量推理数据浪费。<br>纠正低质量思维链<br>除了直接过滤外，纠正不正确的解决方案有助于最大限度地利用已有数据，因此低质量解决方案的改进已成为研究的关键方向。早期研究主要依赖模型的内在能力对解决方案进行优化。例如，Madaan等[2023b]使用自生成反馈对初始输出进行迭代优化；Zhang等[2024g]则通过大语言模型比较多个方案，并将差异整理为对照清单，以增强自我反思过程的一致性与可靠性。然而，仅依赖内在纠正方法往往难以充分优化结果，表明引入外部信息对于提升改进效果至关重要。<br>最近的研究提出多种策略增强纠正性能。Ferraz等[2024]、Wu等[2024b]通过细粒度约束分解和后向推理优化纠正过程。Gou等[2024]利用外部工具反馈，Li等[2024b]、Gao等[2024c]、Chen等[2023b]、Yuan等[2024a]借助Python解释器迭代执行代码，直至成功评估。Ramji等[2024]采用策略指标作为质量反馈，迭代优化答案。Wu等[2024c]训练PSV模型识别并纠正错误步骤，确保准确性。Shridhar等[2024]训练提问者模型生成子问题以辅助纠正。为增强模型的批评与改进能力，Zheng等[2024]、Xi等[2024]、Yan等[2024]、Zhang等[2024i]提出训练模型提供批评以推动改进。<br>从理论角度看，迭代纠正方法可视为通过线性搜索进行的马尔可夫决策过程（MarkovDecisionProcess,MDP），其中解决方案为状态，纠正操作则为状态转移的行动。简单的线性搜索通常效果平平，但更复杂的树搜索方法理论上能获得更优结果。例如，Zhang等[2024e,d]将蒙特卡洛树搜索（MonteCarloTreeSearch,MCTS）与自我进化机制结合，优化复杂数学推理任务的解决方案。该算法初始化根节点，并通过价值函数Q选择最具潜力的节点进行扩展。在自我进化阶段，模型通过反馈纠正答案并生成更优解，随后通过自我评估打分，这些分数用于更新树中节点的价值评估。节点的树上置信上界（UpperConfidenceBoundforTrees，UCT）值通过改进的公式进行更新。该过程持续进行，直到满足终止条件，既提升了解决方案质量，也不断探索新的可能性。<br>其他方法<br>除上述纠正、过滤与总结操作外，还可采用其他后处理方式，如回溯机制[Qin等，2024；Yang等，2025b]。当系统检测到错误时，可回溯至先前状态，重新探索替代的推理路径。<br>在本小节中，我们将“短思维链”（ShortCoT）定义为仅包含逻辑推理步骤、不涉及评估与纠正等行为的思维链。短思维链体现了一种从任务提示直接通向标准答案的精简推理过程，要求每个中间步骤均为正确。针对传统思维链准确率较低的问题，研究者提出基于启发式搜索（尤其是树搜索）的增强方法，以提高对短思维链的搜索效率。我们将此类方法统一归纳为“显式树搜索”（ExplicitTreeSearch）框架。<br>尽管短思维链本身不包含评估等行为，但在搜索过程中仍可引入评估机制辅助推理。搜索过程中，评估函数用于引导探索方向并执行剪枝，从而优先保留最具潜力的路径。该方法在提升搜索效率的同时，亦保持了所生成思维链的准确性与简洁性。根据底层搜索策略的不同，显式树搜索算法可分为若干类型：朴素的广度优先&#x2F;深度优先搜索（naiveBFS&#x2F;DFS）、束搜索（BeamSearch）、A<em>算法以及蒙特卡洛树搜索（MCTS）。<br>广度优先&#x2F;深度优先搜索：思维树（Tree-of-Thoughts,ToT）[Yao等，2023]将问题分解为多个思维节点，并利用经典搜索算法——广度优先搜索（BFS）和深度优先搜索（DFS）——探索多样化的推理路径，显著增强了语言模型在复杂任务中的问题解决能力。Qin等[2023]将搜索过程与工具使用相结合，采用DFS处理工具组合与错误管理，从而提升模型在真实任务中的表现。上述方法依赖外部程序（如Python代码）定义搜索逻辑。然而，这些被动搜索方法效率较低，灵活性有限。自主树搜索（AutonomousTree-Search）[Zhang等，2023b]通过提示直接引导大语言模型独立执行BFS或DFS，自主探索多条解决路径，提升推理灵活性。思维算法（Algorithm-of-Thought,AoT）[Sel等，2023]则利用BFS&#x2F;DFS的整个搜索路径作为提示，整合思维链与思维树的优势，使模型在推理过程中能动态调整路径，从而更高效地发现解法。此外，AoT避免了ToT所需的多轮查询，降低了推理开销。<br>束搜索：束搜索作为广度优先搜索的一种变体，在搜索过程中维护k个候选序列（称为束），实现了搜索准确性和计算效率之间的有效平衡。其与大语言模型自回归生成的契合使其特别适合在解码过程中指导前向搜索。根据搜索的粒度，束搜索可分为三个层次：词元级（token-level）、步骤级（step-level）和解决方案级（solution-level）。<br>词元级束搜索在模型生成的最小单位上操作，直接与大语言模型解码过程对齐。虽然传统束搜索基于词元对数概率对序列进行排序，但这种方法优先考虑自然语言流畅性而非推理质量。为解决这一局限性，Lee等[2024c]引入了词元监督价值模型，对词元进行评分以提高数学推理的准确性。此外，为缓解生成序列多样性不足的问题，Vijayakumar等[2016]提出多样化束搜索，将束分成多个组，在每个组内独立优化，并在组间引入多样性惩罚，以鼓励生成更多样的推理路径。<br>步骤级束搜索将多步推理分解为子步骤，对每个子步骤进行评分和验证，以维持高质量的候选路径。例如，Wang等[2024i]、Ma等[2023]使用过程奖励模型（PRM）对子步骤进行打分，利用这些分数引导搜索朝有希望的推理路径发展。类似地，Chen等[2024b]、Yu等[2023a]利用学习的价值模型在步骤级别增强搜索效率，避免了蒙特卡洛树搜索的计算开销。Setlur等[2024]进一步结合过程优势来完善搜索过程。与外部评估方法不同，Xie等[2023]利用模型本身进行自我验证，提示它验证步骤正确性，同时通过温度调整的随机化引入多样性。<br>解决方案级束搜索独立评估整个推理路径，通过避免中间操作提供更快的推理。例如，Best-of-N（BoN）采样生成多个完整解决方案，并使用奖励模型选择评分最高的解。然而，Wang等[2024i]强调了奖励模型在区分相似推理过程方面的局限性，提出了一种成对偏好模型以实现更有效的排名。同时，Wang和Zhou[2024]观察到模型可以通过采样自动生成思维链推理，而基于思维链得出的答案表现出更高的置信度。利用这一见解，他们引入了思维链解码（CoT-decoding），这是一种通过改变解码过程隐式执行思维链推理的方法，通过top-k采样生成多个序列，并基于答案置信度选择最佳序列。<br>A</em>搜索：A<em>算法通过使用评估函数f(n)&#x3D;g(n)+h(n)扩展最具潜力的节点，从而提升搜索效率。其中，g(n)表示从初始状态到当前节点的累积代价，h(n)是用于估计从当前节点到目标状态的启发式代价函数。该框架已被改造以增强大语言模型的多步推理能力，在搜索效率方面优于传统的思维树（ToT）方法。<br>已有多项研究将A</em>原则整合进大语言模型的推理过程。Zhuang等[2023]提出ToolChain<em>，为特定任务维护一套“长期记忆”机制，用于存储推理经验。该记忆系统初始由示例数据预置，并在推理过程中不断吸收正确的解路径，从而实现动态扩展。ToolChain</em>通过最长公共子序列（LongestCommonSubsequence）将新任务与历史经验匹配，进而估计累积与未来成本，实现对复杂规划与推理任务中最优解的高效识别。相比之下，Wang等[2024a]引入了Q<em>，该方法采用训练得到的Q值模型为每个状态计算启发式值h(x)，从而使A</em>算法可扩展至数学、编程等领域。<br>进一步的研究利用大语言模型的固有能力对A<em>搜索进行优化。Meng等[2024a]提出LLM-A</em>，该方法利用大语言模型的全局理解生成中间引导点（waypoints），以引导A<em>搜索方向并减少冗余状态的探索。Gupta和Li[2024]训练大语言模型学习真实代价h∗(n)与启发式估计h(x)之间的残差（差），通过减少迭代次数加快搜索收敛。Lehnert等[2024]提出Searchformer，将A</em>的执行轨迹转化为标记序列，进而引导Transformer模型迭代采样更短路径。类似地，Su等[2024]提出Dualformer，在A<em>搜索过程中引入随机信息丢弃机制，使模型在搜索过程中实现快思维与慢思维的动态平衡，从而优化搜索策略。<br>蒙特卡洛树搜索：蒙特卡洛树搜索（MonteCarloTreeSearch,MCTS）是一种在探索与利用之间实现平衡的搜索算法，在以马尔可夫决策过程（MarkovDecisionProcess,MDP）建模的任务中表现出色[Chen等，2024b;Wu等，2024a]。这类任务通常要求MCTS在庞大的状态-行动空间中发挥其探索与利用平衡的优势，以发现高价值的行动轨迹。AlphaGoZero[Silver等，2017]是其中代表，该系统基于MCTS实现，在围棋任务中搜索高质量的落子序列，不断优化策略网络的性能。受AlphaGoZero启发，研究者提出了在复杂行动空间中使用MCTS搜索高质量推理路径的思路。经典MCTS通常包含以下四个步骤[Browne等，2012]：<br>选择（Selection）从根节点开始，MCTS在探索与利用之间进行权衡，并据此计算各子节点的权重。常见的权重计算策略包括上置信界（UpperConfidenceBound,UCB）和预测器上置信树界（PredictorUpperConfidenceTreeBound,PUCT）[Rosin,2011]。UCB公式为：；PUCT公式为：。其中Q(s,a)表示从状态s采取行动a后的累积奖励，πprior(a|s)为在状态s下选择行动a的先验概率，N(s)是当前上下文中状态s被探索的次数，N(s,a)是行动a在状态s被探索的次数。权重函数同时考虑探索（未访问节点将获得更高探索值）与利用（历史上高回报节点获得更高利用值）。每轮选择会推进到得分最高的子节点，直至到达叶节点。<br>扩展（Expansion）一旦到达叶节点，若该节点不是终止状态（例如尚未得出最终答案），MCTS将基于当前状态执行新的行动，扩展生成多个子节点。扩展质量主要取决于行动空间的定义。在围棋中，行动为落子；而在大语言模型推理中，不同任务需定义不同的行动空间。即使在同一任务下，不同粒度的行动空间也可能导致完全不同的搜索行为和结果。<br>评估（Evaluation）到达叶节点后，需对其状态值进行评估。常见方法包括：1）蒙特卡洛采样估值：将从根到当前节点的状态-行动路径作为上下文，采样多个完整轨迹，并基于其统计指标（如成功率）计算状态值。该方法无偏但方差高、计算成本大，难以用于采样代价高的任务；2）训练价值模型估值：利用预训练模型直接估计状态值，但训练价值模型比奖励模型更具挑战，因为它需预测未来的预期累积奖励。<br>反向传播（Backpropagation）一旦完成状态值评估，MCTS将从叶节点向根节点回传该值，更新路径中所有节点的状态估计。随着模拟次数的增加，这些估值愈发精确。该过程重复执行，直到达到设定的最大模拟次数，最终形成一棵记录每个节点状态值与访问次数的搜索树。由于不同任务和方法的设计差异，MCTS在大语言模型推理中的实现方式也有所不同。<br>在前一节中，我们介绍了基于短思维链（ShortCoT）的方法，其特点是每一步推理均为正确。所有被判定为“无前途”（unpromising）的推理步骤将由算法控制进行剪枝，使搜索聚焦于更有希望的分支，确保最终仅保留通向正确解的推理轨迹。<br>与此相对，长思维链（LongCoT）[DeepSeek-AI等，2025；Team等，2025；Hou等，2025；Xu等，2025]并不要求每一步都正确，而是允许模型在推理过程中通过试错进行探索。我们将长思维链定义为模拟人类认知过程的思维链。与短思维链不同，长思维链不仅包含逐步逻辑推理，还在整个推理过程中集成了自我评估和自我纠正等行为。相应地，我们将R1和类似工作用于探索长思维链的过程称为隐式试错搜索（ImplicitTrial-and-ErrorSearch）。在此过程中，不需要外部评估器或精炼器；大语言模型自主触发其自我评估机制，并利用自我纠正和回溯能力来调整推理路径，这对提高推理性能至关重要。尽管长思维链在表面上呈现为线性结构，但由于纠错与回溯机制的存在，其本质逻辑形态更接近于树状结构。因此，我们将其称为隐式搜索。<br>为实现LongCoT的生成，O1项目[Huang等，2024]提出了基于蒸馏的训练方法。然而，该方法仅模仿了试错行为的模式，未能真正赋予模型深入思考的能力。为此，多个团队陆续引入基于强化学习的优化策略。DeepSeek-R1在PPO[Schulman等，2017]的基础上采用GRPO[Shao等，2024]进行改进；Kimik1.5借助在线策略镜像变体[Lazic等，2019]；T1应用了RLOO算法[Ahmadian等，2024]进行优化。这些优化将在§4详细讨论。<br>值得注意的是，这些开源研究普遍选择以结果奖励模型（OutcomeRewardModel,ORM）替代过程奖励模型（ProcessRewardModel,PRM），以指导大语言模型自主探索解空间。这一策略性转变使模型在性能上达到了与O1相当甚至超越的水平。放弃PRM的决定，主要源于其泛化能力有限以及奖励欺骗（rewardhacking）问题严重，相关内容已在§3.2.1中详尽讨论。随着强化学习训练的不断推进，模型生成的思维链显著延长，推理准确性与泛化能力持续提升。在此过程中，模型甚至展现出“顿悟时刻”[DeepSeek-AI等，2025]：能够自主完成解的验证与替代推理路径的探索，表现出接近人类“灵感式”认知的推理能力。<br>显式树搜索与隐式试错搜索的差异<br>在深入比较之前，我们简要总结显式树搜索用于短思维链和试错搜索用于长思维链在程序上的区别：<br>图5：两种搜索范式的说明。显式树搜索通过同时扩展多个步骤并优先处理最有希望的步骤来提高搜索效率，从而识别逻辑连贯的短思维链。相比之下，隐式试错搜索通过逐步推理、试错和回溯到过去的状态来探索替代思路，模仿人类思考。<br>如图5所示，显式树搜索采用启发式搜索算法（如蒙特卡洛树搜索、A</em>和束搜索）来探索解决方案空间。在每个状态，都会扩展多个行动以获得候选状态，形成树结构的搜索过程。在此过程中，推理系统被动调用评估和剪枝等操作。生成的思维链中的每个推理步骤都保证是正确的，而评估、剪枝和错误纠正等行为不会在短思维链（ShortCoT）中呈现。<br>相比之下，隐式试错搜索不依赖启发式算法。相反，大语言模型在推理过程中主动调用自我评估和自我纠正等能力，并用自然语言表达这些操作。因此，试错搜索中的长思维链不仅包含逐步推理，还融合自我评估、自我纠正与回溯操作，使整体推理过程更加透明且具有动态调整能力。<br>在性能方面，树搜索也有成功的实现，如rStar-Math[Guan等，2025]，它使用蒙特卡洛树搜索和过程奖励模型以及自我进化训练，使小型大语言模型在性能上达到与O1相当的水平。然而，最近的开源项目，包括DeepSeekR1[Team,2024a]和Kimik1.5[Team等，2025]，都选择了试错搜索路线，获得了显著的泛化能力[Yeo等，2025]。这些开源项目放弃使用短思维链的显式树搜索，转而采用长思维链的试错搜索的原因可以从其技术报告中推断：<br>首先，树搜索通常依赖奖励模型或价值模型等验证器提供评分，以实现细粒度的评估指导。然而，这些验证器普遍存在泛化能力弱与奖励欺骗严重的问题。这可能导致中间评估不准确，甚至因LLM利用捷径最大化奖励而引发训练崩溃。相比之下，R1、Kimik1.5和T1在搜索过程中利用自我评估能力，并在训练过程中采用基于规则的结果奖励，显著减轻了奖励欺骗并提高了泛化能力。<br>此外，树搜索中验证器的分数仅反映推理的相对质量，未能指出错误或原因，导致评估质量有限。相比之下，R1和类似项目通过自我评估生成口头评估反馈，提供更丰富和更有信息的反馈。<br>最后，虽然树搜索可以同时探索多条路径，但这些路径是独立的。因此，中间经验无法在它们之间共享，降低了并行推理过程的利用率。这使得树搜索与人类推理有显著差异，因为在人类推理中，过去错误的见解指导后续推理，这在长思维链（LongCoT）的试错搜索中可以看到。<br>虽然上述讨论强调了与试错搜索相比，显式树搜索的弱点，但并不意味着试错搜索没有缺点。<br>在试错搜索中应用长思维链可能在两个关键方面引入效率低下。1）对于简单任务，长思维链方法往往表现出过度思考。正如[Chen等，2024f]所指出的，QwQ[Team,2024b]和R1[DeepSeek-AI等，2025]等方法通常会探索多个潜在解决方案，即使初始解决方案通常已经足够。这种过度探索行为会引入显著的计算资源消耗。2）对于复杂任务，Wang等[2025a]观察到QwQ和R1容易思考不足。这些方法往往在未充分验证当前推理路径有效性前即过早放弃，导致策略频繁切换，导致搜索过程不稳定且效率低下，伴随着不必要的冗长推理链。相比之下，基于短思维链的方法产生更简洁的推理路径，提供明显的效率优势。[Wu等，2025b;Xie等，2025a]进一步论证，更长的思维链不一定能改善推理性能；相反，每个模型和任务都存在最佳思维链长度。因此，试错搜索的低效率不仅增加了词元使用和计算成本，还降低了性能。<br>此外，隐式试错搜索严重依赖大语言模型的自我评估和自我纠正能力。一方面，这些能力的背景机制仍是需要进一步研究的领域；另一方面，这些能力在大语言模型的学习过程中尚未被特别优化。R1[DeepSeek-AI等，2025]、kimik1.5[Team等，2025]和T1[Hou等，2025]等模型在同一行动空间中仅使用结果级奖励同时学习推理、评估、反思和错误纠正，但缺乏专门的奖励信号来指导评估、反思和纠正能力的学习。结果，大语言模型中的这些能力没有得到特别优化，一个后果是，即使大语言模型在早期阶段进行低质量的反思或错误纠正，只要最终答案正确，它们仍然可以获得积极奖励。此外，自我评估能力的不足是R1等方法经常无法准确评估推理路径，从而过早放弃有希望路径的原因之一。<br>为解决效率低下问题，Kimik1.5[Team等，2025]引入了长度惩罚作为长度奖励的一部分，用于控制响应长度。Yeo等[2025]设计了余弦奖励函数，对于正确响应，奖励随着长度缩短而增加，而对于错误响应，奖励随着长度增加而增加。Luo等[2025]提出长度协调奖励，抑制过长的响应。除引入新的奖励函数外，Chen等[2024f]采用偏好学习，将最短响应视为正例，最长响应视为负例，从而鼓励大语言模型生成更短的思维链，抑制过长思维链的生成。我们在表1中简要总结了这两种搜索方法的差异。<br>表1：两种搜索范式的比较。<br>显式树搜索与隐式试错搜索的统一这两种搜索策略——树搜索和试错搜索——各自提供独特优势，引发一个关键问题：它们之间的关系是什么，能否统一？我们从两个角度探讨这个问题。首先，我们从行动空间的角度分析这两种搜索的相关性，重点关注不同元操作符的角色。<br>最初，两种策略都包括逐步推理，短思维链主要由逻辑连贯的推理步骤组成。<br>然而，两种策略在评估机制上有显著差异。显式树搜索通常需要学习过程奖励模型或价值模型来评估推理质量，由于这些模型泛化能力差而引入高偏差。相比之下，试错搜索依靠大语言模型的内在自我评估能力来评估推理状态。<br>关于后处理，我们以”纠正”为例进行分析。树搜索通常缺乏直接纠正操作，尽管分支间切换可被视为一种形式上的错误纠正。然而，这种”纠正”无法利用先前尝试的内容，因为它们仅是在先前扩展阶段预先采样的，不同尝试彼此独立。例如，在蒙特卡洛树搜索的扩展阶段，同时采样多个子候选行动。在随后的选择阶段，当前状态中选择的行动可能与前一模拟中的不同，这可视为一种”纠正”。然而，此次模拟中选择的新行动并非基于前一模拟中所选行动的评估反馈生成；相反，两种行动都是在扩展阶段独立采样的。<br>因此，与试错搜索相比，当前树搜索方法的主要限制主要在于其受限的行动空间。如果扩展树搜索的行动空间以纳入评估和纠正等行动，理论上它也可以促进长思维链的探索[Lin等，2025]。<br>从推理能力进化的角度看，长思维链是解决新问题的有效方法，而短思维链代表通过对长思维链的持续训练实现的最终目标。具体而言，人类在面对复杂任务时，通常先通过试错探索，最终归纳出高效的求解路径。可以学习这些有效途径以减少不必要的试错，从而缩短长思维链。因此，长思维链可视为处理复杂任务的初始和中间解决方案。一旦解决任务，从长思维链提炼的知识可用于学习短思维链，而短思维链又作为先验知识，在处理更复杂任务时减少长思维链的试错迭代。总之，强大的推理系统应具备动态切换长思维链与短思维链的能力，以实现探索性与高效性的自适应平衡。<br>4.模型进化<br>在收集高质量推理数据后，下一步是提升系统中各模型能力，为后续数据优化打下基础。由于任务创建器研究较少，本文聚焦于推理器、评估器和后处理器的训练方法，并从强化学习视角总结现有工作，涵盖行为克隆（BehaviorCloning）、偏好优化（PreferenceOptimization）和强化学习（ReinforcementLearning）。<br>为便于正文引用，本节先介绍几种典型的强化学习算法。</p>
<p>奖励建模（Rewarding）：收集偏好数据训练奖励模型rθ。早期方法通过人工标注同一提示下的多个响应，并按质量排序以表示人类偏好关系。训练目标如下：<br>策略优化（PolicyOptimization）：将大语言模型微调为策略模型πref，目标是最大化其所获奖励。过程包括生成内容、通过奖励模型评分，并使用PPO[Schulman等，2017]进行优化：<br>其中参考模型πref通常经监督微调（SFT）后冻结参数。KL散度项用于限制偏离并保持多样性，防止策略塌缩。<br>尽管RLHF最初用于对齐任务，该框架也可用于优化推理能力。通过构建基于推理正确性的偏好数据，可引导模型偏向生成正确推理路径，抑制错误路径，从而提升推理表现。<br>尽管RLHF使用PPO进行优化，但在实际应用中，经典RLHF通常被视为一种赌博机（bandit）方法，即将整句话视为一个整体动作[Zhong等，2024]。这是因为RLHF仅依赖结果级奖励，缺乏细粒度的优化信号。<br>相较于密集奖励，稀疏奖励会显著增加学习难度[Andrychowicz等，2017]，在复杂推理任务中尤为明显。例如，在多步推理中，解答失败并不意味着每一步都出错，可能前几步是正确的，仅后续步骤有误。而仅使用结果奖励，会在训练中抑制那些正确的中间推理。为充分发挥强化学习潜力，需引入步骤级甚至词元级奖励作为更细粒度的优化信号。要实现这一点，需要重新审视PPO算法的设计。<br>PPO[Schulman等，2017]是一种经典的on-policy算法，在多个领域表现出良好的稳定性与效果。其通用训练目标为：<br>其中y表示策略模型生成的文本，|y|表示其字符数。优势函数定义为At&#x3D;Q(st,yt)-V(st)是优势函数，即将动作值函数Q(st,yt)归一化至状态值基线V(st)，以降低方差、提高学习稳定性。实际训练中常用广义优势估计势函数（GeneralizedAdvantageEstimation,GAE）形式，以平衡偏差与方差：<br>其中γ是折扣因子，λ是位于区间[0,1]的超参数。当γ&#x3D;0时，。<br>尽管PPO在RLHF中表现良好，但其对训练资源的高要求限制了其在推理优化中的应用。完整PPO框架包含四个模块：策略模型（policymodel）、参考模型（referencemodel）、价值模型（valuemodel）和奖励模型（rewardmodel）。后两者的初始化更进一步增加了训练复杂度，并影响策略模型稳定性。为简化PPO框架，已有研究提出多种改进方法，如跳过对价值模型[Shao等，2024]或奖励模型[Rafailov等，2023]的显式建模与训练。下面将介绍若干代表性工作，展示如何简化PPO训练流程以支持更高效的推理优化。<br>为降低训练资源开销，近期研究重新审视了REINFORCE[Sutton等，1999]在大语言模型优化中的潜力[Li等，2023d；Ahmadian等，2024]。REINFORCE是一种经典的策略梯度算法，其传统优化目标为：<br>其中，为累积奖励，用于控制策略梯度更新的方向与步长。<br>然而，REINFORCE存在高方差问题，尤其体现在R(st,at)上，导致训练过程不稳定。为降低方差，常通过替换为动作值函数Q(st,at)或优势函数A(st,at)（如PPO所采用），或引入基线项实现修正：<br>基线b(st)有多种实现方式。为避免额外训练价值模型，ReMax[Li等，2023d]采用概率最高动作的奖励作为基线：</p>
<p>在仅有结果级奖励的Bandit场景中，Ahmadian等[2024]发现RLOO优于PPO。其原因可能在于，经过大规模预训练与微调的大语言模型本身就是强初始化策略，采样轨迹的句子级方差较小。同时，RLOO通过采样估计价值函数，减少了方差，并避免了显式学习价值函数所带来的偏差。<br>然而，这一优势主要体现在bandit设置中。对于多跳推理等需步骤级或词元级密集奖励的任务，RLOO可能因方差过大而表现不佳。虽然REINFORCE简化了结构并降低成本，但其稳定性仍受限于奖励信号的稀疏程度。<br>表2：五种强化学习算法对比：PPO、RLOO、GRPO、DPO、PRIME（VM：价值模型；RM：奖励模型；RefM：参考模型）<br>在具备步骤级或词元级奖励的场景下，PPO是微调策略模型的理想选择，因其通过优势函数与裁剪操作保障训练稳定性。但如公式（5）所示，计算优势函数需同时依赖奖励模型与价值模型V(st)。通常，价值模型规模与推理器相当，训练困难、易不稳定，且大幅增加资源负担。<br>为此，Shao等[2024]提出GRPO，利用蒙特卡洛（MC）采样替代价值模型，对PPO进行改造。具体而言，对每个任务q，GRPO同时采样G个完整解y1,y2,…,yG，根据奖励函数对每个解给予奖励。<br>两种奖励版本：<br>使用PRM时，为每步分配奖励，构造奖励集：<br>其中ki表示yi中的步骤数，表示yi的第j步中结束词元的索引。此时，优势函数计算如下：<br>使用ORM时，为每个解分配一个奖励ri，优势函数简化为：<br>无论使用哪种模型，GRPO都将组内奖励标准化，以平均值替代价值模型作为基线，从而在训练中抑制低质量行为，强化高质量行为。<br>最终，GRPO的优化目标为：<br>其中是上一轮的参考模型。此外，为提高稳定性，GRPO在PPO基础上加入KL散度项，但采用Schulman[2020]提出的无偏估计方法：<br>总结，GRPO通过MC采样估算优势函数，无需引入价值模型，简化了训练架构，仅需策略模型、参考模型和奖励模型。它继承了PPO的稳定性，同时利用LLM的强先验性弱化了方差问题。MC采样带来无偏估计，组内标准化强化高质量轨迹，显著提升训练稳定性。GRPO已在多个类O1的开源项目中成功应用，如[Shao等，2024；Yang等，2024a；Wang等，2024e；DeepSeek-AI等，2025]。<br>RLHF需显式建模并预训练奖励模型，增加了计算资源消耗与训练复杂度。为此，DPO首先指出了等式（3）的闭式解：<br>该结论说明，最优策略模型π*(y|x)与奖励模型r(x,y)紧密耦合。即设定奖励模型即可对应一个最优策略，最大化其隐含的最优轨迹概率。DPO将等式（14）变换为：<br>这意味着，奖励函数r(x,y)可由策略模型π(y|x)表达。因此，Rafailov等[2023]提出：与其先训练奖励模型r(x,y)再优化策略π(y|x)，不如直接优化策略模型π(y|x)来的高效。在RLHF中，奖励模型训练通常基于Bradley-Terry偏好建模：<br>将等式（15）代入等式（16）后，DPO可直接将该目标转化为策略学习目标：<br>虽然DPO省去了奖励模型建模，简化RLHF，降低了LLM优化门槛。但后续研究也揭示了若干问题：<br>优化粒度粗糙原始DPO只在响应级别优化偏好，难以精细区分复杂推理中的正确与错误步骤，容易将部分正确的响应也标记为负例。为此，后续提出了step-DPO、token-DPO等细粒度方法（详见§4.2.2）。<br>数据分布偏移：DPO通常在离线场景训练，先使用参考模型πref收集一批固定的偏好数据集，再用DPO训练策略模型πΦ。该方法虽具有较高的训练效率，但完全依赖静态离线数据可能限制模型的持续学习能力[Chen等，2024a]。为缓解此问题，有研究将DPO拓展到在线学习框架。具体做法是：每轮先收集一批偏好数据，使用DPO训练策略模型，然后将新训练得到的模型πΦ替换为下一轮数据收集的参考模型πref，实现策略的持续迭代优化。<br>正样本被抑制DPO在训练中不仅会降低负样本概率，也可能误伤正样本，尤其当正负差异不显著时。为解决该问题，研究者引入正则化项以强化对正负样本质量差异的建模[Azar等，2023；Le等，2024]。<br>奖励信号利用不足DPO未对偏好程度进行显式建模，在奖励数值可用的情况下，仅通过比较奖励高低构造偏好对，而未直接利用奖励信号本身，导致信息利用不足。同时，对偏好对数据的依赖也提高了训练数据的构造成本。为解决这一问题，OREO[Wang等，2024b]提出一种全新的离线强化学习算法，仅依赖奖励信号进行优化，完全无需偏好对数据。<br>尽管DPO简化了训练流程，但其泛化能力仍不如PPO[Li等，2023c]，甚至某些任务中不如直接SFT[Yuan等，2024b；Chen等，2024d]。因此，多项扩展方法被提出：<br>fDPO：引入散度约束，增强偏好表达能力与鲁棒性[Wang等，2023a]<br>cDPO：提升在噪声反馈环境下的稳定性[Chowdhury等，2024]<br>KTO：基于Kahneman-Tversky心理模型结合人类决策偏好[Ethayarajh等，2024]<br>GPO：用凸函数族参数化损失函数，统一偏好学习框架[Tang等，2024]<br>ORPO：去除参考模型，仅使用偏好信息优化策略，进一步简化流程[Hong等，2024]<br>Rafailov等[2024]进一步分析DPO，并引入隐式奖励（ImplicitReward）概念，其公式如下：<br>Rafailov等[2024]认为，DPO所训练的策略模型实质上充当了一个词元级奖励函数，其中每个词元的奖励正是由该公式定义的隐式奖励。这一机制的有效性已在多项工作中得到验证[Zhong等，2024；Chen等，2024a]。<br>Yuan等[2024c]证明，若将结果奖励函数定义为，则所得的ORM可直接用于计算词元级奖励。换句话说，按此格式训练出的ORM本质上也可作为过程奖励模型（PRM）使用。具体而言，PRIME[Cui等，2025]包含四个核心组件：策略模型πΦ、结果奖励验证器ro、过程奖励模型πθ及其对应的参考模型πref。在生成响应y后，PRIME首先获取结果级奖励ro(y)，并通过交叉熵损失训练rθ(y）：<br>其中rθ(y)被优化以逼近真实的结果奖励。该训练过程中，过程奖励模型πθ也同步更新，并可用于为每个词元yt提供词元级奖励：<br>这正是隐式奖励的计算形式。基于训练好的πθ，PRIME可为策略模型πΦ提供精细的词元级奖励，从而与如RLOO等多种强化学习算法无缝对接（如原论文所示）。<br>PRIME的核心思想是将整体结果奖励分解到每个词元，借助大规模采样过程学习词元级奖励。对最终结果贡献较大的词元将获得更高奖励。该方法无需人工标注，可同时训练策略模型与奖励模型，既避免了奖励欺骗问题，也提升了奖励模型的泛化能力。<br>在收集推理过程数据后，最直接的优化方式是行为克隆（BehaviorCloning,BC），即监督微调（SupervisedFine-Tuning,SFT）。然而，从理论上讲，BC只能在正确的数据上进行。Yuan等[2023a]和Tong等[2024]提出了拒绝微调（RejectionFine-Tuning），通过答案标签过滤错误的推理轨迹，仅在正确轨迹上进行微调。尽管这种方法能保证训练数据的质量，但会造成大量数据浪费。<br>为提升正确样本的数量，Zelikman等[2022]提出在错误解的基础上引入“合理化（Rationalization）”步骤来重生成推理过程。Zhang等[2023a]提出HIR（HindsightInstructionRelabeling），通过重标指令使错误解可用，例如将“生成正确答案”改为“生成错误答案”，从而无需引入额外参数即可复用失败样本。同时，Zhang等[2024c]和Wang等[2024k]使用蒙特卡洛树搜索（MCTS）提高发现正确轨迹的效率。Chen等[2024e]则通过构造逆向问题并对其进行SFT，使模型具备逆向推理能力。<br>尽管上述方法提升了有效样本比例，或通过修改指令利用错误数据，但在最大化数据利用率与挖掘负样本方面仍存在局限。<br>图6：偏好优化的三个粒度：解级、步级和标记级。<br>偏好优化（PreferenceOptimization）是提升大语言模型推理能力的主流方法。其核心思想是：提升高质量思维链（CoT）的概率，同时压低劣质思维链的概率，从而增强目标模型的推理能力。<br>早期方法如RRHF[Yuan等，2023b]从排序角度进行偏好学习。该方法使用奖励模型对不同来源采样的响应进进行评分排序，构建偏好对，并通过排序损失优化模型：<br>其他偏好优化算法，以DPO[Rafailov等，2023]为代表的偏好优化方法进一步简化了RLHF流程，突破了SFT的限制，并因其实现简便而广泛应用于各类任务。<br>下文将按偏好数据粒度，将现有研究划分为解决方案级（solution-level）、步骤级（step-level）和词元级（token-level）优化三类：<br>解决方案级偏好优化<br>该层级偏好数据最易获取，因而早期研究多集中于此。Pang等[2024]与Jiang等[2024a]基于答案标签将解划分为“正确”与“错误”组，构造偏好对进行优化。在答案标签缺失的自我进化场景中，可借助LLM-as-a-Judge[Gu等，2024]或预训练奖励模型[Yu等，2024a;Ouyang等，2022]生成偏好数据。例如，Yuan等[2024d]利用模型自评能力对其生成的解打分。但自评能力有限，奖励函数泛化性弱，导致评估易受噪声干扰。Wang等[2024c]提出“基于不确定性的偏好优化”框架，使用贝叶斯神经网络量化每个偏好对的不确定性，并将其融入DPO训练，提升鲁棒性。<br>步骤级偏好优化<br>相较于粗粒度的解级优化，步骤级偏好优化可更精准地引导模型学习。例如，在一条错误解中，前半部分推理正确，仅后续出错。如果直接按解级优化，可能会误伤前面正确的部分。为解决这一问题，研究人员探索了步骤级偏好优化。相关工作可分为两类：主动构建和树搜索。<br>主动构建方法（activeconstructionapproach）的核心思想是：在具有相同前缀的推理轨迹中，有针对性地采样正确或错误的子轨迹。Hwang等人[2024]首先使用蒙特卡洛采样定位缺陷轨迹y-中的首个错误步骤。从该步骤起，将每个步骤与其前置上下文拼接，并对其进行多轮采样。若某一步骤生成的所有推理过程均失败，则将该步骤判定为错误。接着，以此前的步骤为上下文，构造出一条新的正确轨迹y+。由y+和y-构成的偏好对具有相同前缀，可用于训练。随后，采用如DPO等偏好对齐算法对模型进行优化，使其聚焦于改进决定正误的轨迹后缀。Lai等人[2024]提出类似策略，使用GPT-4检测错误步骤，并结合DPO实现步骤级偏好优化（Step-DPO）。相比之下，Lu等人[2024c]从一条正确轨迹出发，通过调高采样温度诱导生成错误的后续步骤，从而构建失败轨迹。类似方法，利用GPT-4作为监视器检测不正确步骤，随后应用DPO进行步骤级偏好优化，称为Step-DPO。相比之下，Lu等[2024c]采用不同策略：从正确轨迹开始，通过设置高温度生成不正确的后续步骤，诱导失败后缀。<br>树搜索方法（Treesearch-basedmethods）则直接从搜索树中提取偏好对。Zhang等人[2024h]使用思维树（Tree-of-Thought,ToT）[Yao等，2023]进行搜索，并在过程中通过自我评估对节点进行打分。一旦找到正确的推理路径，即可基于该路径上的节点构造偏好对。在广度优先搜索中，若某节点在从正确路径延展时被剪枝，则其对应步骤可视为负例，与正确路径节点构成偏好对。相较ToT，许多工作更偏好使用MCTS进行搜索，因其能更好地平衡探索与利用。Xie等人[2024]和Chen等人[2024c]便在MCTS基础上构造偏好对。前者选择同一层级中Q值最高与最低的节点组成偏好对；后者则从同一父节点的子节点中选取Q值差异较大的节点对，作为优化目标。<br>词元级偏好优化<br>近期研究开始探索词元级偏好优化，以支持更细粒度的推理能力提升。该方法的核心挑战在于获取词元级偏好对。Rafailov等人[2024]与Zhong等人[2024]指出，通过直接偏好优化（DPO）训练的策略模型可以隐式学习词元级奖励信号，形式为“隐式奖励”：<br>这一发现为构建词元级DPO算法提供了理论基础。Yang等人[2024b]在此基础上进一步对隐式奖励进行了改进，以提升优化效果。<br>作为补充方法，Lin等人[2024]提出cDPO算法，从另一个视角标注词元级重要性。其方法是在正确与错误解上分别微调两个语言模型，并计算两者在每个词元上的概率差异，从而估计该词元在错误推理中所承担的责任。对于差异分数较低的词元st，意味着其对推理失败影响更大，可据此对关键词元进行加权优化。<br>尽管基于DPO的方法因实现简单而得到广泛应用，但其在推理增强方面仍存在局限，如4.1.5节所述。值得关注的是，O1博客[OpenAI,2024b]与R1报告[DeepSeek-AI等，2025]均强调：若要实现复杂推理能力的显著跃升，最终仍可能需要引入在线强化学习技术，凸显更高级优化框架的重要性。<br>无模型在线强化学习（Model-freeOnlineReinforcementLearning）<br>对于数学推理等任务，其环境动态具有确定性，因为推理过程中并不涉及对外部环境的感知或交互。每执行一个动作（如生成一个词元或推理步骤），模型的推理状态便会自动更新，例如通过将新生成的词元追加至已有上下文中形成新的推理状态。随着大语言模型推理效率的提升，从模型中采样生成完整推理路径已变得高效且低成本。因此，在此类任务中，通常无需构建环境模型，仅依赖无模型（model-free）在线强化学习算法即可实现有效优化。<br>“无模型”是指不对环境进行显式建模，而是通过策略直接与环境交互来学习；“在线”则意味着训练数据来源于当前策略与环境的实时交互，而非依赖固定的历史数据集（即“离线”学习）。在线与离线学习方式的差异，会显著影响强化学习过程中的数据分布偏移问题。<br>在大语言模型（LLM）训练中，常用的在线强化学习方法包括REINFORCE[Sutton等，1999]、PPO[Schulman等，2017]和GRPO[Shao等，2024]。Li等[2023d]和Ahmadian等[2024]发现，在没有结果奖励模型（ORM）和价值模型的情况下，直接应用REINFORCE取得了良好效果。Ylfeng等[2024]受人类反馈强化学习（RLHF）的启发，使用PPO在解决方案层面提升了LLM的推理能力。Zhang等[2024j]学习了过程奖励模型（PRM），并在步骤层面利用其指导PPO训练。Zhong等[2024]利用直接偏好优化（DPO）的隐式奖励，在词元层面进一步指导PPO训练。诸如deepseek-math[Shao等，2024]、qwen-math[Yang等，2024a]和OpenR[Wang等，2024e]等项目采用GRPO[Shao等，2024]进行训练，训练过程由PRM指导，显著增强了LLM的多跳推理能力。尽管当前的无模型强化学习算法取得了成功，但随着任务复杂性的增加和推理任务扩展到更多现实场景，仅依赖无交互的环境是不够的。在这种情况下，预计更为多样化的强化学习算法将在LLM的后续训练优化中发挥关键作用。<br>图7：三种强化学习范式的比较：在线基于模型的强化学习、基于模型的强化学习、离线强化学习和层次强化学习。<br>离线强化学习（OfflineReinforcementLearning）<br>离线强化学习使用静态数据集而非通过策略模型与环境交互收集的轨迹数据来训练策略模型[Prudencio等，2022]。由于训练大语言模型的时间和计算成本，批量训练在大规模微调过程中提供了显著优势。因此，许多研究，特别是在学术界，采用离线训练方法来训练大语言模型。<br>Snell等人[2022]对现有的离线强化学习算法IQL进行了改进，并将其应用于自然语言生成任务，提出了ILQL算法。当前最常用的离线训练方法是DPO[Rafailov等，2023]，其基本流程是先收集大量偏好数据，再在此基础上进行偏好学习。该方法不仅省去了奖励建模的步骤，也极大推动了DPO的广泛应用。为克服DPO仅依赖偏好信息、无法利用实际奖励值的局限，Wang等人[2024b]基于最大熵强化学习[Haarnoja等，2017]推导出一种新的离线强化学习方法OREO，有效弥补了上述不足。<br>尽管离线强化学习（尤其是DPO）在当前研究中被广泛采用，但该方法仍存在一些显著局限。其核心问题在于训练数据并非源自当前策略模型，而是采样自先前的次优策略。随着训练过程中策略模型的持续优化，行为策略与目标策略之间的偏差不断扩大，严重削弱了训练效果。对此，Chen等人[2024a]提出，可通过将离线训练过渡为在线训练策略来缓解该问题。另一种常见做法是，先利用离线强化学习对大语言模型进行初始化[Yang等，2024c；He等，2024c]，再结合在线强化学习进一步提升性能。相较于在线强化学习，离线方法具备可预先构造训练信号的优势，因而在存在标准答案、但难以通过奖励模型精确评估的任务中尤为适用[Yang等，2024c]。<br>基于模型的强化学习（Model-basedReinforcementLearning）<br>对于涉及与外部环境交互的任务（如对话系统和视觉导航），环境建模是强化学习中的关键环节[Moerland等，2020]。通过构建模拟环境（或称“世界模型”）[Zhu等，2024]，系统能够在训练与推理过程中提供反馈信号、状态转移以及内部规划能力，从而显著降低交互成本。有效的世界模型应具备充分的任务知识，能够针对策略模型的动作准确预测状态转移和奖励反馈。<br>典型实例包括AlphaGoZero[Silver等，2017]，其通过建模对手并结合蒙特卡洛树搜索（MCTS）模拟博弈状态，用于优化策略学习。类似地，Hao等[2023]证明了大语言模型可作为规划任务中的世界模型，He等[2024c]则在对话规划中引入大语言模型，通过MCTS框架模拟用户交互。<br>尽管已有初步进展，基于模型的强化学习在大语言模型主导的复杂推理任务中仍显不足，尤其是在数学推理等不涉及外部环境动态的场景中应用受限。然而，随着研究不断向更高复杂度任务迈进，世界模型与基于模型的强化学习在大语言模型中的融合有望成为重要发展方向，为推理能力的进一步提升开辟新路径。<br>层次强化学习（HierarchicalReinforcementLearning）<br>许多推理任务可有效建模为层次马尔可夫决策过程（HierarchicalMDPs），反映人类认知的分层特征。例如，在数学推理中，学生往往不会逐词生成解答，而是先构思一系列推理步骤，然后再基于这些步骤填充具体内容。这一过程自然划分为两个层级：高层模型生成抽象的推理思路，低层模型在此基础上生成对应的词元内容。<br>Liu等[2024b]将推理任务形式化为层次MDP：高层模型首先选择推理策略（如思维链CoT[Wei等，2022]、由浅入深提示L2M[Zhou等，2022]、编程式推理PoT[Chen等，2022]），再生成具体推理过程；若推理失败，则迭代选择新的策略。SMART[Liu等，2024b]采用策略梯度方法[Lee等，2024c]优化高层决策过程，但未涉及低层推理的优化。ReasonFlux[Yang等，2025a]则构建了一系列“思维模板”，通过高层规划生成推理意图序列，再在具体任务上下文中对每一项意图进行实例化，最终形成完整、连贯的推理路径。这种结构化方法有效地将复杂任务解构为抽象高层计划与对应的可执行推理子任务。类似地，Zhou等[2024]提出ArCHer框架——一个用于大语言模型的层次强化学习方法。在高层，ArCHer使用基于值函数的离线强化学习算法IQL[Kostrikov等，2021]学习话语级Q-函数与V-函数，以结果奖励评估响应质量；在低层，则使用REINFORCE[Sutton等，1999]优化词元级MDP，低层奖励由高层优势函数提供。<br>通过引入层次学习机制，大语言模型不仅能够实现抽象推理步骤之间的连贯性，还能摆脱逐词回忆的模式，学会更具结构化的推理策略，从而显著提升其在复杂推理任务中的表现能力。<br>在本节中，我们首先介绍优化评估器的数据构建方法，包括结果级（outcome-level）、步骤级（step-level）和词元级（token-level）数据构建。<br>结果级结果级奖励构建相对直接。早期RLHF方法依赖人工标注的偏好数据来训练奖励模型，但高昂的人工成本推动了自动标注方法的发展。<br>最简单的自动方法是利用答案标签将解决方案划分为正确与错误，并构造偏好对，基于DPO方法训练奖励模型[Hosseini等，2024]。也可使用更强的大模型评估推理正确性，如Lee等[2024a]利用更强的LLM对响应打分（0-10分），再基于该数据训练奖励模型。此外，Mu等[2024]提出基于规则的奖励机制，将期望行为拆解为具体规则并分配得分，最终与传统RLHF奖励结合，通过PPO优化模型。类似地，DeepSeek-AI等[2025]为推理任务设计了结合准确性与格式规范的规则奖励体系，构建了更全面的训练信号。<br>这些自动方法不仅降低了对人工标注的依赖，还提升了奖励模型训练的效率与可扩展性，推动了RLHF在复杂推理任务中的应用。<br>步骤级为获取步骤级评估信号，OpenAI发布了过程奖励数据集PRM800K[Lightman等，2023]。然而，随着推理任务持续涌现且评估器需具备良好泛化能力，PRM数据的扩展显得必要。手动标注代价高昂、难以扩展，而基于LLM的评判方法虽易实现，但存在不稳定性与噪声问题[Zheng等，2023；Ye等，2025]，因此更高效的自动标注方法成为研究重点。当前自动标注方法主要可分为三类：<br>第一类：估计步骤正确性。Wang等[2024g,m]和Jiao等[2024]通过蒙特卡洛采样估算步骤奖励，以步骤Si的N次完成的成功率为其奖励。Luo等[2024]结合二分查找和MCTS识别首个错误步骤，提高采样效率。Zhang等[2024f]、Xia等[2024]和Gao等[2024a]则直接采用LLM评估步骤正确性。Zhang等[2025b]指出MC采样存在较大噪声，提出共识过滤机制，将MC估计与LLM验证结合，以提升数据准确性。与此不同，Chen等[2024g]将问题分解为子问题，并从标准解中提取中间结果，将其与模型生成结果比对评估步骤正确性。<br>第二类：基于标签生成步骤内容。此类方法主动向正确推理过程注入错误，以构建包含错误步骤的数据集。Yan等[2024]通过高温采样生成错误，并基于正确解生成反思与修正。Xi等[2024]则主动插入错误并引导模型生成反思，构造高质量的修正数据。<br>第三类：通过置信度变化评估步骤质量。该类方法基于以下假设：优质推理步骤提升推理置信度，劣质步骤则降低之。Lu等[2024a]提出利用结果监督验证器评估相邻步骤之间置信度变化，以此标注步骤正确性，同时避免大规模采样以降低计算开销。<br>词元级为获取更高细粒度的奖励信号，需自动评估各词元的重要性。Chen等[2024h]训练一个可重写原始解的生成式奖励模型，输入重写结果后，原始解中每个词元的预测概率即为其奖励。该方法假设：错误词元更可能被修改，其概率下降；而正确词元预测一致，概率更高。Yoon等[2024]采用类似策略，利用强LLM对错误解yr进行“添加、删除、替换”三种操作的迭代修正，并通过与修改前ym的对比，为每个词元标注奖励。Rafailov等[2024]、Zhong等[2024]从DPO框架导出隐式奖励，形式为：<br>此信号可用于词元级标注。Yang等[2024b]将其作为初始评分标准，对正确推理中前k%的词元赋予奖励1，其余为0；对错误推理中后k%的词元赋值为-1。OREA[Lyu等，2025]进一步将词元级奖励总和与整体结果奖励对齐，从而实现词元级奖励模型的学习。<br>点式（Point-wise）当评估结果为标量值时，最直接的方式是通过监督学习训练评估模型。例如，Wang等[2024g,m]采样并完成推理步骤，使用完整路径的成功概率作为每一步的评分，从而训练步骤级的过程监督验证器（PSV）。Lu等[2024a]则先基于真实答案标注每个推理步骤，并训练结果监督验证器（OSV）以估计每一步通向正确解的概率；随后，通过计算相邻步骤间的置信度变化生成步骤级标签，用以训练PSV。</p>
<p>该方法无需精确标注分数，仅依赖偏好数据训练。例如，Yu等[2024b]和Hosseini等[2024]采用DPO从偏好对中学习奖励函数，Liang等[2024]基于答案正确性对来自多个模型的解进行偏好划分，并使用SimPO[Meng等，2024b]训练评估模型。<br>为克服现有验证器仅在二元标签路径上训练、难以刻画中间步骤间相对优劣的问题，He等[2024b]提出树结构方法：对每个树节点采样补全路径，并以其导向正确解的比例作为奖励，进一步通过兄弟节点间的奖励比较，构造步骤级偏好对，并以排序损失训练验证器。<br>在此基础上，Yuan等[2023b]提出奖励加权偏好学习（RRHF），通过从多个来源（如模型自身、其他大语言模型、人类专家）采样响应，并根据人工偏好或模型打分进行排序，实现对响应条件概率的排序优化，从而提升生成质量。上述方法共同推动了偏好驱动评估与优化框架的高效发展。<br>自回归（Autoregressive）近年来，充分挖掘大语言模型自身的生成能力，成为提升评估器鲁棒性与可解释性的关键策略。相关方法主要按反馈形式可分为两类：概率分数型（probabilityscores）与口头批评型（verbalcritiques）。<br>在概率型方法中，研究者从自然语言反馈中提取特定词元的生成概率作为评分依据。例如，Zhang等[2024f]提示模型回答“答案是否正确（是&#x2F;否）”，并将生成“是”的概率作为评分依据，对应优化目标为生成正确答案词元。为提升解释性与稳健性，Zhang等[2024f]、Ankner等[2024b]、Gao等[2024a]引入思维链（CoT）辅助答案生成，采用“两阶段训练”：先生成可解释思维过程，再据此输出答案。此外，Mahan等[2024]提出CoT-GenRM-STaR，结合误判数据与DPO优化生成式奖励模型，进一步推动该方向研究。<br>相比之下，口头反馈提供更丰富的上下文信息，如错误位置与原因，便于指导后续纠错与回溯。该类能力的优化路径可分为行为克隆（BC）与强化学习（RL）。BC是最直接策略，其数据构建方式详见第4.3.1节。Xi等[2024]通过人为注入噪声并引导模型生成批评，进而训练评估器。由于构造数据的困难，不少研究转向RL方法学习自评能力。RL4F[Akyürek等，2023]与Retroformer[Yao等，2024b]将反馈生成建模为RL任务：状态为当前生成内容与环境反馈，行动为生成具体反馈，前后质量差异作为奖励信号。Xie等[2025b]则采用BC初始化模型，并通过RL精调，展现了两者互补性。最前沿的开源工作，如R1[DeepSeek-AI等，2025]与Kimik1.5[Team等，2025]，均在推理过程中引入口头反馈自评机制，并借助基于规则的奖励框架，通过RL联合优化逐步推理与自我评估能力。<br>在后处理阶段，研究重点在于提升模型的纠错能力。根据优化方式的不同，这些方法可划分为两类：行为克隆（BehaviorCloning）与强化学习（ReinforcementLearning）。<br>行为克隆<br>该类方法包括两类思路：增强模型自身的自我纠错能力，或训练辅助模型协助完成纠错。前者如Zhang等[2024a]、An等[2023]、Yan等[2024]、Paul等[2024]、Gao等[2024c]通过错误采样技术，利用更强的外部模型或多轮自生成样本生成纠错数据，并据此进行监督微调（SFT），提升模型的自我纠错能力。Du等[2024]则构建渐进式训练集，强化模型的逐步改进能力。<br>后者则聚焦于构建专门的辅助模型。例如，Welleck等[2023]、Zhang等[2024i]、Wadhwa等[2024]训练独立的精炼器模型用于答案修正。Shridhar等[2024]提出提问器模型，判断是否需要纠错并辅助实施纠错操作。Wang等[2024l]则将模型在反思阶段的知识整理成代码本，以实现知识的存储、检索与复用，进一步提升模型的解决问题能力。<br>强化学习<br>Kumar等[2024]指出，基于SFT的方法在自我纠错学习中存在两大挑战：其一是分布偏移，即模型能纠正初始模型的错误，但难以应对自身生成的新错误；其二是行为崩溃，即模型偏向优化初始输出，忽略真正的纠错行为。为此，他们提出一种策略内的多轮强化学习方法，尽管该方法仅生成两轮解答（初始解与修订解），并未引入推理过程中的反馈信息，因此仍难以充分利用外部信号。<br>为进一步突破该限制，Gehring等[2024]提出整合外部执行反馈的强化学习算法，使模型能有效吸收外部反馈信号，增强自我优化能力。<br>值得注意的是，R1[DeepSeek-AI等，2025]、Kimik1.5[Team等，2025]及T1[Hou等，2025]等研究并未在架构上明确区分推理器、评估器与后处理器模块。相反，这些能力在统一的动作空间内，在相同的结果奖励信号指导下被协同优化，从而实现统一的推理、自评与纠错学习。<br>值得注意的是，R1[DeepSeek-AI等，2025]、Kimik1.5[Team等，2025]和T1[Hou等，2025]等研究在物理上并未明确区分推理器、评估器和后处理器。相反，在相同的结果奖励指导下，推理、自我评估、自我纠正等能力在相同的行动空间中同时得到优化。<br>图9：对自我进化的直观理解每轮自我进化由两部分组成：数据进化与模型进化。系统首先通过数据进化（主要基于搜索）突破原有能力边界，获得更高质量的解答作为新一轮训练数据；随后，系统通过模型进化从这些数据中学习，从而扩展其能力边界，实现性能的持续提升。<br>5.自我进化<br>在“数据进化”部分，我们探讨了如何通过任务进化与思维链进化生成更高质量的训练数据；在“模型进化”部分，我们研究了提升系统各模块性能的方法。然而，仅依赖数据或模型单一方向的进化，难以构建出性能卓越的推理系统。数据进化虽可通过推理阶段的计算开销提升模型性能，却受限于模型本身的能力上限；而模型进化若缺乏高质量数据支持，也无法实现持续优化。<br>因此，本节关注“自我进化”，即在循环机制中融合数据与模型进化，实现系统的持续增强。如图9所示，我们直观展示了自我进化的运作机制：推理系统无需人工介入，依靠自身不断生成数据并迭代优化能力。然而在实践中，自我进化仍面临若干关键挑战，例如如何保证系统性能持续提升、如何协调模块间的协同进化。接下来，我们将依次探讨其收敛性理论、自我进化的规模法则、自进化策略与模式的实践工作，最后从自我进化的视角重释典型的类O1工作。<br>自我进化要求系统利用自身生成的数据，在无外部干预的前提下持续提升性能[Zelikman等，2022]。这一“自驱动”训练过程的理论基础亟需厘清。为验证其有效性，需回答两个研究问题：<br>[研究问题1]推理的自我进化是否遵循规模法则？<br>[研究问题2]哪些关键因素促使自我进化实现持续性能提升？<br>[研究问题1]推理的自我进化是否遵循规模法则？<br>我们首先讨论在任务集固定的前提下，自我进化是否能够收敛。Singh等[2023]从期望最大化（ExpectationMaximization,EM）[Moon,1996]视角对此进行了建模。具体而言，推理任务形式化为，其中x为输入问题，为正确答案。大语言模型通常生成一个推理链y来辅助推导最终答案，因此可将y视为潜变量。设定O&#x3D;1表示输出正确（即），最终优化目标为：<br>对于含有潜变量的优化问题，EM算法是常用方法。<br>在E步骤中，固定p(O&#x3D;1,y|x)，通过最小化来最大化目标，最终得到：<br>这一结果可解释为：先生成推理过程y，再通过p(O&#x3D;1|x,y)判断该推理过程是否能导出正确答案。因此，E步骤对应于建模“数据生成与评价”的过程。<br>在M步骤中，固定q(y|x)，目标变为最小化：<br>M步骤旨在使用生成的数据训练推理模型pΦ(y|x)，即学习模型进化的过程。由于EM具有理论收敛性，我们有理由相信这种数据与模型交替改进的迭代过程是可收敛的。<br>但需要注意的是，上述分析依赖于“固定任务集”的假设。当任务本身也在演化时，是否仍具收敛性仍是一个悬而未决的问题。从直觉来看，任务集的扩展有助于覆盖更多分布区域，从而提高模型泛化能力。然而，自我进化是否存在规模法则，还取决于任务演化本身是否也服从某种规律——即它是否存在先验的复杂度上限。<br>当然，以上结论尚属理论推导，仍需进一步实证研究加以验证。<br>[研究问题2]自我进化实现持续改进的关键因素是什么？<br>Zeng等[2024a]发现，在现有的自我进化方法中，经过3到4个训练周期后，性能增益明显减小，甚至出现性能下降的现象。为研究影响模型性能的瓶颈，Zeng等[2024a]分析了模型所搜索到的推理轨迹的多样性。结果表明，随着自我进化训练的进行，推理轨迹的多样性显著减少。这是因为被高度评估的轨迹更有可能被重新采样，从而导致推理模型收敛到较为狭窄的推理模式。虽然这种探索减少有助于模型聚焦于生成更高质量的推理过程，但也意味着模型未能探索新的知识，进而阻碍了其泛化能力的提升。<br>基于这些观察，Zeng等[2024a]提出了一个新的自我进化框架——B-STAR。首先，他们设计了“平衡分数”（BalanceScore）指标，用于衡量训练过程中模型的探索能力。随后，他们引入了一种基于采样温度和奖励过滤阈值的动态训练策略，旨在缓解自我进化过程中探索性下降的问题。B-STAR框架的结论表明，影响自我进化性能的关键因素是大语言模型在训练过程中遇到的推理轨迹的多样性。当这种多样性减少时，进化效果也会随之减弱。<br>从更高层次的角度来看，B-STAR通过加强思维链（CoT）进化的探索力度，提升了推理系统的泛化能力。遵循这一推理泛化的改进原则，可以采用以下额外策略进一步增强系统的泛化能力：1）增加任务的多样性和难度可以直接增强推理轨迹的多样性，进而改善系统的泛化能力[Li等，2024a]；2）提升系统的自我评估和后处理能力，有助于在遇到错误时显著增强系统的鲁棒性；3）提高推理器逻辑的一致性和泛化能力，可以有效降低错误的发生频率。<br>在预备部分中，我们已界定了推理系统中的四个关键模块及其功能与相互关系。由此，推理系统可视为一个多智能体系统，理论上任何一个模块的进化都应提升整体性能，联合优化则有望带来更显著的性能增益。下文总结三类适用于推理系统的多智能体训练策略。<br>早期自我进化系统中，模块优化通常相对独立，仅聚焦单个模块，且模块间耦合性较弱。例如，Zelikman等[2022]、Gulcehre等[2023]使用标准答案筛选正确解，以提升推理器性能；Hosseini等[2024]亦基于标准答案构造偏好对，用DPO训练验证器，但验证器未能反哺推理器训练。Madaan等[2023b]通过解的迭代修正实现逻辑自我进化，然而结果表明仅依赖上下文学习难以实现自我纠错。Wang等[2023d]在推理阶段优化后处理器，推理器仅生成初始解，对后续演化无贡献。<br>独立进化实现简单，易于部署，但提升有限。对各模块演化机制的单独研究可为未来多模块联合优化奠定基础。<br>在涉及多个模块的联合进化时，一种常见方法是利用模块之间的合作来提高整体系统性能。<br>协作进化通过模块间信息共享提升整体性能。Jiang等[2024a]用推理器生成正确与错误解构建奖励模型训练数据，同时用奖励模型筛选优质解反哺推理器训练。Wang等[2024e]采用强化学习训练整个推理系统，策略迭代中使用过程奖励模型（评估器）提供优化信号，价值迭代中利用推理器生成的数据训练评估器。<br>上述工作表明，未来应进一步探索更复杂的协同策略。<br>除协作外，对抗机制也是一种有效的联合学习策略。如GAN[Goodfellow等,2014]中生成器与判别器的博弈极大推动了生成模型的发展。在推理系统中，任务生成器与推理器天然构成对抗关系：前者提出更具挑战性的任务，后者尝试解决之。Ye等[2024]提出推理器与任务生成器的对抗训练框架。推理器通过ReST[Gulcehre等,2023]迭代优化，任务生成器基于不确定性选择种子任务并通过EvalInstruct生成多样任务。此过程实现了任务生成器与推理器的联动进化。<br>对抗机制较协作更难学习，但能缓解模型陷入局部最优的问题，而协作机制则可能加剧此风险。若合理融合协作与对抗策略，系统有望获得更大性能提升。<br>在讨论整体策略之后，我们从模块视角出发，进一步分析多种自我进化模式。<br>多数方法直接优化推理器以提升系统性能，这类方法实现简单，差异主要体现在训练数据构造与训练方式上。<br>在推理器训练方面，Gulcehre等[2023]、Min等[2024]、Zelikman等[2022]在正确推理轨迹上进行监督微调（SFT）；Chen等[2024b]、Xie等[2024]、Wang等[2024j,k]使用蒙特卡洛树搜索（MCTS）筛选偏好数据并据此训练推理器；Gulcehre等[2023]则通过奖励模型生成的奖励，利用强化学习优化推理器。<br>在数据获取方面，Singh等[2023]、Min等[2024]、Pang等[2024]直接使用标准答案筛选正确样本用于下一轮训练；Zelikman等[2022]通过将正确答案作为提示，重新生成原本错误问题的解答，以提升正样本比例；Peng等[2024]指出在STaR[Zelikman等，2022]中直接提供答案可能导致模型形成捷径，因此仅在抽象推理阶段提供答案；Huang等[2022]、Li等[2024c]则在无答案标签场景中利用一致性筛选答案以构建数据。<br>此外，Aksitov等[2023]、Dong等[2023]使用奖励模型对推理轨迹进行评分和排序，筛选高质量轨迹训练推理器；Song等[2024]依据环境奖励过滤低质量轨迹。<br>在自我进化中，评估器需评估推理过程，但其泛化能力是关键难点。随着训练深入，推理器生成的问题与推理过程可能偏离评估器的训练分布，影响评估效果，因此提升评估器的泛化能力至关重要。<br>Yuan等[2024d]、Wang等[2024c]使用推理器生成的正确推理过程训练推理器，同时利用正负样本训练奖励模型，从而提升评估器性能。Jiang等[2024a]进一步引入奖励模型参与样本筛选，并采用主动学习优先处理难例。Zhang等[2024c]、Guan等[2025]提出推理器与评估器的迭代训练框架：推理器通过MCTS获得步骤级价值估计，训练出过程奖励模型（PPM），后者再用于提升推理轨迹质量，反哺推理器。Zhang等[2024j]、Wang等[2024e]采用强化学习训练推理器，并用过程奖励评分指导其优化，实现推理器与评估器的协同进化。Chen等[2024b]、Zhang等[2024c]不直接使用评估器，而是通过奖励模型引导MCTS搜索以提高推理器生成解的正确率。Cheng等[2024]、Chen等[2024i]探索推理器与评估器的对抗训练，评估器判断回答是否与标准一致，推理器则试图生成混淆评估器的回答。然而该方法在推理任务中仍待验证，因为推理任务重在答案正确性而非过程一致性，推理多样性更能体现模型能力，仅对齐标准过程可能适得其反。<br>推理器越强大，后处理器（尤其是精炼器）所需的修正压力越小。一些工作致力于这两个模块的协同优化。Dou等[2024]首先用推理器生成初始解，再进行精炼；Wang等[2023d]采用多轮精炼，直至解正确或达到最大轮数。训练过程中，Dou等[2024]采集精炼后的解并通过SFT训练精炼器，同时用正确解对推理器进行SFT以增强其推理能力；Wang等[2023d]则将精炼过程建模为马尔可夫决策过程，使用强化学习优化精炼器各轮修改操作，并以最终解为目标训练推理器，二者同步优化。<br>任务的多样性与复杂性对自我进化效果影响显著。若仅在静态任务集上学习，推理器容易过拟合，降低对分布外任务的适应能力，因此任务创建器的进化亦至关重要。Ye等[2024]提出推理器与任务创建器的对抗训练框架：任务创建器持续生成更具挑战性的任务，推理器则提升能力以应对挑战。该方法如第5.2.3节所述，通过对抗学习实现双向进化，保障持续改进。<br>相较于只进化单一或双模块的工作，推理器、评估器与后处理器的联合进化理论上可实现更大性能提升。近期工作如R1[DeepSeek-AI等，2025]、T1[Hou等，2025]、Kimi-k1.5[Team等，2025]专注于学习长思维链（LongCoT）[Xu等，2025]，即是一例。这些方法生成包含自评、自反思与自纠错操作的长思维链，并通过基于结果奖励的在线强化学习对LLM进行优化。<br>首先，基于在线RL的推理学习天然契合自我进化框架。与依赖静态数据集的方法不同，在线RL驱动模型与环境交互、生成轨迹与奖励进行优化，随着训练推进，模型探索出更多样化且更高质量的解，并可通过探索-利用机制缓解性能停滞。<br>此外，R1等方法未显式划分评估器与后处理器，也未分别优化其评估与纠错能力（如rStar-Math[Guan等，2025]），而是在统一的行动空间与结果奖励引导下，同时优化推理、验证、评估、反思与纠错能力。因此我们认为，R1类工作在实质上已实现推理、评估与后处理能力的协同进化。基于此结论，也可解释为何其性能超越以往仅聚焦于单一或双模块优化的工作。<br>6.基于自我进化框架解读O1类研究<br>基于对自我进化技术框架的讨论，本节从自我进化的视角重新解读O1类工作。<br>Marco-O1<br>Marco-O1[Zhao等，2024a]使用蒙特卡洛树搜索（MCTS）生成数据集，并在该数据集上进行监督微调（SFT）。尽管未引入迭代训练，MCTS采样体现了数据进化，SFT则代表模型进化。然而，缺乏迭代过程限制了推理性能的持续提升。<br>O1Journey[Qin等，2024;Huang等，2024]引入“旅程学习”（JourneyLearning）概念，探索融合自我反思、自我纠正与回溯的推理过程，契合第3.2.3节所述的长思维链（LongCoT）。生成的思维链依据答案正确性划分为正负样本，并通过DPO优化，体现模型进化。尽管未显式采用自我进化机制，其强大性能源于对隐式试错能力的深层建模。<br>SlowThinking<br>第1部分：SlowThinking[Jiang等，2024a]的第一阶段采用两阶段迭代训练：先由推理器与评估器基于MCTS搜索生成解答及评分（对应数据进化），再以DPO联合优化两个模块（对应模型进化）。由于推理器与评估器联合优化，该方法可归类为“推理器+评估器”自我进化模式。<br>第2部分：SlowThinking[Min等，2024]第二阶段基于QwQ[Team，2024b]和DeepSeek[DeepSeek-AI等，2025]提炼的长形式思维能力，通过探索—学习循环完成自我进化。长思维链的生成反映数据进化中的隐式试错，随后以SFT或DPO优化推理器，构成系统自我进化的完整闭环。<br>rStar-Math<br>rStar-Math[Guan等，2025]是典型的推理自我进化系统，包含三轮训练：1）终端引导的MCTS收集高质量数据用于推理器的SFT；2）使用该数据训练评估器（PRM）；3）利用PRM引导的MCTS采集新数据，重训推理器与评估器。每轮均涵盖数据与模型双重进化，且各轮训练聚焦于不同能力，最终实现整体性能跨轮跃升。<br>OpenR&#x2F;O1-Coder<br>OpenR[Wang等，2024e]与O1-Coder[Zhang等，2024j]使用强化学习联合训练策略模型（推理器）与评估器（PRM）。策略模型通过树搜索（如束搜索、MCTS）探索解答，PRM则提供奖励指导训练，分别体现数据与模型进化。两模块在强化学习框架下实现持续联动式自我进化。<br>DeepSeekR1&#x2F;Kimik1.5<br>R1[DeepSeek-AI等，2025]与Kimik1.5[Team等，2025]是当前领先的开源推理模型，性能已媲美甚至超越O1[OpenAI，2024b]。其核心算法一致，采用在线强化学习训练，仅依赖结果奖励模型（ORM）进行优化，鼓励策略探索并激发长思维链能力的涌现。<br>此外，该类工作采用的RL训练范式与自我进化理念高度契合：策略探索对应数据进化，奖励驱动对应模型进化。系统通过探索—学习的循环实现持续进化。更重要的是，R1等工作不仅优化逐步推理，还同时提升评估、反思与自我纠错能力，符合第5.3.5节所述的“推理器+评估器+后处理器”共进模式。正是这种多模块协同进化，使其在性能上显著优于仅进化单模块的早期系统。<br>7.未来挑战和方向<br>如何更有效地自我进化推理能力？<br>更具前景的自我进化模式：前文提及五种常见的自我进化模式，但从理论上讲，这四个模块存在$$2^4-1&#x3D;15$$种可能的优化组合。通过探索不同的模块组合及合作与对抗等训练策略，有望构建更高效的自我进化框架。理想情况下，四个模块的同步增强将带来持续且显著的性能提升。<br>系统泛化：自我进化通过迭代训练提升系统性能。持续进化的关键在于防止过拟合并确保泛化能力。首先，任务泛化至关重要；合成更多样化和复杂的任务可以确保更广泛的覆盖范围，这是解决泛化问题的基础[Yu等，2024a]。其次，推理器、评估器和后处理器的泛化能力同样重要。B-StAR[Zeng等，2024a]表明，增强推理器的探索能力可以减少过拟合。后处理器在多样化解决方案方面也发挥着关键作用。此外，奖励欺骗问题表明，当前评估器可能对推理器过拟合并利用奖励捷径。总之，推理系统的泛化能力对于自我进化框架中的持续提升至关重要。<br>我们如何在自我进化框架内进一步增强大语言模型的复杂推理能力？<br>尽管O1和R1等模型展示了令人印象深刻的推理能力，但仍有显著的改进空间，包括增强推理能力和提高词元效率。持续训练至关重要，但应专注于解决关键挑战。在未来研究中，以下几个关键问题仍需解决：<br>如何进一步增强任务多样性？艰难任务是提升系统泛化能力的有效途径之一。例如，Min等[2024]指出，由于任务池稀疏，模型在仅经历少量迭代训练后便趋于收敛。为维持持续的自我进化，亟需提升任务的多样性与复杂性。尽管R1等方法有效增强了逐步推理、自我评估与自我纠正等能力，但尚未纳入任务进化机制。若能引入有效的任务进化，有望实现更显著且持久的性能提升。目前，相关方法仍较为初级，亟待进一步研究以构建更加多样化、复杂且具挑战性的任务集。<br>如何开发更细致的奖励建模？R1等工作表明，仅使用结果奖励模型（ORM）即可实现令人满意的推理能力，而其在蒙特卡洛树搜索+过程奖励模型（PRM）方面的失败尝试加剧了对PRM实用性的质疑。与可学习的PRM相比，R1采用的基于规则的ORM在泛化和缓解奖励欺骗方面具备优势。然而，这种ORM在优化过程中无法提供细粒度的奖励。分析表明，R1等模型倾向于在简单问题上过度思考，而在复杂问题上思考不足[Chen等，2024f;Wang等，2025a]，这可能激励PRM的研究，因为PRM可以提供过程信号以指导高效的逐步推理。然而，PRM的弱泛化能力、持续更新和奖励欺骗等挑战仍是其进一步发展的重大障碍。R1通过自我评估实现PRM，并使用ORM同时优化逐步推理、自我评估和自我纠正能力，但并未特别优化自我评估。自我评估的持续有效增强仍需进一步研究。<br>如何平衡效率与有效性以确定最佳思维链进化？短思维链的显式树搜索具备较高效率，但缺乏长思维链的泛化能力。尽管试错搜索模仿了人类推理，但其存在过度思考和思考不足等缺陷。因此需要思考如何在推理时计算阶段结合两种搜索类型的优势。一种可能的解决方案是增强大语言模型的自我评估和自我纠正能力，以缓解过度思考和思考不足。另一个潜在方向是在推理过程中将显式树搜索原则与试错相结合，从而提升R1中序列推理的性能。<br>自我进化推理如何应用于具身智能场景？<br>本综述聚焦于文本模态中复杂推理任务的自我进化。然而，未来的人工智能系统需要与现实世界交互[Wang等，2024d]，其中许多场景需要跨多模态数据进行推理[Xiang等，2024;Yao等，2024a;Wu等，2025a]。为实现这一目标，必须解决以下挑战：首先，全面理解多模态数据是多模态推理的基础。其次，必须重新定义思维链的格式，例如考虑是否应将多模态数据组成的词元纳入思维链[Li等，2025]。此外，多模态场景（如具身智能）中的许多推理任务还面临环境交互成本高和训练数据资源有限等挑战[He等，2024a]。<br>8.结论<br>本综述从自我进化的角度，系统回顾了大语言模型在复杂推理方面的现有研究。我们首先从数据进化和模型进化两个视角审视了相关技术，为自我进化奠定了基础。随后，我们将焦点转向自我进化本身，通过探索系统模块之间的进化关系，分析了现有的自我进化研究。此外，我们进一步分析和总结了现有的类O1开源研究，发现这些研究均可用我们的自我进化框架进行解释。最后，我们希望本综述能够激发更多研究，推动基于大语言模型的复杂推理进一步发展。<br>译者注释：<br>1.[Polu等，2022]应该是Expertiteration而非Expectinteration<br>译者简介<br>部分参考文献，全部参考文献请查看原文</p>
<p>（可上下滑动查看）<br>发起人招募：<br>「人机协同的智能时代」主题读书会<br>随着人工智能技术的不断发展和普及,人类社会正在经历前所未有的变革。特别是以大型语言模型为代表的新一代人工智能技术让我们面临双重心境：一方面，大模型重塑各个行业的速度让人类面临被取代的威胁；另一方面，人们又不断的试探着大模型的能力上限：人类的直觉和情感理解能力，解释性和适应性，包括伦理道德问题都是大模型迈向智能需要翻越的大山。<br>人机协同能够通过人与机器进行合作和协同的工作方式,在高维动态环境下完成复杂的决策任务,需要将人类的归纳、演绎、指挥、决策等优势与机器擅长的计算、存储、搜索、优化等技术相结合,以实现最佳互补效果。这不仅会带来信息论、控制论、系统论、协同论等领域变革，还有可能引发一场人类的认知革命！<br>因此，我们想要招募在人机协同领域的学者，一起来发起以「人机协同的智能时代」为主题的读书会，一起构建主题社区，梳理领域发展与前沿，如果你有意向，请与我们联系：<br>阅读最新前沿科技趋势报告，请访问欧米伽研究所的“未来知识库”<br>https :&#x2F;&#x2F;wx.zsxq.com&#x2F;group&#x2F;454854145828<br>未来知识库是“欧米伽未来研究所”建立的在线知识库平台，收藏的资料范围包括人工智能、脑科学、互联网、超级智能，数智大脑、能源、军事、经济、人类风险等等领域的前沿进展与未来趋势。目前拥有超过8000篇重要资料。每周更新不少于100篇世界范围最新研究资料。欢迎扫描二维码或访问https :&#x2F;&#x2F;wx.zsxq.com&#x2F;group&#x2F;454854145828进入。<br>截止到3月31日”未来知识库”精选的百部前沿科技趋势报告<br>（加入未来知识库，全部资料免费阅读和下载）<br>牛津未来研究院《将人工智能安全视为全球公共产品的影响、挑战与研究重点》<br>麦肯锡：超级智能机构：赋能人们释放人工智能的全部潜力<br>AAAI2025关于人工智能研究未来研究报告<br>斯坦福：2025斯坦福新兴技术评论：十项关键技术及其政策影响分析报告（191页）<br>壳牌：2025能源安全远景报告：能源与人工智能（57页）<br>盖洛普&amp;牛津幸福研究中心：2025年世界幸福报告（260页）<br>Schwab：2025未来共生：以集体社会创新破解重大社会挑战研究报告（36页）<br>IMD：2024年全球数字竞争力排名报告：跨越数字鸿沟人才培养与数字法治是关键（214页）<br>DS系列专题：DeepSeek技术溯源及前沿探索，50页ppt<br>联合国人居署：2024全球城市负责任人工智能评估报告：利用AI构建以人为本的智慧城市（86页）<br>TechUK：2025全球复杂多变背景下的英国科技产业：战略韧性与增长路径研究报告（52页）<br>NAVEXGlobal：2024年十大风险与合规趋势报告（42页）<br>《具身物理交互在机器人-机器人及机器人-人协作中的应用》122页<br>2025-2035年人形机器人发展趋势报告53页<br>EvaluatePharma：2024年全球生物制药行业展望报告：增长驱动力分析（29页）<br>【AAAI2025教程】基础模型与具身智能体的交汇，350页ppt<br>Tracxn：2025全球飞行汽车行业市场研究报告（45页）<br>谷歌：2024人工智能短跑选手（AISprinters）：捕捉新兴市场AI经济机遇报告（39页）<br>【斯坦福博士论文】构建类人化具身智能体：从人类行为中学习<br>《基于传感器的机器学习车辆分类》最新170页<br>美国安全与新兴技术中心：2025CSET对美国人工智能行动计划的建议（18页）<br>罗兰贝格：2024人形机器人的崛起：从科幻到现实：如何参与潜在变革研究报告（11页）<br>兰德公司：2025从研究到现实：NHS的研究和创新是实现十年计划的关键报告（209页）<br>康桥汇世（CambridgeAssociates）：2025年全球经济展望报告（44页）<br>国际能源署：2025迈向核能新时代<br>麦肯锡：人工智能现状，组织如何重塑自身以获取价值<br>威立（Wiley）：2025全球科研人员人工智能研究报告（38页）<br>牛津经济研究院：2025TikTok对美国就业的量化影响研究报告：470万岗位（14页）<br>国际能源署（IEA）：能效2024研究报告（127页）<br>Workday：2025发挥人类潜能：人工智能（AI）技能革命研究报告（20页）<br>CertiK：Hack3D：2024年Web3.0安全报告（28页）<br>世界经济论坛：工业制造中的前沿技术：人工智能代理的崛起》报告<br>迈向推理时代：大型语言模型的长链推理研究综述<br>波士顿咨询：2025亚太地区生成式AI的崛起研究报告：从技术追赶者到全球领导者的跨越（15页）<br>安联（Allianz）：2025新势力崛起：全球芯片战争与半导体产业格局重构研究报告（33页）<br>IMT：2025具身智能（EmbodiedAI）概念、核心要素及未来进展：趋势与挑战研究报告（25页）<br>IEEE：2025具身智能（EmbodiedAI）综述：从模拟器到研究任务的调查分析报告（15页）<br>CCAV：2025当AI接管方向盘：自动驾驶场景下的人机交互认知重构、变革及对策研究报告（124页）<br>《强化学习自我博弈方法在兵棋推演分析与开发中的应用》最新132页<br>《面向科学发现的智能体人工智能：进展、挑战与未来方向综述》<br>全国机器人标准化技术委员会：人形机器人标准化白皮书（2024版）（96页）<br>美国国家科学委员会（NSB）：2024年研究与发展-美国趋势及国际比较（51页）<br>艾昆纬（IQVIA）：2025骨科手术机器人技术的崛起白皮书：创新及未来方向（17页）<br>NPL&amp;Beauhurst：2025英国量子产业洞察报告：私人和公共投资的作用（25页）<br>IEAPVPS：2024光伏系统经济与技术关键绩效指标（KPI）使用最佳实践指南（65页）<br>AGI智能时代：2025让DeepSeek更有趣更有深度的思考研究分析报告（24页）<br>2025军事领域人工智能应用场景、国内外军事人工智能发展现状及未来趋势分析报告（37页）<br>华为：2025鸿蒙生态应用开发白皮书（133页<br>《超级智能战略研究报告》<br>中美技术差距分析报告2025<br>欧洲量子产业联盟（QuIC）：2024年全球量子技术专利态势分析白皮书（34页）<br>美国能源部：2021超级高铁技术（Hyperloop）对电网和交通能源的影响研究报告（60页）<br>罗马大学：2025超级高铁（Hyperloop）：第五种新型交通方式-技术研发进展、优势及局限性研究报告（72页）<br>兰德公司：2025灾难性网络风险保险研究报告：市场趋势与政策选择（93页）<br>GTI：2024先进感知技术白皮书（36页）<br>AAAI：2025人工智能研究的未来报告：17大关键议题（88页）<br>安联Allianz2025新势力崛起全球芯片战争与半导体产业格局重构研究报告<br>威达信：2025全球洪水风险研究报告：现状、趋势及应对措施（22页）<br>兰德公司：迈向人工智能治理研究报告：2024EqualAI峰会洞察及建议（19页）<br>哈佛商业评论：2025人工智能时代下的现代软件开发实践报告（12页）<br>德安华：全球航空航天、国防及政府服务研究报告：2024年回顾及2025年展望（27页）<br>奥雅纳：2024塑造超级高铁（Hyperloop）的未来：监管如何推动发展与创新研究报告（28页）<br>HSOAC：2025美国新兴技术与风险评估报告：太空领域和关键基础设施（24页）<br>Dealroom：2025欧洲经济与科技创新发展态势、挑战及策略研究报告（76页）<br>《无人机辅助的天空地一体化网络：学习算法技术综述》<br>谷歌云（GoogleCloud）：2025年AI商业趋势白皮书（49页）<br>《新兴技术与风险分析：太空领域与关键基础设施》最新报告<br>150页！《DeepSeek大模型生态报告》<br>军事人工智能行业研究报告：技术奇点驱动应用加速智能化重塑现代战争形态-250309（40页）<br>真格基金：2024美国独角兽观察报告（56页）<br>璞跃（PlugandPlay）：2025未来商业研究报告：六大趋势分析（67页）<br>国际电工委员会（IEC）：2025智能水电技术与市场展望报告（90页）<br>RWS：2025智驭AI冲击波：人机协作的未来研究报告（39页）<br>国际电工委员会（IEC）：2025智能水电技术与市场展望报告（90页）<br>RWS：2025智驭AI冲击波：人机协作的未来研究报告（39页）<br>未来今日研究所2025年科技趋势报告第18版1000页<br>模拟真实世界：多模态生成模型的统一综述<br>中国信息协会低空经济分会：低空经济发展报告（2024-2025）（117页）<br>浙江大学：2025语言解码双生花：人类经验与AI算法的镜像之旅（42页）<br>人形机器人行业：由“外”到“内”智能革命-250306（51页）<br>大成：2025年全球人工智能趋势报告：关键法律问题（28页）<br>北京大学：2025年DeepSeek原理和落地应用报告（57页）<br>欧盟委员会人工智能与未来工作研究报告<br>加州大学伯克利分校：面向科学发现的多模态基础模型：在化学、材料和生物学中的应用<br>电子行业：从柔性传感到人形机器人触觉革命-250226（35页）<br>RT轨道交通：2024年中国城市轨道交通市场数据报告（188页）<br>FastMoss：2024年度TikTok生态发展白皮书（122页）<br>CheckPoint：2025年网络安全报告-主要威胁、新兴趋势和CISO建议（57页）<br>【AAAI2025教程】评估大型语言模型：挑战与方法，199页ppt<br>《21世纪美国的主导地位：核聚变》最新报告<br>沃尔特基金会（VoltaFoundation）：2024年全球电池行业年度报告（518页）<br>斯坦福：2025斯坦福新兴技术评论：十项关键技术及其政策影响分析报告（191页）<br>国际科学理事会：2025为人工智能做好国家研究生态系统的准备-2025年战略与进展报告（英文版）（118页）<br>光子盒：2025全球量子计算产业发展展望报告（184页）<br>奥纬论坛：2025塑造未来的城市研究报告：全球1500个城市的商业吸引力指数排名（124页）<br>FutureMatters：2024新兴技术与经济韧性：日本未来发展路径前瞻报告（17页）<br>《人类与人工智能协作的科学与艺术》284页博士论文<br>《论多智能体决策的复杂性：从博弈学习到部分监控》115页<br>《2025年技术展望》56页slides<br>大语言模型在多智能体自动驾驶系统中的应用：近期进展综述<br>【牛津大学博士论文】不确定性量化与因果考量在非策略决策制定中的应用<br>皮尤研究中心：2024美国民众对气候变化及应对政策的态度调研报告：气候政策对美国经济影响的多元观点审视（28页）<br>空间计算行业深度：发展趋势、关键技术、行业应用及相关公司深度梳理-250224（33页）<br>Gartner：2025网络安全中的AI：明确战略方向研究报告（16页）<br>北京大学：2025年DeepSeek系列报告-提示词工程和落地场景（86页）<br>北京大学：2025年DeepSeek系列报告-DeepSeek与AIGC应用（99页）<br>CIC工信安全：2024全球人工智能立法的主要模式、各国实践及发展趋势研究报告（42页）<br>中科闻歌：2025年人工智能技术发展与应用探索报告（61页）<br>AGI智能时代：2025年Grok-3大模型：技术突破与未来展望报告（28页）<br>上下滑动查看更多</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ZejunCao</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://zejuncao.github.io/2025/04/17/1000003074-2650032866-4/">https://zejuncao.github.io/2025/04/17/1000003074-2650032866-4/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ZejunCao</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E5%AE%B6/">
                                    <span class="chip bg-color">人工智能学家</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/04/17/1000003074-2650032866-3/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000003074_2650032866_3.jpg" class="responsive-img" alt="刚刚，ICLR 2025时间检验奖颁给Adam之父！Bengio「注意力机制」摘亚军">
                        
                        <span class="card-title">刚刚，ICLR 2025时间检验奖颁给Adam之父！Bengio「注意力机制」摘亚军</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-04-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E5%AE%B6/">
                        <span class="chip bg-color">人工智能学家</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/04/17/1000000254-2247487877-1/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000000254_2247487877_1.jpg" class="responsive-img" alt="最快开源模型？GLM-Z1上手实测表现如何">
                        
                        <span class="card-title">最快开源模型？GLM-Z1上手实测表现如何</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-04-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/IT%E5%92%96%E5%95%A1%E9%A6%86/">
                        <span class="chip bg-color">IT咖啡馆</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">ZejunCao</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZejunCao" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:caozejun369@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1378463428" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1378463428" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5915009280" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5915009280" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/Garfusion/posts" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/Garfusion/posts" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
