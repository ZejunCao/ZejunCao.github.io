<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="5万字长文全面解读GUI Agent的前世今生, ZejunCao&#39;Blogs">
    <meta name="description" content="5万字长文全面解读GUI Agent的前世今生

仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接

前言今天的主题聚焦于一个激动人心的领域——大型语言模型（LLM）驱动的图形用户界面（GUI）智能体（Agent）。这一领域">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>5万字长文全面解读GUI Agent的前世今生 | ZejunCao&#39;Blogs</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZejunCao&#39;Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZejunCao&#39;Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/frontcover/1000002194_2650447133_3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">5万字长文全面解读GUI Agent的前世今生</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
                                <span class="chip bg-color">开源项目</span>
                            </a>
                        
                            <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0/">
                                <span class="chip bg-color">微信公众号聚合平台</span>
                            </a>
                        
                            <a href="/tags/AINLP/">
                                <span class="chip bg-color">AINLP</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-01-12
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qacueqa-xEgLuZ09L0JUOA">5万字长文全面解读GUI Agent的前世今生</a></p>
<blockquote>
<p>仅用于站内搜索，没有排版格式，具体信息请跳转上方微信公众号内链接</p>
</blockquote>
<p>前言<br>今天的主题聚焦于一个激动人心的领域——大型语言模型（LLM）驱动的图形用户界面（GUI）智能体（Agent）。这一领域融合了人工智能、人机交互和软件工程的跨学科知识，是当前AI领域最活跃的方向之一。本次的综述系列解读将系统梳理LLM驱动GUIAgent的发展脉络，剖析其核心技术、关键挑战及未来机遇，旨在为感兴趣的读者提供详尽指南，并激发更多创新思考。<br>原始综述论文地址：<br>https :&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2411.18279(原文长达近70页)<br>图形用户界面（GUI）一直是人机交互的核心，便于用户操控数字系统。然而，传统的GUI自动化多依赖脚本或规则，缺乏灵活性，难以满足复杂需求。<br>大型语言模型（LLM），尤其是多模态模型的兴起，革命性地推动了GUI自动化的发展。LLM在自然语言理解和任务执行方面展现出卓越能力，使“LLM驱动”的GUIAgent能够根据自然语言指令自主操作，标志着人机交互的新范式。<br>LLM驱动的GUIAgent在网络导航、移动应用和桌面自动化等领域具备巨大潜力，迅速发展。本文综述了LLM驱动的GUIAgent的发展历程、核心组件及技术，探讨现有框架和数据使用方法，并分析其在实际应用中的表现及未来机遇。<br>通过深入分析，本综述识别了关键研究空白，并为未来发展提供了路线图，旨在为研究者和从业者提供指导，推动该领域的进步。<br>智能体（Agent）能够接受用户的自然语言请求，并在多个应用程序中无缝协作。例如，它可以从Word中提取信息、总结网页、处理PDF文件，并在PowerPoint中创建幻灯片，最终通过Teams发送。<br>图形用户界面（GUI）极大地改变了用户与数字系统的交互方式，降低了使用门槛，提升了可用性。然而，GUI在重复性任务和多步骤操作中效率不足。相比之下，命令行界面（CLI）在某些场景下仍更高效。<br>尽管GUI改善了用户体验，但其多样性和动态性为自动化带来了挑战。传统的GUI自动化方法依赖于脚本或规则，缺乏适应性和扩展性，难以应对动态工作流。<br>大型语言模型（LLM）的兴起，尤其是其多模态能力，为GUI自动化带来了突破性进展。以ChatGPT为代表的LLM能够处理复杂的视觉数据，使智能体更自然地与GUI交互，推动了GUI自动化的新发展。<br>LLM驱动的GUIAgent标志着自动化的范式转变，使得自然语言理解、视觉识别与决策制定融为一体，显著提升了任务自动化的效率。这些智能体不仅简化了复杂操作，还为非技术用户提供了更友好的交互体验。<br>为了弥补这一空白，这篇综述首次对LLM驱动的GUIAgent进行了全面调查。该综述涵盖了GUIAgent的历史演进，提供了构建这些Agent的分步指南，总结了基本和高级技术，回顾了与框架、数据和模型相关的重要工具和研究，展示了代表性应用，并勾画出未来发展方向。具体来说，本调查旨在回答以下研究问题（ResearchQuestions，RQ）：<br>RQ1:LLM驱动GUIAgent的历史发展轨迹是什么？（第4节）<br>RQ2:构成LLM驱动GUIAgent基础的基本组件和先进技术是什么？（第5节）<br>RQ3:LLMGUIAgent的主要框架是什么，它们的定义特征是什么？（第6节）<br>RQ4:现有的数据集是什么，如何收集全面的数据集来训练GUIAgent的优化LLM？（第7节）<br>RQ5:如何利用收集到的数据训练GUIAgent专用的大规模行动模型（LAM），该领域当前领先的模型有哪些？（第8节）<br>RQ6:用于评估GUIAgent能力和性能的指标和基准是什么？（第9节）<br>RQ7:LLM驱动GUIAgent最重要的实际应用有哪些，它们是如何为实际使用而调整的？（第10节）<br>RQ8:开发出健壮、智能GUIAgent面临的主要挑战、局限性和未来研究方向是什么？（第11节）<br>原始论文综述的组织结构如下。<br>第3节提供了关于LLM、LLMAgent和GUI自动化的初步背景知识。<br>第4节追溯了LLM驱动GUIAgent的演进历程。<br>第5节介绍了LLM驱动GUIAgent中的关键组件和先进技术，可作为综合指南。<br>第6节介绍了LLM驱动GUIAgent的代表性框架。<br>第7节讨论了数据集收集，以及针对优化GUIAgent中LLM的相关以数据为中心的研究。<br>第8节涵盖了GUIAgent的基础和优化模型。<br>第9节概述了评估指标和基准测试。<br>第10节探讨了实际应用和使用案例。<br>第11节审视了当前的局限性、挑战和潜在的未来方向。<br>第12节是本综述的结论。<br>具体到公众号解读系列里面一共划分为9篇：<br>第1篇：作为引言及其概述，简要介绍综述的内容。<br>GUIAgent综述-1:总览<br>第2篇：介绍LLM、LLMAgent和GUI自动化的初步背景知识（对应原始综述第3章）。<br>GUIAgent综述-2:三大技术基石<br>第3篇：追溯LLM驱动GUIAgent的演进历程（对应原始综述第4章）。<br>GUIAgent综述-3:发展历程<br>第4篇：介绍LLM驱动GUIAgent中的关键组件和先进技术（对应原始综述第5章）。<br>GUIAgent综述-4:深度解读GUIAgent的核心组件及其最新进展<br>第5篇：介绍LLM驱动GUIAgent的代表性框架（对应原始综述第6章）。<br>GUIAgent综述-5:GUIAgent框架百家争鸣<br>第6篇：介绍现有的数据集及其如何收集全面的数据集来训练优化GUIAgent的LLM（对应原始综述第7章）。<br>GUIAgent综述-6:汇总GUIAgent训练数据集<br>第7篇：如何利用收集到的数据训练GUIAgent专用的大规模行动模型（LAM），及其该领域当前领先的模型（对应原始综述第8章）。<br>GUIAgent综述-7:GUIAgent模型优化<br>第8篇：概述GUIAgent评估指标和基准测试（对应原始综述第9章）。<br>GUIAgent综述:8-如何评测GUIAgent？有哪些评测基准？<br>第9篇：介绍GUIAgent实际应用和使用案例并审视了当前的局限性、挑战和潜在的未来方向（对应原始综述第10章和11章）。<br>GUIAgent综述:9-GUIAgent应用与未来<br>只对部分章节感兴趣的小伙伴可以留意目标章节的解读。<br>更多智能体(Agent)相关可以订阅此专题：智能体(Agent)专题<br>LLM驱动的GUIAgent的发展得益于三大领域的进展：<br>大型语言模型（LLMs）在自然语言理解和代码生成方面的强大能力，构成了此类Agent的核心智能基础；<br>扩展LLMs能力的相关Agent架构和工具，弥合了语言模型与物理环境之间的鸿沟，使其能够产生实际影响；<br>GUI自动化领域提供的一套成熟的工具、模型和方法论，为GUIAgent的功能奠定了坚实的基础。<br>这些组成部分共同推动了基于LLM的GUIAgent的诞生。以下各小节将对这些领域进行简要概述，为后续讨论奠定基础。<br>语言模型的研究历史悠久且成果丰硕，其起源可追溯到早期的统计语言模型和较小规模的神经网络架构。基于这些基础概念，近期的研究重点转向了基于Transformer结构的LLMs，例如生成式预训练Transformers（GPTs）。通过在大规模文本语料库上进行预训练，并显著扩大模型规模，这些模型验证了扩展规律（scalinglaws），并在广泛的自然语言任务上展现出卓越的性能。除了模型规模的增长，这些LLMs还表现出更强的语言理解与生成能力，以及一些小规模语言模型所不具备的涌现特性。<br>早期的神经语言模型主要基于循环神经网络（RNNs）和长短时记忆网络（LSTMs），但在性能和泛化能力上均存在局限。Transformer模型的引入，以其注意力机制为核心，成为一个革命性的里程碑，确立了此后几乎所有LLMs所采用的基础架构。这一进展催生了多种模型结构的变体，包括仅编码器模型（如BERT、RoBERTa、ALBERT）、仅解码器模型（如GPT-1、GPT-2）和编码器-解码器模型（如T5、BART）。2022年，基于GPT-3.5的ChatGPT发布，作为一款具有突破性的LLM，彻底改变了人们对语言模型能力的认知。此后，许多先进的LLM相继问世，包括GPT-4、LLaMA-3和Gemini，推动了该领域的快速发展。如今的LLMs用途广泛，其中许多模型不仅能够处理多模态数据，还可以执行从问答到代码生成等多种任务，已成为各种应用中不可或缺的工具。<br>LLMs的出现还带来了一些显著的高级特性，这些特性极大地扩展了其应用范围，使得以自然语言驱动的GUIAgent成为可能。这些进步包括：<br>Few-ShotLearning：也被称为“上下文学习”，LLMs能够在推理阶段通过少量示例学习新任务，而无需重新训练。这一能力对于GUIAgent在不同环境中实现跨场景泛化至关重要。</p>
<p>Long-TermReasoning：LLMs具备规划能力，可以通过将复杂任务拆解为可管理的步骤来解决问题，常用的技术如“链式思考”，即思维链（CoT）推理技术。这一能力对GUIAgent尤为重要，因为许多任务需要多步操作，并依赖可靠的规划框架。<br>代码生成与工具利用：LLMs在生成代码和使用各种工具（如API）方面表现出色。这些能力至关重要，因为代码和工具是GUIAgent与环境交互的核心工具集。<br>多模态理解：高级LLMs能够整合额外的数据模态（如图像）到其训练过程中，演变为多模态模型。这一能力对GUIAgent尤为重要，因为它们需要解析GUI截图以理解并操作图形界面。<br>这些进步奠定了基于LLM的GUIAgent的技术基础，使得以前难以实现的任务成为可能，并为进一步提升智能化、人机交互能力和跨领域应用提供了强大的支持。<br>传统的人工智能Agent通常专注于增强特定能力，如符号推理或在某些特定任务（如围棋或国际象棋）上达到顶尖水平。相比之下，大型语言模型(LLM)的出现彻底改变了人工智能Agent，为其提供了自然语言界面，赋予了类似人类的决策能力，并使其能够执行各种任务并在不同环境中产生实际影响。在LLMAgent中，如果LLM构成了GUIAgent的”大脑”，那么其附带的组件则扮演着”眼睛和手”的角色，使LLM能够感知环境的状态，并将其文本输出转化为可操作的步骤，从而产生实际影响。这些组件将LLM从被动的信息源转变为可以代表用户执行任务的交互式Agent，从而重新定义了LLM的角色，使其不仅是纯文本生成模型，还是能够驱动行为和实现特定目标的系统。<br>在GUIAgent的背景下，Agent通常通过屏幕截图和小部件树(widgettrees)来感知GUI状态，然后执行操作以模仿用户行为(例如鼠标点击、键盘输入、手机上的触摸手势)。由于任务可能是长期的，因此通常需要有效的规划和任务分解，这带来了独特的挑战。因此，由LLM驱动的GUIAgent通常具有多模态能力、强大的规划系统、分析历史交互的记忆机制以及与环境交互的专用工具包。第5节将详细讨论这些针对GUIAgent量身定制的设计。<br>自计算机图形用户界面(GUI)诞生之日起，GUI自动化就一直是研究和应用的重要领域。最初，GUI自动化的目标是提高软件测试效率，专注于模拟用户在图形应用程序中的操作，如点击、文本输入和导航，以验证功能。早期的GUI自动化工具旨在执行静态界面上重复的测试用例。这些方法简化了质量保证过程，确保了一致性并减少了人工测试时间。随着对数字解决方案需求的不断增加，GUI自动化已扩展到测试之外的其他应用领域，包括机器人流程自动化(RPA)和人机交互(HCI)。RPA利用GUI自动化在业务流程中复制人类操作，自动化例行任务以提高操作效率。同样，HCI研究也利用GUI自动化来模拟用户行为，实现可用性评估和交互研究。在这两种情况下，自动化都通过最小化重复性任务和提高系统适应性，极大地提高了生产力和用户体验。<br>传统的GUI自动化方法主要依赖于脚本编程和基于规则的框架。基于脚本的自动化利用Python、Java和JavaScript等语言在程序层面控制GUI元素。这些脚本在界面上模拟用户操作，通常使用Selenium等工具进行基于Web的自动化，或使用AutoIt和SikuliX等工具进行桌面应用程序的自动化。与此同时，基于规则的方法则根据预定义的启发式规则运行，使用规则根据位置、颜色和文本标签等属性检测并与特定GUI元素交互。虽然这些方法对于可预测的、静态工作流程非常有效，但它们难以适应现代GUI的可变性，在现代GUI中，动态内容、响应式布局和用户驱动的变化使得维护一成不变的、基于规则的自动化变得极具挑战性。<br>计算机视觉(CV)已成为解释GUI视觉方面的关键技术，使自动化工具能够识别和交互屏幕上的元素，即使布局和设计发生变化。CV技术允许GUI自动化系统通过分析屏幕截图并识别感兴趣区域来检测和分类屏幕元素，如按钮、图标和文本字段。光学字符识别(OCR)进一步增强了这一能力，从图像中提取文本内容，使自动化系统能够准确解释标签、错误消息和表单说明。物体检测模型增加了系统的鲁棒性，使自动化Agent能够定位GUI元素，即使视觉布局发生改变。通过结合CV，GUI自动化系统在动态环境中实现了更大的弹性和适应性。<br>尽管取得了进展，但传统的GUI自动化方法在应对当代界面的复杂性和可变性方面仍显不足。如今的应用程序通常具有动态、自适应的元素，仅凭刚性的脚本编程或基于规则的方法无法可靠地实现自动化。现代界面越来越需要情境意识，例如处理屏幕文本、理解用户意图和识别视觉线索。这些需求暴露了现有自动化框架的局限性，以及对更加灵活、能够实时适应和基于上下文做出响应的解决方案的迫切需求。<br>大型语言模型(LLM)为解决这些挑战提供了一个有前景的方案。凭借其理解自然语言、解释上下文和生成自适应脚本的能力，LLM可以实现更智能、更灵活的GUI自动化。它们处理复杂指令和从上下文中学习的能力，使其能够弥合静态的基于规则方法与当代GUI动态需求之间的差距。通过将LLM与GUIAgent相结合，这些系统获得了根据当前界面状态实时生成脚本的能力，从而获得传统方法无法实现的适应性和复杂性水平。LLM和GUIAgent的结合为高级的以用户为中心的自动化范式铺平了道路，能够灵活响应用户请求，并与复杂、不断演进的界面无缝交互。<br>古人云”冰冻三尺，非一日之寒”。LLM驱动的GUIAgent的发展也是一个循序渐进的过程，其根基深植于数十年的研究和技术积累。从最初的简易GUI测试脚本和基于规则的自动化框架起步，该领域通过融合机器学习技术取得了长足进步，进而催生了更智能、适应性更强的系统。LLM模型，尤其是多模态模型的引入，使得自然语言交互成为可能，从根本上革新了用户与软件应用程序的交互方式，从而彻底改变了GUI自动化领域。<br>如图3所示，在2023年LLM模型出现之前，GUIAgent的工作范围和能力均受到较大限制。自那时起，基于LLM的方法在网络、移动和桌面环境等不同平台上蓬勃发展，推动了该领域众多创新成果的诞生。这一趋势方兴未艾，持续推动着该领域的创新。本节将回溯GUIAgent的演进历程，重点介绍推动该领域发展至今的关键里程碑。<br>在GUI自动化的早期阶段，研究人员主要依赖基于随机、规则和脚本的策略。尽管这些方法奠定了基础，但在灵活性和可适应性方面存在明显的局限性。<br>基于随机的自动化在GUI中使用随机动作序列，不依赖于特定算法或结构化模型，例如MonkeyTest。这种方法被广泛应用于GUI测试，通过探索不可预测的输入序列来发现潜在问题。尽管能有效识别边缘情况和bug，但基于随机的方法由于存在大量冗余或无关试验，往往效率较低。<br>基于规则的自动化运用预定义的规则和逻辑来实现任务自动化。2001年，Memon等人提出了一种规划方法，通过一系列预定义的运算符将初始状态转换为目标状态，从而生成GUI测试用例。Hellmann等人在2011年证明了基于规则方法在探索性测试中的潜力，增强了错误检测能力。在RPA领域，诞生于2020年的SmartRPA使用基于规则的处理来自动化例行任务，展示了规则在简化结构化流程方面的实用性。<br>基于脚本的自动化依赖于详细的脚本来管理GUI交互。jRapture等工具使用Java二进制文件和JVM记录和重放Java-based的GUI序列，通过精确重现输入序列实现一致执行。类似地，DART（2003年）自动化了GUI测试的整个生命周期，从结构分析到测试用例生成和执行，提供了一个全面的回归测试框架。<br>在此期间，一系列软件工具被开发出来，用于GUI测试和业务流程自动化。MicrosoftPowerAutomate（2019年）提供了一个低代码&#x2F;无代码环境，用于在Microsoft应用程序中创建自动化工作流。Selenium（2004年）支持跨浏览器Web测试，而Appium（2012年）则实现了移动UI自动化。TestComplete（1999年）、KatalonStudio（2015年）和Ranorex（2007年）等商业工具允许用户创建具有跨平台能力的自动化测试。<br>尽管这些早期系统能够有效地自动化特定的预定义工作流程，但它们缺乏灵活性，需要手动编写脚本或基于规则的逻辑。然而，它们为GUI自动化奠定了基础，为后续更智能的系统构建提供了支撑。<br>机器学习的融入标志着GUIAgent向更具适应性和更强大方向转变的一个重要转折点。这一阶段的早期里程碑包括将机器学习、自然语言处理、计算机视觉和强化学习应用于GUI任务的进展。<br>RoScript（2020年）是一个开创性系统，引入了非侵入式机器人测试系统，将GUI自动化扩展到了多种平台。AppFlow（2018年）使用机器学习识别常见的屏幕和UI组件，从而实现了针对广泛应用类别的模块化测试。计算机视觉的进步也推动了GUI测试的重大进展，例如2010年提出的frameworks自动化了视觉交互任务。Humanoid（2019年）使用在Android系统中训练用户交互轨迹的深度神经网络模型，学习用户如何根据应用程序的GUI选择操作。然后，该模型被用于指导测试输入生成，从而提高了覆盖率，并在测试期间产生了更加贴近人类的交互模式。类似地，DeepGUI（2021年）应用深度学习技术过滤掉屏幕上无关的部分，从而增强了GUI测试中的黑盒测试有效性，只关注重要元素。这些方法展示了深度学习使GUI测试更加高效和直观的潜力，通过紧密契合实际用户行为来实现。<br>White等人（2019年）展示的利用计算机视觉检测Widget来准确识别UI元素，作为支持技术使GUI自动化能够以更智能和响应式的方式与复杂动态GUI进行交互。通过检测和分类界面组件，该方法增强了Agent与复杂动态GUI有效交互的能力。<br>自然语言处理功能为GUI自动化带来了新的维度。RUSS（2021年）和FLIN（2020年）等系统允许用户通过自然语言命令控制GUI，架起了人类语言与机器动作之间的桥梁。在数据集方面，部分学者（2020年）将自然语言指令映射到移动UI操作，为GUI控制开辟了更广泛的应用。然而，这些方法仅限于处理简单的自然语言命令，无法管理长期任务。<br>WorldofBits(WoB)（2017年）等环境的开发使得能够使用强化学习(RL)训练基于网络的Agent。工作流引导探索（2018年）提高了RL的效率和任务性能。DQT（2024年）将深度强化学习应用于AndroidGUI测试，同时保留小部件结构和语义，而AndroidEnv（2021年）则提供了Agent在Android上训练的真实模拟环境。WebShop（2022年）展示了大规模网络交互的潜力，凸显了RL驱动的GUI自动化日益增长的复杂性。<br>尽管这些基于机器学习的方法比早期的基于规则的系统更具适应性，但它们仍然难以推广到多样化的、未知的任务。它们依赖于预定义的工作流程，适应性有限，需要针对新环境进行重新训练或定制，而自然语言控制也仍然受限。<br>LLM模型的引入，尤其是像GPT-4o（2023年）这样的多模态模型，通过支持自然语言交互，从根本上改变了GUI自动化。与以前需要整合单独模块的方法不同，LLM提供了GUI自动化的端到端解决方案，在自然语言理解、视觉识别和推理等方面具有先进的能力。<br>LLM为GUIAgent带来了独特的优势，包括自然语言理解、多模态处理、规划和泛化能力。这些特性使LLM和GUIAgent成为强大的组合。尽管早期有一些尝试，但2023年是标志着LLM驱动的GUIAgent在网络、移动和桌面应用等各种平台上取得重大进展的关键一年。<br>最初，LLM在图形用户界面自动化领域的应用始于Web领域，早期研究建立了基准数据集和环境。WebAgent是一个关键里程碑，它与WebGUM一起，开创了使用LLM进行实际Web导航的先河。这些进展为后续发展铺平了道路，利用更专门的LLM来增强基于Web的交互。<br>LLM与移动设备的集成始于AutoDroid，它将LLM与特定领域知识相结合，用于智能手机自动化。其他贡献如MM-Navigator、AppAgent、Mobile-Agent和AutoGLM实现了对智能手机应用程序的精细控制。研究持续改进模型微调，以提高移动GUI自动化的准确性。<br>对于桌面应用程序，UFO是最早利用具有视觉功能的GPT-4在Windows环境中执行用户命令的系统之一。Cradle扩展了这些能力，适用于软件应用程序和游戏，而吴等人则实现了跨不同桌面应用程序的交互，包括Web浏览器、代码终端和多媒体工具。<br>在工业界，Claude3.5Sonnet模型推出了“电脑使用”功能，能够通过UI操作与桌面环境交互。这标志着业界对LLM驱动的GUIAgent价值的认可日益加深，相关利益方也越来越多地投资于这项技术。<br>毫无疑问，LLM为GUIAgent引入了新的范式，提升了以往无法企及的智能水平。随着该领域不断发展，可以预见，一波商业化浪潮即将到来，从而带来用户与GUI应用程序交互方式的变革。<br>LLM驱动的GUIAgent旨在处理用户以自然语言提出的指令或请求，通过屏幕截图或UI元素树理解GUI的当前状态，并执行模拟人机交互的动作，从而跨越各种软件界面。这些Agent利用LLM强大的自然语言理解、推理和生成能力，精准地理解用户意图、评估GUI上下文，并自主地在不同环境中与应用程序交互，完成复杂的多步骤任务。这种集成使其能够流畅地解释和响应用户请求，为GUI自动化赋予了适应性和智能。<br>作为一种特定类型的LLMAgent，当前的GUIAgent大多采用相似的基础框架，集成了规划、记忆、工具使用等核心组件，以及多Agent协作等高级增强功能。然而，为了确保在不同应用程序环境中的适应性，每个组件都必须针对GUIAgent的特定目标进行调整。<br>接下来的部分将深入概述每个组件，提供构建LLM驱动GUIAgent的实用指南和教程。此全面解析可作为指导，用于利用强大LLM创建高效且智能的GUI自动化系统。<br>图4展示了LLM驱动GUIAgent的架构，呈现了从用户输入到任务完成的操作序列。该架构包括多个集成组件，每个组件都为Agent理解和执行基于用户自然语言指令的任务做出贡献。Agent接收用户请求后，遵循系统化的工作流程，包括环境感知、提示工程、模型推理、动作执行和持续的记忆管理利用，直至任务完全完成。<br>总体而言，GUIAgent包括以下组件：<br>操作环境：环境定义了Agent的操作上下文，包括移动设备、网页浏览器和Windows等桌面操作系统平台。为了有意义地交互，Agent通过屏幕截图、部件树或其他方法捕获UI结构，感知环境的当前状态。它持续监控每个动作的影响反馈，并实时调整策略，以确保任务有效进行。<br>Prompt工程：在环境感知之后，Agent构建详细的prompt来指导LLM的推理。该prompt包含用户指令、处理后的视觉数据(如屏幕截图)、UI元素布局、属性和任何与任务相关的附加上下文。这种结构化输入最大幅度地提高了LLM生成与当前GUI状态相一致、内容感知的响应的能力。<br>模型推理：构建好的prompt被传递给LLM，即Agent的推理核心，LLM生成完成用户请求所需的一系列规划、动作和见解。该模型可以是通用的LLM，也可以是经过GUI特定数据微调的专门模型，从而更好地理解GUI交互、用户流程和任务需求。<br>动作执行：根据模型推理结果，Agent确定任务执行所需的特定动作(如鼠标点击、键盘输入、触屏手势或API调用)。Agent中的执行器将这些高级指令转化为可操作的命令，直接影响GUI，有效模拟人机交互，覆盖不同的应用程序和设备。<br>记忆：对于多步骤任务，Agent维护内部记忆，跟踪之前的动作、任务进度和环境状态。这种记忆确保了复杂工作流程的连贯性，因为Agent可以参考先前的步骤并相应地调整动作。还可能融入外部记忆模块，以实现持续学习、访问外部知识，并增强适应新环境或需求的能力。<br>通过反复遍历这些阶段并组装基础组件，LLM驱动的GUIAgent可以智能地操作，无缝地跨越各种软件界面，弥合基于语言的指令与具体动作之间的鸿沟。每个组件对于Agent的稳健性、响应性和处理动态环境中复杂任务的能力都至关重要。在下面的小节中，将详细介绍每个组件的设计和核心技术，为从头构建LLM驱动的GUIAgent提供全面指南。<br>由大型语言模型驱动的GUIAgent的操作环境包括移动、网络和桌面操作系统等各种平台，在这些平台上，这些Agent可以与图形界面进行交互。每个平台都有其独特的特点，这影响了GUIAgent在其中感知、解释和采取行动的方式。以下将详细介绍了每个平台的细微差别、Agent收集环境信息的方式以及它们在适应不同操作环境时面临的挑战。<br>GUIAgent可以与多种平台进行交互，包括移动设备、网络应用程序和Windows等计算机操作系统。每个平台为GUI自动化提供了独特的功能和限制，要求Agent相应地调整其感知和交互策略。<br>移动平台：移动设备在有限的屏幕空间内运行，高度依赖触摸交互，并提供不同的应用架构(如本地与混合应用)。移动平台通常使用辅助功能框架，如Android的辅助功能API和iOS的VoiceOver辅助功能检查器，来公开有关UI元素的结构化信息。然而，GUIAgent必须处理移动环境中的额外复杂性，如手势识别、应用导航以及特定于平台的限制(如安全和隐私权限)。<br>网络平台：网络应用程序提供了相对标准化的界面，通常可通过超文本标记语言(HTML)和文档对象模型(DOM)结构访问。GUIAgent可以利用HTML属性(如元素ID、类和标签)来识别交互组件。Web环境还提供动态内容、响应式布局和异步更新(如AJAX请求)，要求Agent持续评估DOM并适应不断变化的界面元素。<br>计算机平台：Windows等计算机操作系统平台提供了对GUI交互的完全控制。Agent可以使用系统级自动化API(如WindowsUIAutomation6)来获取全面的UI元素数据，包括类型、标签、位置和边框框。这些平台通常支持更广泛的交互类型，如鼠标、键盘和复杂的多窗口操作。这些使得GUIAgent能够执行复杂的工作流程。但是，这些系统还需要针对从简单UI到复杂多层软件套件等各种应用程序进行复杂的适应。<br>总之，跨越移动、网络和桌面环境的平台多样性使GUIAgent能够提供广泛的自动化能力，使其成为可通过统一框架实现适应性的通用解决方案。然而，每个平台在系统和应用程序层面都呈现出独特的特点和约束，需要采取量身定制的方法来实现有效集成。通过考虑这些特定于平台的特性，GUIAgent可以针对每种环境的独特需求进行优化，从而提高其在不同自动化场景中的适应性和可靠性。<br>准确感知环境的当前状态对于由大型语言模型驱动的GUIAgent至关重要，因为它直接影响其决策和行动规划过程。这种感知是通过收集结构化数据（如部件树）和非结构化数据（如屏幕截图）的组合来实现的，以捕获界面及其组件的完整表示。在表III中，概述了跨各种平台收集GUI环境数据的关键工具包：<br>并在下面详细讨论了它们的作用：<br>GUI截图：截图提供了应用程序的可视快照，捕获了给定时刻GUI的整个状态。它们为Agent提供了布局、设计和可视内容的参考，这在UI元素的结构细节有限或不可用时至关重要。诸如图标、图像和其他可能含有重要上下文的图形线索等视觉元素，可以直接从截图中分析。许多平台都有内置工具可以捕获屏幕截图(如Windows的SnippingTool、macOS的截图实用程序和Android的MediaProjectionAPI)，并且截图可以通过为关键UI组件添加额外的注释(如Set-of-Mark(SoM)高亮显示或边界框)来增强，以简化Agent决策。图6说明了VSCodeGUI的各种截图，包括一个干净的版本，以及带有SoM和边界框的版本，突出显示了可操作组件，帮助Agent专注于界面的最关键区域。<br>部件树(WidgetTrees)：部件树以分层视图呈现界面元素，提供有关布局和组件之间关系的结构化数据。在图7中展示了一个GUI及其部件树的示例。通过访问部件树，Agent可以识别元素类型、标签、角色和界面内部关系等属性，所有这些对于语境理解都至关重要。WindowsUIAutomation和macOS的AccessibilityAPI10等工具为桌面应用程序提供了结构化视图，而Android的AccessibilityAPI和HTMLDOM结构则为移动和网络平台提供了服务。这种分层数据对Agent绘制逻辑交互和根据UI结构做出明智选择至关重要。<br>UI元素属性：界面中的每个UI元素都包含诸如控件类型、标签文本、位置和边界框尺寸等特定属性，这有助于Agent定位适当的组件。这些属性对于Agent决定空间关系(如相邻元素)和功能用途(如区分按钮和文本字段)至关重要。例如，网络应用程序公开了DOM属性(id、class、name)和CSS样式等属性，提供了上下文和控制信息。这些属性有助于Agent精确定位要与之交互的元素，提高了其在不同UI环境中导航和操作的能力。图8说明了WindowsUIAutomationAPI提取的选定UI元素属性示例，这些属性支持GUIAgent的决策。<br>辅助计算机视觉方法：当结构化信息不完整或不可用时，计算机视觉技术可以提供额外的信息。例如，OCR允许Agent直接从屏幕截图中提取文本内容，方便阅读标签、错误消息和说明。此外，像SAM(SegmentAnythingModel)、DINO和OmniParser这类先进对象检测模型可以在不同布局中识别和分类UI组件，支持Agent在UI元素可能频繁变化的动态环境中运行。这些基于视觉的方法确保了GUIAgent的健壮性，使得Agent即使在标准UIAPI不足的情况下也能有效运行。在图9中说明了这种辅助信息的示例，并在5.7.1节进一步详细介绍这些先进的计算机视觉方法。<br>总而言之，这些元素共同创建了GUI环境当前状态的全面多模态表示，提供了结构化和可视化数据。通过将此信息纳入提示构建，Agent可以做出明智、符合上下文的决策，而不会遗漏关键的环境线索。<br>有效的反馈机制对于GUIAgent评估每个动作的成功与否并为后续步骤做出明智决策至关重要。反馈可以采取多种形式，具体取决于平台和交互类型。图10展示了从环境中获得的各种类型反馈的示例。<br>截图更新：通过比较执行动作前后的截图，Agent可以识别表明应用程序状态变化的视觉差异。截图分析可以显示界面的细微变化，如通知、视觉线索或确认消息的出现，而这些可能无法通过结构化数据捕获到。<br>UI结构更改：执行动作后，Agent可以检测到部件树结构的修改，如元素的出现或消失、元素属性的更新或层次结构的变化。这些变化表明交互成功(如打开下拉列表或点击按钮)，有助于Agent根据更新后的环境状态确定下一步操作。<br>函数返回值和异常：某些平台可以通过函数返回值或系统生成的异常直接提供操作结果反馈。例如，Web平台上的API响应或JavaScript返回值可以确认操作成功，而异常或错误代码则可以指示交互失败，引导Agent重试或选择替代方法。<br>环境提供的这些反馈对于GUIAgent评估之前行动的结果至关重要。这种实时信息使得Agent能够评估其干预措施的有效性，并确定是否坚持原定规划或转向替代战略。通过这种自我反思过程，Agent可以调整其决策，优化任务执行并提高在动态和多样的应用程序环境中的整体性能。<br>在由大语言模型驱动的GUIAgent的运作中，有效的提示构建是一个关键步骤，其中包含了Agent生成适当响应和成功执行任务所需的全部信息。在从环境收集相关数据后，Agent构建一个综合性提示，结合了大语言模型推理所需的各种必要组成部分。每个组成部分都有特定的用途，共同使得Agent能够有效执行用户的请求。图11展示了一个以大语言模型为”大脑”的GUIAgent的基本提示构建示例。提示的关键元素总结如下:<br>用户请求：这是用户提供的原始任务描述，概述了目标和预期结果。它是Agent行动的基础，对于确保大语言模型理解任务的上下文和范围至关重要。<br>Agent指令：该部分为Agent的操作提供指导，详细说明其角色、需遵循的规则和特定目标。指令阐明了Agent将接收哪些输入，以及大语言模型的预期输出，为推理过程建立了一个框架。<br>环境状态：Agent包括感知到的GUI截图和UI信息，如5.2.2节所介绍。这种多模态数据可能包括截图的不同版本(如干净版和加了SoM注释的版本)，以确保清晰度并降低UI控件被注释遮挡的风险。这种对环境的全面表述对于做出准确的决策至关重要。<br>操作文档：该组件概述了Agent可以采取的可用操作，详细说明了相关文档、函数名称、参数、返回值和任何其他必要的参数。提供此信息使大语言模型具备了为任务选择和生成适当操作所需的上下文。<br>演示范例：包含输入&#x2F;输出示例对对于激活大语言模型的情景学习能力至关重要。这些示例有助于模型理解并概括任务要求，从而提高其执行GUIAgent任务的表现。<br>补充信息：还可以包含有助于规划和推理的其他上下文。这可以包括从Agent记忆(如5.6节所述)检索的历史数据，以及通过检索增强生成(RAG)方法获得的外部知识源(如文档)。这些补充信息可以提供有价值的见解，进一步完善Agent的决策过程。<br>构建有效的提示是由大语言模型驱动的GUIAgent高效运行的基础。通过系统地纳入上述信息，Agent确保了大语言模型获得了执行任务所需的必要上下文和指导。<br>构建的提示被提交给大语言模型进行推理，在此过程中，大语言模型的任务是同时生成执行用户请求所需的规划和具体行动。这一推理过程至关重要，因为它决定了GUIAgent在动态环境中的有效性。它通常包括两个主要组成部分:规划和行动推理，以及生成补充输出。图12显示了大语言模型推理输出的示例。<br>成功执行GUI任务通常需要一系列连续的动作，要求Agent参与有效的规划。类似于人类认知过程，深思熟虑的规划对于组织任务、安排行动以及确保成功完成至关重要。LLM必须最初设想长期目标，同时专注于短期行动来推进实现该目标。<br>为了有效应对多步骤任务的复杂性，Agent应该将总体任务分解为可管理的子任务，并制定执行时间表。可以采用CoT推理等技术，使LLM能够制定结构化的计划来指导行动的执行。这个计划可以存储供将来推理步骤参考，从而增强Agent活动的组织性和集中性。<br>规划的细粒度可能因任务性质和Agent角色而有所不同。对于复杂任务，结合全局规划(确定广泛的子目标)和局部规划(为这些子目标定义详细步骤)的分层方法，可以显著提高Agent有效管理长期目标的能力。<br>行动推理是推理阶段的核心目标，因为它将规划转化为可执行的任务。推断出的行动通常表示为函数调用字符串，包括函数名称和相关参数。这些字符串可以直接转化为与环境的实际交互，如点击、键盘输入、手机手势或API调用。在5.5节对这些行动类型进行了详细讨论。<br>输入提示必须包括Agent可供选择的预定义行动集合。Agent可以从该集合中选择行动，或者如果允许，生成自定义代码或API调用以与环境交互。这种灵活性可以增强Agent适应未预期情况的能力;然而，它可能会带来可靠性问题，因为生成的代码可能容易出错。<br>除了规划和行动推理之外，LLM还可以生成补充输出来增强Agent的能力。这些输出可能包括阐明Agent决策的推理过程(例如CoT推理)、与用户互动的消息，或与其他Agent或系统的交流，或任务状态(例如继续或完成)。可以根据特定需求量身定制这些功能的设计，从而丰富GUIAgent的整体性能。<br>通过有效平衡规划和行为推理，同时结合补充输出，Agent可以以更高层次的组织性和适应性应对复杂任务。<br>经过推理过程后，GUIAgent执行从推断命令中得到的动作并在GUI环境中收集反馈是一个至关重要的后续步骤。虽然”GUIAgent”一词可能暗示了专注于用户界面操作，但通过结合各种工具箱，可以大大扩展Agent的行动空间，从而提高其通用性。总的来说，GUIAgent可用的行动可分为三大类:<br>用户界面操作<br>原生API调用<br>AI工具<br>每个类别都有独特的优势和挑战，使Agent能够更有效地应对各种任务。在表IV中总结了GUIAgent常用的各种行动，并按不同类型分类，下面将对每个类别进行详细阐释。<br>用户界面操作包括用户通常与软件应用程序GUI进行的基本交互。这些操作包括各种形式的输入，如鼠标动作(点击、拖拽、悬停)、键盘动作(按键、组合键)、触摸动作(点击、滑动)和手势(捏、旋转)。这些动作在不同平台和应用程序中的细节可能有所不同，需要针对每种环境采取量身定制的方法。<br>虽然用户界面操作构成了与GUI交互的基础，但由于这些任务的连续性质，它们相对较慢。每个操作都必须一步步执行，这可能会导致延迟增加，尤其是对于涉及大量交互的复杂工作流程。尽管存在这一缺点，但用户界面操作对于保持跨不同应用程序的广泛兼容性至关重要，因为它们利用了标准的用户界面元素和交互。<br>与用户界面操作不同，一些应用程序提供原生API，允许GUIAgent更高效地执行操作。这些API提供了对应用程序中特定功能的直接访问，使Agent能够通过单个命令执行复杂任务。例如，调用OutlookAPI允许Agent通过一个操作发送电子邮件，而使用UI操作则需要一系列步骤，如导航菜单和填写表单。<br>虽然原生API可以显著提高动作执行的速度和可靠性，但它们的可用性有限。并非所有应用程序或平台都向外部公开API，开发这些接口也需要大量的努力和专业知识。因此，尽管原生API为高效完成任务提供了强大手段，但它们可能无法像UI操作那样普遍应用于不同的应用程序。<br>将AI工具整合到GUIAgent中，使得GUIAgent的能力产生变革性进步。这些工具可以协助完成广泛的任务，包括从截图或文本中总结内容、增强文档、生成图像或视频(例如调用ChatGPT、DALL·E)、甚至唤起其他Agent或Copilot工具进行协作辅助。生成式人工智能技术的快速发展使得GUIAgent能够应对之前无法完成的复杂挑战。<br>通过整合AI工具，Agent可以扩展其功能，在不同环境中提升性能。例如，GUIAgent可以使用人工智能摘要工具快速从冗长文档中提取关键信息，或利用图像生成工具为用户演示文稿创建自定义视觉效果。这种整合不仅可以简化工作流程，而且还可以使Agent以远低于传统所需时间就能提供高质量的输出，从而赋予其更大能力。<br>先进的GUIAgent应熟练利用三大类操作：用户界面操作实现广泛兼容性、原生API实现高效执行、人工智能工具增强能力。这种多方面的方法使得Agent能够在各种应用程序中可靠运行，同时最大限度地提高效率和有效性。通过熟练地在这些操作类型间导航，GUIAgent可以更高效地满足用户需求，最终带来更加无缝和高效的用户体验。<br>为了在复杂的多步骤任务中实现健壮的性能，GUIAgent必须保留记忆，从而在本质上无状态的环境中管理状态。记忆使Agent能够跟踪先前的操作、结果和任务的整体状态，这对于在后续步骤中做出明智决策至关重要。通过建立连续性，记忆将Agent从反应式系统转变为具有主动性和有状态的系统，能够根据累积的知识自行调整。Agent的记忆通常分为两种主要类型:短期记忆和长期记忆。表V显示了GUIAgent中不同类型记忆的概览。<br>短期记忆(Short-TermMemory，STM)为大型语言模型在运行时提供了主要的、短暂的上下文。STM存储与当前任务相关的信息，例如最近的计划、操作、结果和环境状态，并持续更新以反映任务的进展状态。在多步骤任务中，每个决策都建立在前一个决策之上，需要Agent对任务轨迹有清晰的理解，因此这种记忆尤为宝贵。如图13所示，在独立任务执行期间，由操作和计划组成的任务轨迹存储在STM中。这使Agent能够高效地跟踪任务进度，从而做出更明智的决策。<br>然而，STM受限于大型语言模型的上下文窗口，限制了它可以携带的信息量。为了管理这一限制，Agent可以采用选择性记忆管理策略，例如有选择地丢弃或总结不太相关的细节，优先保留最有影响力的信息。尽管规模有限，但STM对于确保连贯、与上下文相关的交互以及支持Agent执行复杂工作流程并获得即时相关反馈至关重要。<br>长期记忆(Long-TermMemory，LTM)作为一个外部存储库，用于存放超出即时运行时的上下文信息。与短期记忆的暂时性特征不同，LTM可以保留历史任务数据，包括以前完成的任务、成功的操作序列、上下文提示和学习到的见解。LTM可以存储在磁盘或数据库中，使其能够比大型语言模型的即时上下文窗口容纳更大量的信息。在图13所示的示例中，当第二个任务要求下载与之前任务相关的游戏时，Agent会从其LTM中检索相关信息。这使Agent能够准确识别正确的游戏，从而高效完成任务。<br>LTM通过保存成功任务轨迹、操作指南和常见交互模式的示例，有助于Agent的自我改进。在应对新任务时，Agent可以使用检索增强生成(RAG)技术来检索相关的历史数据，从而增强其根据过往成功来适应策略的能力。这使LTM在培养Agent”学习”经验的能力方面发挥了重要作用，使其能够在累积经验后以更大的准确性和效率执行任务。例如，在Synapse计算机控制智能体系统中提供了一个说明性案例，展示如何使用存储在记忆中的过去任务轨迹来指导和增强未来决策，这是一种高度适用于GUIAgent的技术。它还通过保留以前任务的信息，实现了更好的个性化。<br>虽然大多数大型语言模型驱动的GUIAgent都包含了诸如感知、规划、行动执行和记忆等基本组件，但研究人员还发展了若干先进技术，以显著提高这些Agent的推理能力和整体能力。在这里，将概述在研究中广泛采用的共享进展，以指导开发更加专门化和功能强大的大型语言模型驱动的GUIAgent。<br>尽管各种工具使GUIAgent能够访问诸如窗口部件位置、标题和属性等信息，但某些非标准GUI或部件可能不遵循这些工具的协议，从而使其信息无法访问。此外，由于权限管理，这些工具并不总是可用的。这种信息不完整可能会给GUIAgent带来重大挑战，因为大型语言模型可能需要独立定位并与所需的部件交互，方法是估算其坐标以执行诸如单击等操作：这是一项在没有精确GUI数据的情况下本身就很困难的任务。<br>基于CV的模型提供了一种非侵入性的解决方案，可直接从屏幕截图解析GUI，实现对部件的检测、定位、分割，甚至功能估计。这种方法使Agent能够根据纯视觉线索解释GUI的视觉结构和元素，而无需依赖可能无法使用或不完整的系统级工具或内部元数据，从而增强了Agent识别并对屏幕上的元素采取行动的能力。图9提供了一个说明基于CV的GUI解析器如何工作的示例。虽然标准API检测捕获预定义的部件，但CV模型还可以识别缩略图和画布等其他元素，而这些元素在PowerPoint界面中可能没有显式的API表示。这增强了对部件的识别，使Agent能够检测超出API检测范围的组件。<br>一个值得注意的例子是OmniParser，它实现了一种多阶段解析技术，包括用于检测可交互图标的微调模型、用于提取文本的OCR模块以及生成每个UI元素的本地化语义描述的图标描述模型。通过集成这些组件，OmniParser构建了GUI的结构化表示，增强了Agent对交互区域和功能元素的理解。这种全面的解析策略已被证明可以显著提高GPT-4V对屏幕的理解和交互准确性。<br>此类基于CV的GUI解析层为Agent提供了关键的基础信息，极大地增强了其与不同GUI进行准确和直观交互的能力。这对于处理偏离典型辅助功能协议的自定义或非标准元素尤为有益。此外，诸如迭代缩小等提示方法已显示出提高VLM部件定位能力的前景。总的来说，这些方法为构建更具适应性和稳健性的GUIAgent铺平了道路，使其能够在更广泛的屏幕环境和应用程序上下文中高效运行。<br>俗话说“三个臭皮匠，顶个诸葛亮”，这句话在GUI自动化任务中尤为适用。单个agent虽然有能力完成任务，但在多agent框架下，其能力可以得到显著提升。多agent系统利用多个agent的集体智慧、专业技能和互补优势，更有效地解决复杂任务，这是单个agent无法单独做到的。在GUIAgent的背景下，多agent系统通过两种主要机制提供高级功能：专业化和agent间的协作。图14展示了一个由大型语言模型（LLM）驱动的多agent如何协作创建一个桌子的例子。<br>Agent专业化：在多agent框架中，每个agent都被设计为专注于特定的角色或功能，利用其独特的能力为整体任务做出贡献。如图14所示，专业化使不同的agent能够专注于任务流程的不同方面。例如，“文档提取器”专门从本地文档（如PDF）中提取相关内容，而“网络检索器”则专注于从在线资源中收集额外信息。类似地，“设计器(Designer)”将检索到的信息转换为具有视觉吸引力的幻灯片，而“评估器(Evaluator”)”则提供反馈以改进和完善输出。这种功能分离确保每个agent都高度擅长其指定的任务，从而提高效率和结果质量。<br>协作式Agent间动态：图14所示的多agent系统展示了agent如何动态协作来处理复杂任务。该过程从“文档提取器”和“网络检索器”开始，它们并行工作，从本地和在线资源收集信息。检索到的数据被传递给“设计器”，后者将其合成为一组连贯的幻灯片。幻灯片创建完成后，“评估器”会审查输出，并提供反馈以进行完善。这些agent共享信息、交换上下文并以协调的方式运行，反映了类似人类的团队合作动态。例如，如图所示，agent的角色紧密集成——每个输出都为下一阶段提供输入，从而创建一个简化的工作流程，该流程反映了现实世界的协作环境。<br>在这样的系统中，agent可以集体参与需要规划、讨论和决策的任务。通过这些互动，系统可以利用每个agent的领域专业知识和潜在的专业化能力，从而最大限度地提高跨越不同多步骤流程的整体性能。<br>俗话说，“知错能改，善莫大焉”。在GUI多agent系统的背景下，自我反思指的是agent在整个任务执行过程中内省地评估其推理、行动和决策的能力。这种能力使agent能够检测潜在的错误、调整策略和改进行动，从而提高其决策的质量和稳健性，尤其是在复杂或不熟悉的GUI环境中。通过定期评估自身的表现，具有自我反思能力的agent可以动态地进行调整，从而产生更准确和有效的结果。<br>自我反思对于GUIagent尤为重要，因为用户界面的可变性以及即使在人工操作的系统中也可能出现错误。GUIagent经常遇到偏离预期的情况，例如点击错误的按钮、遇到意外的广告、导航不熟悉的界面、收到来自API调用的错误消息，甚至是对任务结果的用户反馈做出响应。为了确保任务成功，GUIagent必须快速反思其行动，评估这些反馈信号，并调整其计划以更好地与期望的目标保持一致。<br>如图15所示，当agent最初未能找到“设计”菜单中的“线条绘制”选项时，自我反思使其能够重新考虑并在“图片格式”菜单下的“艺术效果”中找到其正确位置，从而成功完成任务。<br>在实践中，GUIagent的自我反思技术通常涉及两种主要方法：（i）ReAct和（ii）Reflexion。<br>ReAct（推理和行动）：ReAct通过让agent评估每个行动的结果并推理出下一个最佳步骤，将自我反思集成到agent的行动链中。在这个框架中，agent不仅仅是遵循线性的行动序列；相反，它会动态地适应，不断地根据每个行动的反馈重新评估其策略。例如，如果一个试图填写表单的GUIagent意识到它点击了错误的字段，它可以通过回溯并选择正确的元素来调整。通过ReAct，agent可以实现更高的连贯性和准确性，因为它学会了在完成的每个步骤中改进其行为。<br>Reflexion：Reflexion强调基于语言的反馈，其中agent接收并处理来自环境的反馈作为语言输入，称为自我反思反馈。此反馈被上下文关联，并用作后续交互的输入，帮助agent从先前的错误中快速学习。例如，如果GUIagent收到来自应用程序的错误消息，Reflexion使agent能够处理此消息，更新其对界面的理解，并避免在未来的交互中出现类似的错误。Reflexion的迭代反馈循环促进了持续改进，并且对于GUIagent导航复杂的多步骤任务尤其有价值。<br>总的来说，自我反思是GUI多agent系统中的一项重要增强功能，使agent能够更好地应对GUI环境的可变性和不可预测性。这种内省能力不仅提高了单个agent的性能，而且还促进了协作环境中的韧性、适应性和长期学习。<br>自我进化是GUIagent应该具备的关键属性，它使得agent能够通过积累的经验逐步提升性能。在GUI多agent系统中，自我进化不仅允许单个agent改进，还通过在agent之间共享知识和策略来促进集体学习和适应。在任务执行期间，GUIagent会生成详细的动作轨迹，并附带有环境状态、内部推理过程（agent的思考过程）和评估结果等补充信息。这些丰富的数据构成了宝贵的知识库，GUIagent可以从中学习和进化。从这些经验中提取的知识可以分为三个主要领域：<br>任务轨迹：agent执行的动作序列以及相应的环境状态，对于学习至关重要。这些成功的轨迹可以通过两种重要方式加以利用。首先，它们可以用于微调支撑agent的核心LLM。使用这种特定领域和任务相关的数据进行微调，可以增强模型泛化能力，并提高未来在类似任务上的性能。其次，这些轨迹可以用作演示示例，以激活LLM在提示工程中的上下文学习能力。通过在提示中包含成功任务执行的示例，agent可以更好地理解和复制期望的行为，而无需额外的模型训练。<br>例如，假设一个agent成功完成了一项复杂的任务，该任务涉及跨多个应用程序的自动化数据输入。记录下来的动作轨迹（包括采取的步骤、做出的决策和上下文线索）可以与其他agent共享。当这些agent面临类似任务时，可以使用此轨迹作为指导，从而缩短学习曲线并提高效率。<br>指导和规则：从积累的经验中，agent可以提取出高层次的规则或指导方针，这些规则或指导方针概括了最佳实践、成功的策略以及从过去的错误中吸取的教训。这些知识可以被形式化为策略或启发式方法，供agent在决策过程中参考，从而增强其推理能力。<br>例如，如果agent在尝试执行某些操作时，由于没有适当的先决条件而反复遇到错误（例如，在指定文件路径之前尝试保存文件），则它们可以制定一条规则，在执行操作之前检查这些先决条件。这种主动方法降低了出错的可能性，并提高了任务成功率。<br>新工具包：在整个交互过程中，GUIagent可能会发现或开发出更有效的方法、工具或动作序列，从而简化任务执行。这些可能包括优化的API调用、宏或UI操作的组合，这些组合比以前的方法更有效地完成任务。通过将这些新工具纳入其技能库，agent可以扩展其能力并提高整体效率。<br>例如，一个agent可能会发现，使用批量处理API可以比在循环中执行单个UI操作更有效地自动化重复性任务。这种新方法可以在多agent系统中的agent之间共享，从而使所有agent都能从改进的方法中受益，并将其应用于相关任务。<br>图16说明了GUIagent如何通过完成任务进行进化。在其操作过程中，agent会向其技能集中添加新功能，例如图像摘要工具包，从阅读一篇关于创建GUIagent的论文中获得见解，并将网页提取等任务轨迹存储在其经验池中。当分配新任务时，例如“从GitHub存储库学习制作GUIagent”，agent会利用其获得的技能和过去的经验来适应并有效地执行任务。<br>这种动态进化突出了agent不断学习、成长和完善其能力的能力。通过利用过去的经验、融入新的知识并扩展其工具集，GUIagent可以适应各种挑战，改进任务执行，并显著提高系统的整体性能，从而培养一个协作且不断改进的环境。<br>强化学习(RL)在使LLM与期望的行为保持一致方面取得了显著进展，并且最近已被用于LLMagent的开发。在GUI多agent系统中，RL为增强GUIagent的性能、适应性和协作提供了巨大的潜力。GUI自动化任务自然地与马尔可夫决策过程(MDP)的结构相一致，这使得它们特别适合基于RL的解决方案。在这种情况下，状态对应于环境感知（例如GUI屏幕截图、UI元素属性和布局配置），而动作直接映射到UI操作，包括鼠标点击、键盘输入和API调用。可以根据各种性能指标（例如任务完成、效率和准确性）明确定义奖励，从而使agent能够优化其动作以获得最大效果。图17说明了GUIagent中用于任务完成的MDP建模示例，其中明确定义了状态、动作和奖励。<br>通过将GUIagent交互形式化为MDP，可以利用RL技术来训练agent，使其通过试错学习任务执行的最佳策略。这种方法使agent能够做出最大化随时间累积奖励的决策，从而实现更高效和有效的任务完成。例如，一个学习自动化Web应用程序中表单填写的agent可以使用RL来发现输入数据并成功提交表单的最有效动作序列，从而最大限度地减少错误和冗余步骤。此过程有助于使agent在GUI自动化任务中更紧密地与期望的行为保持一致，尤其是在预定义的动作序列不足的复杂或模糊情况下。<br>DigiRL是一种典型的方法，这是一个两阶段RL框架，用于在动态环境中训练GUIagent。DigiRL首先使用离线数据初始化agent模型的离线RL阶段，然后进行在线微调，其中模型直接与环境交互，通过使用LLM评估器提供可靠奖励信号的Android学习环境中的实时数据来改进其策略。这种自适应设置使agent能够学习并有效地响应动态GUI的复杂性。Wang等人提出了DistRL，这是一个专门为在Android中运行的设备上移动控制agent设计的RL微调管道。DistRL采用异步架构，在异构工作设备和环境中部署RL微调agent，以进行分散式数据收集。通过利用离策略RL技术，DistRL可以利用从不同环境远程收集的数据进行集中训练，从而显著增强模型的可扩展性和鲁棒性。这些代表性的方法说明了RL在改进GUIagent方面的潜力，展示了集中式和分布式RL框架如何使现实世界应用中更具响应性、适应性和有效性的GUI自动化模型成为可能。<br>总而言之，这些先进技术显著提升了LLM驱动的GUIagent的能力，使其在多agent框架内更加通用、高效和具有适应性。重要的是，这些技术并非相互排斥——许多技术可以整合在一起，创造出更强大的agent。例如，在多agent框架中加入自我反思机制，可以让agent协同改进任务策略并从错误中恢复。通过利用这些进步，开发者可以设计出不仅擅长自动化复杂、多步骤任务，而且能够通过自我进化、适应动态环境以及有效的agent间协作来持续改进的LLM驱动的GUIagent。未来研究有望产生更复杂的技术，进一步扩展GUI自动化的范围和稳健性。<br>构建稳健、适应性强且高效的LLM驱动的GUIagent是一个多方面的过程，需要仔细整合几个核心组件。在第5节概述的架构、设计、环境交互和记忆方面打下坚实的基础后，后续章节将重点转向在实际场景中部署这些agent所需的关键要素。首先在第6节全面回顾最先进的LLM驱动的GUIagent框架，突出它们在该领域的进步和独特贡献。在此基础上，深入研究为GUIagent优化LLM的方法，从第7章节的数据收集和处理策略开始，逐步深入到第8节的模型优化技术。为了确保稳健的开发和验证，在第9章研究评估方法和基准，这对于评估agent的性能和可靠性至关重要。最后，在第10章节探讨各种实际应用，展示这些agent在各个领域产生的变革性影响。<br>总而言之，这些章节为推动LLM驱动的GUIagent从基础概念到实际应用和创新提供了一个全面的路线图(Roadmap)。这个路线图，从基础组件到实际部署，概括了将LLM驱动的GUIagent概念从构思到实现所需的必要流程。<br>为了提供全面的视角，首先在图18中介绍一个分类法，该分类法将最近关于LLM驱动的GUIagent的工作按框架、数据、模型、评估和应用进行分类。这个分类法可以作为指导浏览每个领域广泛研究和开发工作的蓝图，同时也坦承类别之间的重叠，其中某些模型、框架或数据集对GUIagent功能的多个方面都有贡献。<br>更多智能体(Agent)相关可以订阅此专题：智能体(Agent)专题<br>LLM的集成开启了构建GUIagent的新可能性，使其能够解释用户请求、分析GUI组件，并在各种环境中自主执行操作。通过为这些模型配备第5节概述的基本组件和功能，研究人员已经创建了针对各种平台和应用的复杂框架。这些框架代表了一个快速发展的研究领域，每个框架都引入了创新技术和专业功能，推动了GUIagent所能达到的边界。<br>为了全面了解该领域，首先在表6、7、8和9中总结了Web、移动、计算机和跨平台的关键框架，重点介绍了它们的功能、目标平台和显著的创新。这些总结是理解LLM驱动的GUIagent开发广度的切入点。在概述之后，将详细讨论每个框架，研究它们的基本设计原则、技术进步以及它们在GUI自动化领域解决的具体挑战。通过深入研究这些方面，旨在更深入地了解这些agent如何塑造人机交互和任务自动化的未来，以及它们在该变革性领域发展中发挥的关键作用。<br>WebGUIagent的进步在自动化各种动态Web环境中的复杂任务方面取得了显著进展。最近的框架引入了创新方法，利用多模态输入、预测建模和特定任务优化来提高性能、适应性和效率。在本小节中将深入研究这些框架，突出它们的独特贡献以及它们如何共同推动基于Web的GUI自动化边界。<br>一个显著的趋势是集成多模态功能，以改善与动态Web内容的交互。例如，SeeAct利用GPT-4V的多模态能力，有效地将操作建立在实时网站上。通过利用视觉数据和HTML结构，SeeAct集成了使用图像注释、HTML属性和文本选择的接地技术，优化了与实时Web内容的交互。这种方法使SeeAct在实时Web任务中实现了51.1%的任务成功率，突显了动态评估在开发稳健Webagent中的重要性。<br>WebVoyager凭借多模态输入的优势，通过支持真实网络环境中的端到端任务完成，推动了自主网络导航的发展。它利用GPT-4V处理视觉（屏幕截图）和文本（HTML元素）输入，有效地与动态Web界面交互，包括那些具有动态渲染内容和复杂交互元素的界面。这种多模态能力使得WebVoyager能够管理复杂的界面，其成功率显著高于传统的纯文本方法，为基于Web的任务自动化设定了新的基准。<br>除了多模态集成，一些框架专注于解析复杂的Web结构并生成可执行代码来导航复杂的网站。WebAgent采用了一种双层模型方法，结合了用于解析长而复杂的HTML文档的HTML-T5和用于程序合成的Flan-U-PaLM。这种模块化设计使WebAgent能够将用户指令转换为可执行的Python代码，通过特定于任务的子指令自主处理复杂的真实网站。与传统的单Agent模型相比，WebAgent在真实网站上的成功率提高了50%，这展示了将HTML特定解析与代码生成相结合，应用于多样化和动态Web环境的优势。<br>为了增强网络导航中的决策能力，一些框架引入了状态空间探索和搜索算法。LASER将网络导航建模为状态空间探索，允许灵活的回溯和高效的决策，而无需大量的上下文示例。通过将动作与特定状态相关联，并利用GPT-4的函数调用功能进行基于状态的动作选择，LASER最大限度地减少了错误并提高了任务成功率，尤其是在WebShop和亚马逊等电子商务导航任务中。这种基于状态的方法提供了一种可扩展且高效的解决方案，提高了LLMagent在GUI导航中的效率。<br>类似地，Search-Agent创新性地引入了最佳优先搜索算法，以增强交互式Web环境中的多步推理。通过探索多个动作路径，这种方法提高了决策能力，在WebArena等基准测试中成功率提高了高达39%。Search-Agent与现有多模态LLM的兼容性证明了基于搜索的算法对于复杂、交互式Web任务的有效性。<br>在基于搜索的策略基础上，WebPilot采用了一种结合全局和局部蒙特卡洛树搜索(MCTS)的双重优化策略，以提高在复杂和动态环境中的适应性。如图19所示，WebPilot将总体任务分解为可管理的子任务，每个子任务都进行局部优化。这种方法使WebPilot能够根据实时观察不断调整其策略，模拟类似人类的决策和灵活性。在WebArena和MiniWoB++等基准测试上的广泛测试表明，WebPilot具有最先进的性能，与现有方法相比，展现出卓越的适应性。<br>为了进一步推进预测建模的概念，WMA引入了一个世界模型来模拟和预测UI交互的结果。通过关注基于转换的观察，WMA允许agent在执行操作之前模拟操作结果，从而减少不必要的操作并提高任务效率。这种预测能力在需要高精度的长时程任务中尤其有效，WMA在WebArena和Mind2Web等基准测试中表现出强大的性能。<br>与此类似，WebDreamer创新性地利用LLM进行Web导航中的基于模型的规划，如图20所示。WebDreamer在执行之前使用LLM模拟和评估潜在的动作及其多步结果，类似于一个“梦想家”设想各种场景。通过预先评估不同计划的潜在价值，WebDreamer选择并执行预期价值最高的计划。这种方法解决了Web自动化中的关键挑战，例如安全问题以及在复杂和动态环境中进行稳健决策的需求，在VisualWebArena和Mind2Web-live等基准测试中表现出优于反应式agent的性能。<br>除了预测建模之外，将API交互集成到Web导航中可以提供更高的灵活性和效率。HybridAgent结合了Web浏览和API交互，根据任务需求动态切换方法。通过利用API调用进行结构化数据交互，HybridAgent减少了传统Web导航所涉及的时间和复杂性，在任务执行中实现了更高的准确性和效率。这种混合架构强调了在AIagent系统中集成结构化API数据和类似人类的浏览能力的优势。<br>为了解决复杂Web结构和跨域交互的挑战，AutoWebGLM提供了一种高效的解决方案，通过简化HTML来关注关键网页组件，从而提高任务准确性。通过使用强化学习和拒绝采样进行微调，AutoWebGLM在英语和中文网站上的复杂导航任务中表现出色。其双语数据集和结构化的动作感知模块使其适用于跨域Web交互，强调了在多样化Web任务中高效处理的重要性。<br>总而言之，最近的WebGUIagent框架通过集成多模态输入、预测模型和高级任务特定优化取得了实质性进展。这些创新为现实世界的任务提供了强大的解决方案，增强了基于Web的GUIagent的能力，并在开发智能、自适应的Web自动化方面迈出了重要一步。<br>移动GUIAgent的发展经历了显著的技术进步，通过多模态模型、复杂架构和自适应规划，成功应对了移动环境中的独特挑战。这些Agent从最初的基础交互功能，发展到能够在各种移动应用中执行动态、上下文感知操作的复杂系统。<br>早期的研究重点在于实现类人化的GUI交互，而无需访问后台系统。其中一个开创性的框架是AppAgent，它利用了GPT-4V的多模态能力，能够理解并响应视觉和文本信息。通过实时截图和结构化XML数据，AppAgent可以直接与GUI进行交互，例如执行点击和滑动操作，适用于从社交媒体到复杂图像编辑的多种应用。AppAgent通过自主探索和观察人类演示来学习新应用的使用方式，这种独特的学习方法展现了多模态能力在移动Agent中的高效性和适应性。<br>在此基础上，AppAgent-V2对框架进行了进一步改进，增强了视觉识别能力，并引入了结构化数据解析。这使其能够进行更精确的上下文感知交互，并在不同应用中执行复杂的多步操作。此外，AppAgent-V2还引入了安全检查机制以处理敏感数据，并通过实时跟踪和适应交互来支持跨应用任务。该框架的进化突显了高级视觉识别和结构化数据处理在提升任务精度和安全性方面的重要性，尤其是在实时移动环境中。<br>与此同时，以视觉为核心的方法也逐步兴起，进一步提升了移动任务自动化能力，而无需依赖特定应用的数据。例如，Mobile-Agent利用OCR、CLIP和GroundingDINO等视觉感知工具，通过截图和视觉工具进行操作。Mobile-Agent能够按照指令执行从应用导航到复杂多任务的操作，并通过自我反思机制调整错误。这种基于视觉的方法使Mobile-Agent成为了一个灵活且适应性强的移动任务助手。<br>为了解决长序列导航和复杂多应用场景中的挑战，Mobile-Agent-v2引入了一种多Agent架构，将规划、决策和反思任务分离。通过三个Agent分工协作，该框架优化了任务进度跟踪，保留了与任务相关的信息，并在错误发生时进行纠正。结合诸如GroundingDINO和Qwen-VL-Int4等先进的视觉感知工具，Mobile-Agent-v2在Android和HarmonyOS上的任务完成率显著提升，展示了多Agent系统在处理复杂移动任务中的潜力。<br>除了以视觉为核心的方法外，一些框架还尝试将GUI状态转换为自然语言，从而实现基于LLM的动作规划。VisionTasker通过处理移动UI截图，将视觉UI解析与顺序化LLM任务规划相结合，生成结构化的自然语言描述。借助YOLO-v8和PaddleOCR28进行组件检测，VisionTasker能够在陌生应用中自动化处理复杂任务，其在某些任务上的准确率甚至超过人类操作员。这种两阶段设计展示了一种灵活适应的框架，为移动自动化树立了强有力的标杆。<br>类似地，DroidBot-GPT提出了一种创新方法，通过将GUI状态转换为自然语言提示，使LLM能够自主决策动作序列。通过解析GUI结构并将其转化为GPT模型可理解的语言，DroidBot-GPT无需对应用进行特定调整，即可在多种应用间实现通用性。这种适应能力凸显了LLM在处理复杂多步任务时的变革性作用，同时减少了对定制化数据的依赖。<br>为了提升动作预测和上下文感知能力，一些先进框架将感知与动作系统集成到多模态LLM中。例如，CoCo-Agent通过其综合事件感知模块和综合动作规划模块，处理GUI元素（如图标和布局）。通过将操作分解为可管理的步骤，并利用如AndroidintheWild(AITW)和META-GUI等基准数据中的高质量数据，CoCo-Agent展现了在各种智能手机应用中可靠自动化移动任务的能力。<br>进一步推进这种集成，CoAT引入了“链式动作思考”过程，以增强动作预测和上下文感知能力。CoAT利用先进模型（如GPT-4V）和标签化标记技术解决了传统基于坐标的动作识别限制。通过构建Android-In-The-Zoo(AITZ)数据集，CoAT提供了深度的上下文感知能力，显著提高了动作预测的准确性和任务完成率。这种方法在提升Android平台的可访问性和用户便利性方面展现了巨大潜力。<br>为了解决多步任务处理中的高计算成本问题，AutoDroid结合了基于LLM的理解能力与应用特定知识。通过采用HTML风格的GUI表示和基于记忆的架构，AutoDroid减少了对大量LLM查询的依赖。其混合架构结合了云端模型和本地模型，从而提升了响应速度和可访问性，使AutoDroid成为处理各种移动任务的实用解决方案。<br>MobileGPT则通过模拟人类的任务分解认知过程（探索、选择、推导和回忆）来自动化Android设备上的任务。这种方法极大地提高了任务执行的效率和准确性。MobileGPT的分层记忆结构支持模块化、可重用和可适应的任务及子任务，适用于多种上下文。在任务成功率、成本效率和适应性方面，MobileGPT表现优于现有最先进系统，展现了其推进移动任务自动化的潜力。<br>小结一下，移动GUIAgent取得了显著的发展，从单一Agent系统演进为能够进行动态、上下文感知操作的复杂多Agent框架。这些创新展示了复杂架构、多模态处理以及高级规划策略在应对移动环境多样化挑战中的重要性，同时标志着移动自动化能力的巨大进步。<br>计算机GUIAgent已发展出在不同操作系统中提供复杂自动化功能的能力，能够解决跨应用交互、任务泛化以及高级任务规划等挑战。<br>近年来，计算机GUIAgent的进步催生了能够在桌面环境中处理复杂任务的高级框架。这些Agent从简单的自动化工具演变为智能系统，利用多模态输入、先进架构和自适应学习技术，以高效且灵活的方式完成多应用任务。<br>在这一领域的一个重要进展是多Agent架构的引入，这种架构提升了任务管理和执行的能力。例如，专为Windows操作系统设计的UI-FocusedAgent(UFO)就是一个开创性的框架。UFO通过其先进的双Agent架构重新定义了以UI为中心的自动化，它利用GPT-Vision解释GUI元素，并能够在多个应用之间自主执行操作。该框架包含两个核心组件：HostAgent和AppAgent。HostAgent负责全局规划、任务分解以及应用选择，而AppAgent则负责在单一应用内执行分配的子任务，如图21所示。这种集中式结构使UFO能够管理复杂的多应用工作流，例如信息聚合和报告生成。类似的架构也被其他GUIAgent框架采用。通过整合安全机制和可定制的操作，UFO在处理复杂指令时保证了效率和安全性，成为Windows操作系统上一款前沿的助手。其架构展现了动态适应性和强大的任务解决能力，在多种应用场景中体现了多Agent系统在桌面自动化中的潜力。<br>在适应性和通用能力的主题基础上，Cradle将通用计算机控制的边界进一步拓展。Cradle利用VLM（视觉语言模型）与各种软件交互，从游戏到专业应用，无需依赖API接口即可完成任务。Cradle使用GPT-4o解释屏幕输入并执行底层操作，使其在不同类型的软件环境中表现出极大的灵活性。其六模块结构涵盖信息收集、自我反思等功能，使Agent能够执行任务、推理行动，并通过过去的交互经验指导未来决策。Cradle能够在动态环境（包括复杂软件）中运行，标志着通用型Agent的重要进步，其广泛适用性在桌面环境中具有重大意义。<br>为了将计算机GUIAgent的能力扩展到多个操作系统，OS-Copilot提出了一个通用框架，可在Linux和macOS系统中运行。其突出功能FRIDAY展示了自我驱动学习的潜力，能够适应多种应用并在无需针对每个应用进行专门训练的情况下完成任务。与特定应用的Agent不同，FRIDAY集成了API、键盘鼠标控制和命令行操作，构建了一个灵活的平台，可以在与新应用交互时自主生成和优化工具。OS-Copilot在GAIA基准测试中的表现验证了其在未见过的应用中进行任务泛化的能力，为能在复杂环境中不断演进的操作系统级Agent提供了基础模型。这为创建能够处理多样化桌面环境和复杂任务需求的自适应数字助手指明了方向。<br>总之，计算机GUIAgent已实现了显著的发展，从单任务自动化工具成长为能够执行复杂多应用任务并从交互中学习的高级多Agent系统。像UFO、Cradle和OS-Copilot这样的框架展现了适应性和通用型Agent在桌面自动化中的潜力，为更智能、更多功能的AgentOS框架的演进铺平了道路。<br>跨平台GUIagent已经成为能够适应多种环境的多功能解决方案，从桌面和移动平台到更复杂的系统，这些框架注重适应性和高效性，通过轻量级模型和multi-agent架构的结合，提升跨平台操作能力。本小节探讨了一些体现跨平台GUI自动化最新进展的关键框架。<br>在该领域，一个重要的进步是AutoGLM，它通过集成大型多模态模型，实现了跨平台的无缝GUI交互，在网页浏览和Android控制之间架起桥梁。AutoGLM引入了一种“中间接口设计”（IntermediateInterfaceDesign），将规划（planning）与落地（grounding）任务分离，从而提升动态决策能力与适应性。通过强化学习的在线自我进化式课程设计，AutoGLM能够从真实世界的反馈中逐步学习，并具备错误恢复能力。这种适应性和鲁棒性使得AutoGLM成为多样化用户应用中理想的解决方案，为跨平台自动化设立了新标准，同时也为基础型agent的未来研究指明了方向。<br>部分框架专注于集成先进模型以实现跨平台交互，而另一些则强调效率和可访问性。例如，TinyClick针对单轮次GUI交互需求，提供了一种轻量化解决方案。它基于Florence-2-Base视觉-语言模型，通过用户指令和屏幕截图完成任务，仅需0.27亿参数。尽管模型规模较小，但TinyClick依然取得了出色的准确率——在Screenspot数据集上达到了73%，在OmniAct数据集上达到了58.3%，甚至超越了更大的多模态模型（如GPT-4V），同时保持了高效率。其多任务训练和基于多模态大模型（MLLM）的数据增强技术，能够精确定位UI元素，适用于低资源环境，并有效解决UI定位和动作执行中的延迟及资源限制问题。<br>除了轻量化模型，multi-agent架构在提升跨平台GUI交互方面也发挥了关键作用。OSCAR是这一领域的典范，它引入了一种通用型GUIagent，能够自主导航和控制桌面及移动应用。OSCAR采用状态机架构，根据实时反馈动态处理错误并调整操作，使其适用于自然语言引导的复杂工作流自动化。通过整合标准化的操作系统控制（如键盘和鼠标输入），OSCAR能够以通用方式与应用程序交互，从而提升在各种GUI环境中的生产力。其开源设计促进了广泛的应用与无缝集成，为跨平台任务自动化和效率提升提供了灵活的工具。<br>在multi-agent系统的概念上，AgentStore提供了一个灵活且可扩展的框架，用于集成多种异构agent，实现跨操作系统的任务自动化。AgentStore的核心特性是MetaAgent，它通过创新的AgentToken策略动态管理不断扩展的专业化agent集群。通过支持动态的agent注册，AgentStore具有极高的适应性和可扩展性，能够让专业化和通用化的能力共存。该multi-agent架构支持桌面和移动平台等多种环境，并利用多模态感知（如GUI结构和系统状态）增强交互能力。AgentStore的贡献表明，将专业化与通用化能力结合起来，是突破以往系统局限性的关键。<br>进一步推动跨平台GUI交互发展的是MMAC-Copilot，它采用multi-agent和多模态方法，无需依赖API即可处理3D游戏、办公和移动应用中的任务。通过使用Planner、Viewer和Programmer等专业化agent，MMAC-Copilot能够协作应对视觉复杂环境中的挑战。借助GPT-4V进行视觉识别，以及OCR用于文本分析，MMAC-Copilot在视觉复杂环境中实现了高任务完成率。其与VIBench（一个针对非API应用的基准测试工具）的集成，进一步凸显了其在真实场景中的适用性和适应能力。MMAC-Copilot为跨平台动态交互奠定了坚实基础，其应用领域扩展到游戏、医疗和生产力等行业。<br>AGUVIS利用纯视觉方法实现了GUI自动化，克服了基于文本系统（如HTML或辅助功能树）的局限性。其平台无关的设计支持网页、桌面和移动应用，同时有效降低了推理成本。AGUVIS采用两阶段训练过程：第一阶段专注于GUI定位（grounding），第二阶段将规划（planning）与推理（reasoning）整合到一个统一的模型中。该方法在离线和在线场景下均表现出色，显著简化了决策和执行的过程。<br>总之，跨平台GUIagent体现了未来自动化的多样化发展趋势，从轻量化模型（如TinyClick）到复杂的multi-agent系统（如MMAC-Copilot），各框架均带来了独特的创新。这些进步共同构建了一个丰富多样的GUI自动化工具生态系统，显著提升了在不同平台间的交互能力，标志着跨平台GUI自动化领域的重大突破。<br>GUIagent框架领域取得了显著进展，尤其是在多agent架构、多模态输入和增强的动作集方面。这些发展为更通用、更强大的agent奠定了基础，使其能够处理复杂、动态的环境。近期进展的关键要点包括：<br>多Agent协同：多agent系统，例如UFO和MMAC-Copilot中的系统，代表了GUIagent开发的一个重要趋势。通过在框架内为不同的agent分配专门的角色，多agent系统可以提高任务效率、适应性和整体性能。随着agent在不同平台上承担更复杂的任务，多个agent的协同使用被证明是一种强大的方法，使agent能够以更高的精度和速度处理复杂的流程。<br>多模态输入优势：虽然一些agent仍然只依赖基于文本的输入（例如，DOM结构或HTML），但结合视觉输入（如屏幕截图）已显示出明显的性能优势。像WebVoyager和SeeAct这样的agent突显了视觉数据与文本输入相结合如何提供更丰富的环境状态表示，帮助agent做出更明智的决策。这种多模态输入的集成对于在视觉复杂或动态环境中进行准确解释至关重要，在这些环境中，仅靠文本可能无法捕捉到所有必要的上下文。<br>将动作集扩展到UI操作之外：最近的agent已将其动作集扩展到标准UI操作之外，包括API调用和AI驱动的动作，如HybridAgent和AutoWebGLM中所示。整合多样化的动作使agent能够实现更高水平的交互和任务完成，特别是在可以通过API调用直接检索或操作数据的环境中。这种灵活性增强了agent的能力，使其在更广泛的应用中更高效、更具适应性。<br>改进决策的新兴技术：诸如WMA中的世界模型和Search-Agent中的基于搜索的策略等新方法，代表了更高级决策的有希望的方向。世界模型允许agent模拟动作结果，减少不必要的交互并提高效率，尤其是在长时程任务中。类似地，像最佳优先和MCTS这样的基于搜索的算法可以帮助agent更有效地探索动作路径，增强其在复杂、实时环境中的适应性。<br>迈向跨平台泛化：诸如AutoGLM和OSCAR等跨平台框架，突显了GUIagent设计中泛化性的价值。这些agent正在率先努力创建可以在移动、桌面和Web平台上无缝工作的解决方案，从而更接近于实现可以在多个生态系统中运行的一站式GUIagent的目标。跨平台灵活性对于旨在帮助用户在其数字交互中保持一致的agent至关重要。<br>纯视觉Agent：为了实现通用的GUI控制，纯视觉框架已成为一种突出的解决方案。这些agent仅依赖屏幕截图进行决策，无需访问诸如小部件树或元素属性之类的元数据。像AGUVIS这样的杰出工作就体现了这种方法。虽然纯视觉方法提供了更大的泛化性并绕过了系统API限制，但它们需要强大的“基础”能力来精确定位UI元素并与之交互——许多基础模型通常缺乏这种能力。专门针对视觉基础和GUI理解微调模型，或整合像OmniParser这样的GUI解析技术，可以解决这一挑战，并增强agent执行精确交互的能力。<br>GUIagent领域正朝着多agent架构、多模态能力、多样化的动作集和新颖的决策策略发展。这些创新标志着在创建智能、适应性强的agent方面迈出了重要一步，这些agent能够在各种动态环境中实现高性能。GUIagent的未来在于不断完善这些趋势，推动agent在更广泛的适用性和跨平台更复杂、更像人类的交互方面发展。<br>在上一章节中，探讨了基于LLM的GUIagent的通用框架，其中大多数框架依赖于诸如GPT-4V和GPT-4o之类的基础LLM。然而，为了提高这些agent的性能和效率，优化它们的“大脑”，即底层模型至关重要。实现这一目标通常需要使用大规模、多样化和高质量的上下文GUI数据集来微调基础模型，这些数据集经过专门策划，使这些模型能够在GUI特定任务中表现出色。收集此类数据集，特别是那些富含GUI屏幕截图、元数据和交互的数据集，需要一个精心设计的数据获取、过滤和预处理过程，每个过程都需要大量的精力和资源。<br>随着GUIagent的持续发展，研究人员专注于整合能够代表广泛各类平台并捕捉GUI环境多样、复杂的数据集。这些数据集对于训练能够有效泛化的模型至关重要，这归功于它们对各种界面、工作流程和用户交互的覆盖。为了确保全面性，诸多学者已经采用了各种创新的方法来收集和构建这些数据资产。在接下来的章节中，将详细介绍一个为训练GUI特定LLM量身定制的端到端数据收集和处理流程。还将检查来自各个平台的重要数据集，深入了解它们的独特功能、创建方法以及它们在推进基于LLM的GUIagent领域方面的潜在应用。为了提供结构化的概述，表10、11和12总结了不同平台上的这些数据集，突出了它们的主要属性和对GUIagent研究发展所做的贡献。<br>数据对于训练定制化的GUIagent至关重要，但由于任务的复杂性和所涉及环境的多样性，收集数据需要大量的时间和精力。<br>GUIagent训练所需的基本数据组成与第5.2.2节和5.4节中讨论的agent的感知和推理需求密切相关。从宏观层面来看，这些数据包括：<br>用户指令：这些指令提供了任务的总体目标、目的和具体细节，通常以自然语言形式呈现，为agent提供了一个明确的待完成目标，例如，“将所有文本的字体大小更改为12”。<br>环境感知：这通常包括GUI截图，通常带有各种视觉增强，以及可选的补充数据，如部件树和UI元素属性，以丰富上下文。<br>任务轨迹：这包含完成任务所需的关键动作序列，以及诸如agent计划之类的补充信息。一个轨迹通常涉及多个步骤和动作来完成任务。<br>用户指令和环境感知作为模型的输入，而模型的预期输出是任务轨迹。任务轨迹中的动作序列随后在环境中执行以完成任务。<br>对于用户指令，确保其真实并反映实际用户场景至关重要。指令可以通过多种方式获取：<br>直接来自人类设计者，他们可以根据实际应用提供见解；<br>如果存在合适的数据，则从现有的相关数据集中提取；<br>从公共材料中获取，例如网站、应用程序帮助文档和其他公开可用的资源；<br>由LLM生成，它可以模拟不同上下文中各种各样的用户请求。此外，LLM可用于数据增强，从而提高从原始数据中获得的指令的质量和多样性。<br>为了收集环境感知数据，可以使用各种工具包（例如第5.2.2节中讨论的工具包）来捕获所需的GUI数据。这可以在环境模拟器（例如，AndroidStudioEmulator29、SeleniumWebDriver30、WindowsSandbox31）中完成，也可以通过直接与真实环境交互来捕获GUI元素的状态，包括屏幕截图、部件树以及对agent操作至关重要的其他元数据。<br>收集任务轨迹（代表agent完成任务的动作序列）通常是最具挑战性的方面。任务轨迹需要准确、可执行且经过充分验证。收集方法包括：<br>使用以编程方式生成的脚本，这些脚本定义了预定义任务的动作序列，提供了一个高度受控的数据源；<br>聘请人工标注员，他们以众包方式完成任务，并记录每个步骤，从而获得丰富、真实的动作数据；<br>利用模型或agent自举(bootstrapping)，其中现有的LLM或GUIagent尝试完成任务并记录其动作，尽管此方法可能由于潜在的不准确性而需要额外的验证。<br>所有这些方法都需要大量的努力，反映了为训练GUIagent收集可靠、任务准确的数据的复杂性。<br>图22展示了一个完整的数据收集流程，旨在训练GUIagent模型。该过程首先收集初始用户指令，这些指令可能来自上述各种来源。这些指令通常是原型，尚未针对特定环境进行定制或关联。例如，来自一般网站的“如何更改字体大小？”之类的指令缺乏具体性，并且与用户在特定应用程序中可能提出的具体请求不一致。为了解决这个问题，需要一个实例化步骤，其中指令在特定环境中进行上下文关联，使其更具可操作性。例如，指令可能会被细化为“将draft.docx的Word文档中第三段的字体大小更改为20”，从而赋予其明确的、特定于环境的目标。此实例化过程可以由人工手动执行，也可以使用LLM以编程方式执行。<br>实例化之后，指令可能会经历一个过滤步骤，以删除低质量的数据，确保只保留相关且可操作的指令。此外，可以应用数据增强技术来扩展和多样化数据集，从而提高鲁棒性。这两个过程都可以涉及人工验证或利用LLM来提高效率。<br>一旦指令细化完成，任务轨迹和环境感知就会同时收集。当在环境中执行操作时，每个步骤都会被记录下来，从而提供环境状态和所采取的具体操作的记录。在记录完整的任务轨迹后，需要进行评估阶段，以识别并删除任何失败或不准确的序列，从而保持数据集的质量。通过迭代此流程，可以编译高质量的GUIagent数据集，这对于训练优化的模型至关重要。<br>在接下来的章节中，将回顾跨各种平台的现有GUIagent数据集，从而深入了解当前的实践和潜在的改进领域。<br>基于Web的GUIagent需要能够捕捉真实世界网络交互复杂性和多样性的数据集。这些数据集通常包含各种网站结构，包括DOM树和HTML内容，以及反映真实用户导航和交互模式的多步骤任务标注。开发能够跨不同网站泛化并执行复杂任务的agent，需要提供丰富上下文信息的综合数据集。<br>基于此需求，已经开发了几个重要的数据集来推进基于Web的GUIagent的发展。与专注于狭窄、预定义任务的传统数据集不同，Mind2Web通过强调开放式的任务描述，推动agent独立解释高层次目标，代表着一个重大的进步。它提供了跨越137个不同网站的2350多个人工标注的任务，捕捉了Web导航中典型的复杂交互模式和序列。这种设置有助于评估agent在未见领域中的泛化能力，并作为基于Web的GUI中语言基础的基准，增强了对实际应用的适应性。<br>类似地，WebVLN通过将导航与问答相结合，扩展了WebGUI任务。它为agent提供基于文本的查询，引导它们定位相关的网页并提取信息。通过利用网站的HTML和视觉内容，WebVLN与Web浏览的实际挑战相一致。对于旨在开发能够在GUI驱动的Web空间中进行复杂、类人交互的agent的研究人员来说，此数据集尤其有价值。<br>此外，WebLINX专注于会话式GUIagent，特别强调通过多轮对话进行真实世界的Web导航。WebLINX提供了跨越155个真实世界网站的2300多个专家演示，创建了一个具有DOM树和屏幕截图的丰富环境，用于训练和评估能够执行动态、用户引导的导航任务的agent。此数据集促进了agent在新网站和任务上的泛化，其中全面的动作和对话数据提供了关于增强agent在真实Web场景中响应能力的见解。<br>总而言之，这些数据集代表了重要的资源，能够促进Webagent能力的进步，支持为各种Web应用开发适应性强且智能的agent。<br>由于移动平台涉及各种应用程序和独特的用户交互，因此对于GUIagent而言至关重要。为了开发能够有效地导航和与移动界面交互的agent，数据集必须提供单步和多步任务的组合，重点关注自然语言指令、UI布局和用户交互。<br>该领域早期且基础性的贡献是Rico数据集，它提供了来自9700多个Android应用程序的72000多个独特的UI屏幕和10811个用户交互轨迹。Rico在UI布局相似性、交互建模和感知建模等任务中发挥了重要作用，为移动界面理解和GUIagent开发奠定了基础。<br>基于将自然语言指令与移动UI动作进行关联的需求，PIXELHELP引入了一个专门为此目的设计的数据集。它包括多步骤指令、屏幕截图和结构化的UI元素数据，可以详细分析如何将口头指令转换为移动动作。此数据集在可访问性和任务自动化方面具有重要的应用，支持基于口头提示自主执行任务的agent。<br>进一步扩展范围，AndroidintheWild(AITW)数据集提供了最广泛的自然设备交互集合之一。AITW涵盖了广泛的Android应用程序和不同的UI状态，捕捉了模拟真实设备使用的多步骤任务。它通过与Android模拟器的交互收集，包括屏幕截图和动作序列，使其成为开发无需依赖特定应用程序API即可导航应用程序界面的GUIagent的理想选择。由于其规模和多样性，AITW已成为该领域广泛使用的标准。<br>此外，META-GUI通过支持与移动GUI的直接交互，绕过对基于API的控制的需求，为移动面向任务的对话系统提供了一个独特的数据集。这种方法允许agent使用多轮对话和GUI轨迹跨各种移动应用程序进行交互，从而扩展了它们在没有自定义API依赖的实际应用中的能力。该数据集对复杂交互和多轮对话场景的支持使其对于构建强大的会话式agent非常有价值。<br>最近，MobileViews作为迄今为止最大的移动屏幕数据集出现，提供了来自20000个Android应用程序的600000多个屏幕截图-视图层次结构对。它使用LLM增强的应用程序遍历工具收集，为移动GUIagent在屏幕摘要、可点击性预测和UI组件识别等任务中提供了高保真资源。其规模和对屏幕状态的全面覆盖使MobileViews成为推进移动GUIagent能力的关键资源。<br>总而言之，由于其通用的工具、模拟器支持和多样化的用例，移动平台目前拥有最丰富的数据集，反映了移动应用中对高质量、适应性强的GUIagent的需求。<br>与移动和Web平台相比，尽管桌面GUIagent对于生产力工具和企业软件等应用至关重要，但其专用数据集相对较少。然而，在支持为复杂、多步骤桌面任务设计的agent的开发和评估方面，已经取得了显著的进展。<br>ScreenAgent是该领域的一项重要贡献，它是一个专门的数据集和模型，旨在促进Linux和Windows桌面环境中的GUI控制。ScreenAgent提供了一个全面的流程，使agent能够自主执行多步骤任务，包括规划、行动和反思阶段。通过利用带注释的屏幕截图和详细的动作序列，它实现了UI元素定位和任务完成的高精度，在准确性方面超越了之前的模型。对于那些旨在提升桌面领域GUIagent能力的研究人员来说，这个数据集非常宝贵，可以增强agent的决策准确性和用户界面交互能力。<br>LAM数据集专门用于训练和评估GUI环境中的大型动作模型(LAMs)，它弥合了自然语言任务理解和动作执行之间的鸿沟。它包含两个核心组成部分：任务-计划数据，详细描述了带有逐步计划的用户任务；以及任务-动作数据，将这些计划转化为可执行的GUI动作。该数据集来源于应用程序文档、WikiHow文章和Bing搜索查询，并使用GPT-4进行了丰富和结构化。该数据集针对Windows操作系统，专注于自动化MicrosoftWord中的任务，包括76672个任务-计划对和2688个任务-动作轨迹，使其成为基于GUI的动作学习的最大集合之一。数据质量通过一个强大的验证流程来保证，该流程结合了基于LLM的实例化、GUI交互测试和人工审查。每个条目都附有GUI屏幕截图和元数据，使模型能够学习高层次的任务规划和低层次的执行。该数据集的模块化设计支持针对特定GUI任务进行微调，并为在其他环境中构建数据集提供了一个可复制的框架，标志着在推进基于GUI的自动化方面做出了重大贡献。<br>尽管与移动和Web平台相比，桌面领域的数据集较少，但像ScreenAgent和LAMs这样的努力突显了人们对开发用于计算机系统的复杂GUIagent的日益增长的兴趣和潜力。<br>跨平台数据集在开发能够跨移动、计算机和Web环境无缝运行的多功能GUIagent方面起着关键作用。这些数据集支持泛化和适应性，使agent能够处理现实应用中各种不同的界面和任务。<br>ScreenAI是一项重要的贡献，它将数据收集范围扩展到包括移动和桌面界面。ScreenAI涵盖了屏幕注释、问答和导航等任务，提供了数亿个带注释的样本。其全面的规模和混合平台覆盖使其成为需要管理跨各种界面的复杂布局和交互的GUIagent的强大基础。通过强调元素识别和屏幕摘要，ScreenAI推进了能够处理各种视觉结构的多平台GUIagent的开发。<br>VisualAgentBench建立在跨环境评估视觉基础模型的需求之上，是一个开创性的跨平台基准，旨在评估移动和Web环境中的GUIagent。它强调以交互为中心的任务，使用Android虚拟设备和WebArena-Lite等环境来评估和改进agent对GUI布局和用户界面动作的响应。该数据集的创新收集方法，结合了基于程序的求解器和大型多模态模型引导，促进了强大的训练轨迹，增强了GUIagent任务中的适应性和错误恢复能力。<br>此外，GUI-World跨越了包括桌面、移动和XR环境在内的多个平台，拥有超过12000个带注释的视频。GUI-World旨在解决动态和顺序GUI任务的挑战，允许研究人员在各种界面上对GUIagent的能力进行基准测试。通过提供详细的动作序列和问答对，它为在复杂的现实场景中评估agent设定了高标准。<br>此外，xLAM通过提供统一的数据集格式来支持多轮交互、推理和函数调用任务，为可操作的agent开发做出了重大贡献。xLAM源自WebShop、ToolBench和AgentBoard等数据集，标准化了跨各种环境的数据格式，解决了阻碍agent训练和跨环境兼容性的数据结构不一致的常见问题。通过提供一致的结构，xLAM增强了GUIagent的适应性和错误检测能力，从而可以在不同的应用程序中实现更无缝的集成和性能。<br>总而言之，这些跨平台数据集有助于构建多平台GUIagent，为能够在不同界面之间无缝导航和执行任务的agent铺平了道路，从而促进了更加通用和适应性强的系统。<br>为基于大型语言模型(LLM)的图形用户界面(GUI)agent进行数据收集和整理是一项密集的过程，通常需要大量的人工参与，尤其是在生成准确的动作序列和注释方面。早期的数据集在规模和任务多样性方面都有限，但最近的进展促成了大规模、多平台数据集的出现，这些数据集支持更复杂和真实的GUI交互。这些发展中的关键见解包括：<br>规模和多样性：高质量、大规模的数据对于训练能够处理各种UI状态和任务的强大GUIagent至关重要。诸如MobileViews和ScreenAI等数据集说明了庞大且多样化的数据对于适应移动和桌面应用程序动态特性的重要性，从而增强了agent在不同环境中的适应能力。<br>跨平台灵活性：诸如VisualAgentBench和GUI-World等跨平台数据集强调了泛化性的价值，使agent能够在移动、Web和桌面环境中保持一致的性能。这种跨平台适应性是创建一站式解决方案的关键一步，其中单个GUIagent可以在多个平台上无缝运行。<br>自动化数据收集：以OmniParser和MobileViews为例的AI驱动的数据收集工具，展示了显著减少人工工作量并加速可扩展数据集创建的潜力。通过自动化注释过程，这些工具为更高效的数据管道铺平了道路，朝着AI通过加速复杂GUI交互的数据收集和标记来支持AI的未来迈进。<br>统一的数据格式和协议：xLAM的统一数据格式是一项重要的创新，它提高了跨不同平台的兼容性，解决了跨平台GUIagent开发中的一个重大瓶颈。考虑到不同平台之间的数据格式、动作空间和环境表示形式各不相同，为数据收集建立标准化协议或动作空间对于促进agent的泛化和一致性至关重要。<br>总而言之，用于基于LLM的GUIagent的数据集的演变涵盖了多个平台，每个数据集都解决了特定于其环境的独特挑战和需求。这些基础资源是使agent能够理解复杂的UI、执行细致的交互并提高在各种应用程序中的泛化能力的关键。推动跨平台适应性、自动化数据收集和标准化数据格式将继续塑造GUIagent的未来。<br>更多智能体(Agent)相关可以订阅此专题：智能体(Agent)专题<br>LLM充当GUIagent的“大脑”，使它们能够解释用户意图、理解GUI屏幕并执行直接影响其环境的动作。虽然一些现有的基础模型足够强大，可以作为这个核心大脑，但可以进一步微调和优化，以升级为大型动作模型(LAM)——专门为提高GUIagent的性能和效率而定制的模型。这些LAM弥合了通用能力与基于GUI交互的特定需求之间的差距。<br>在本节中，首先介绍目前构成GUIagent主干的基础模型，重点介绍它们的优势和局限性。然后，深入探讨LAM的概念，讨论如何使用特定于GUI的数据集对这些模型进行微调，以增强它们在GUI环境中的适应性、准确性和面向动作的能力。通过这种探索，阐述了从通用LLM到专门构建的LAM的演变过程，为先进的智能GUIagent奠定了基础。<br>基础模型是基于LLM的GUIagent的核心，为理解和与图形用户界面交互提供基本能力。最近在闭源和开源多模态大型语言模型(MLLM)方面的进展显著增强了GUIagent的潜力，改进了效率、可扩展性和多模态推理等方面。本小节探讨了这些基础模型，重点介绍它们的创新、贡献以及对GUIagent应用的适用性。为了快速参考，表13概述了关键模型及其特性。<br>虽然专有的闭源模型不公开而无法定制，但它们提供了强大的功能，可以直接用作GUIagent的“大脑”。<br>其中，GPT-4V和GPT-4o由于其强大的能力，在现有的GUIagent框架中使用最为广泛，如第6节所述。GPT-4V代表了多模态AI的重大进步，它结合了文本和图像分析，扩展了传统LLM的功能。它基于文本和视觉输入理解和生成响应的能力使其非常适合需要深度多模态推理的GUIagent任务。尽管由于安全和伦理方面的考虑，其部署受到限制，但需要强调的是GPT-4V作为基础模型通过增强效率和灵活性彻底改变GUIagent开发的潜力。<br>同样，GPT-4o提供了一个统一的多模态自回归架构，能够处理文本、音频、图像和视频。该模型擅长高效生成多样化的输出，与之前的模型相比，以更低的成本实现了更快的响应。其严格的安全和对齐实践使其对于敏感任务依然可靠，使其成为需要全面多模态理解的智能GUIagent的强大工具。<br>Gemini模型系列通过提供针对高复杂度任务、可扩展性能和设备端效率量身定制的版本，推进了多模态AI建模。值得注意的是，Nano模型尽管体积小巧，但在推理和编码任务中表现出显著的能力，使其适用于资源受限的设备。Gemini的多功能性和效率使其成为为需要性能和适应性的GUIagent提供动力的一个引人注目的选择。<br>此外，需要强调一下工业界对GUI自动化的投入，如Claude3.5Sonnet(ComputerUse，计算机使用)开创性地利用仅视觉范例进行桌面任务自动化。它利用实时屏幕截图来观察GUI状态并生成动作，无需元数据或底层GUI结构。该模型通过解释屏幕、移动光标、单击按钮和键入文本来有效地自动化GUI任务。其独特的架构将基于ReAct的推理范例与选择性观察相结合，通过仅在必要时观察环境来减少计算开销。此外，Claude3.5维护GUI屏幕截图的历史记录，增强了任务适应性，并实现了与软件环境的类人动态交互。尽管在处理动态界面和错误恢复方面存在挑战，但该模型代表了创建通用GUIagent的重要一步。它的开发突显了业界对该领域的大量投入，表明人们越来越关注利用LLM进行高级GUI自动化。<br>开源模型为定制和优化提供了灵活性，使开发者能够利用上下文数据调整GUIagent，并将其部署在资源有限的设备上。<br>Qwen-VL系列以其精细的视觉理解和多模态能力而著称。它采用基于VisionTransformer的视觉编码器和Qwen-7B语言模型，在视觉-语言基准测试中取得了最先进的成果，同时支持多语言交互。其高效性和开源特性，以及为提高资源效率而提供的量化版本，使其非常适合开发需要精确视觉理解的GUIagent。<br>在此基础上，Qwen2-VL引入了诸如朴素动态分辨率和多模态旋转位置嵌入等创新技术，能够高效处理包括长视频在内的各种模态。Qwen2-VL的可扩展版本平衡了计算效率和性能，使其能够适应设备端应用和GUI环境中复杂的的多模态任务。<br>InternVL-2将VisionTransformer与大型语言模型相结合，以处理文本、图像、视频和医疗数据输入。其渐进式对齐策略和各种尺寸版本的可用性使其在部署方面具有灵活性。通过在复杂的多模态任务中取得最先进的性能，InternVL-2展示了强大的能力，这对于需要全面多模态理解的GUIagent来说非常有价值。<br>CogVLM在视觉和语言信息的有效集成方面取得了进展，它在跨模态任务中表现出色，且可训练参数相对较少。它能够在保留大型语言模型全部功能的同时，深度整合视觉和语言特征，使其成为GUIagent开发的基础，尤其是在资源效率至关重要的应用中。<br>Ferret增强了空间理解和定位能力，为GUIagent提供了一种量身定制的创新方法。通过在单个框架内统一指代和定位任务，并采用混合区域表示，它提供了与图形界面的精确交互。其针对对象幻觉的鲁棒性和高效的架构使其成为在实时GUI应用中进行设备端部署的理想选择。<br>LLaVA模型将视觉编码器与语言解码器集成，促进了模态之间的有效对齐。其轻量级的投影层和模块化设计实现了快速实验和调整，使其适用于需要快速开发周期和强大的多模态推理能力的GUIagent。在此基础上，LLaVA-1.5引入了一种新型的基于MLP的跨模态连接器，并扩展到高分辨率图像输入，以最少的训练数据实现了令人印象深刻的性能。其数据效率和开源特性为在需要详细视觉推理的GUI应用中的广泛使用铺平了道路。<br>BLIP-2通过利用冻结的预训练模型并引入轻量级的查询Transformer，采用了一种计算高效的策略。这种设计允许在可训练参数较少的情况下，在视觉-语言任务上实现最先进的性能。BLIP-2的模块化和高效性使其适用于资源受限的环境，突显了其在设备端GUIagent中的潜力。<br>最后，Phi-3.5-Vision在紧凑的模型尺寸内实现了多模态推理方面的竞争性性能。其创新的训练方法以及图像和文本理解的有效集成，使其成为需要多模态推理和设备端推理的GUIagent的有力候选者，而无需大型模型的计算开销。<br>总而言之，闭源和开源的基础模型都显著提高了由LLM驱动的GUIagent的能力。虽然专有模型提供了强大的开箱即用性能，但开源模型为定制和优化提供了灵活性，从而为各种GUIagent应用提供了量身定制的解决方案。这些模型在多模态推理、效率和可扩展性方面的创新突显了基础模型不断发展的态势，为更智能、更易于访问的GUIagent铺平了道路。<br>虽然通用基础LLM在多模态理解、任务规划和工具利用等能力方面表现出色，但它们通常缺乏GUI导向型任务所需的专门优化。为了解决这个问题，研究人员引入了大型动作模型(LAM)，这些模型是使用上下文的、GUI特定的数据集（如第7节所述）进行微调的基础LLM，以增强其动作驱动能力。这些模型代表了在改进GUIagent的“大脑”以获得卓越性能方面迈出的重要一步。<br>在GUIagent领域，LAM提供了几个变革性的优势：<br>增强的动作导向性：通过专注于动作导向型任务，LAM能够准确解释用户意图并生成精确的动作序列。这种微调确保了LAM能够将其输出与GUI操作无缝对齐，从而提供为用户请求量身定制的可操作步骤。<br>针对长期复杂任务的专业规划：LAM擅长制定和执行复杂的、多步骤的工作流程。无论任务跨越多个应用程序还是涉及相互依赖的操作，LAM都会利用其在广泛的动作序列数据集上的训练，来创建连贯的长期计划。这使得它们非常适合需要跨各种工具进行复杂规划的以生产力为中心的工作。<br>改进的GUI理解和视觉定位：通过在包含GUI屏幕截图的数据集上进行训练，LAM能够提高其检测、定位和解释UI组件（如按钮、菜单和表单）的能力。通过利用视觉线索而不是仅仅依赖结构化的UI元数据，LAM变得高度适应，可以在各种软件环境中有效地执行操作。<br>通过减小模型尺寸提高效率：许多LAM都建立在较小的基础模型之上——通常约为70亿参数——这些模型针对GUI特定任务进行了优化。这种紧凑的、目标驱动的设计减少了计算开销，即使在资源受限的环境中（如设备端推理）也能实现高效运行。<br>如图23所示，为GUIagent开发专用LAM的过程始于一个强大的通用基础模型，理想情况下应具有VLM能力。在全面、专业的GUI数据集（包括用户指令、控件树、UI属性、动作序列和带注释的屏幕截图）上对这些模型进行微调，将其转化为优化的LAM，从而有效地使其成为GUIagent的“大脑”。<br>这种优化弥合了规划和执行之间的差距。通用LLM可能仅提供文本计划或抽象指令来响应用户查询，这些指令可能缺乏精确性。相比之下，由LAM赋能的GUIagent超越了规划，能够积极且智能地在GUI上执行任务。通过直接与应用程序界面交互，这些agent能够以卓越的精度和适应性执行任务。这种范式转变标志着GUIagent从被动的任务规划者向主动的、智能的执行者的演变。<br>在接下来的章节中，将对针对不同平台的GUIagent量身定制的LAM进行分析，总结在表14、15和16中，并在随后的子章节中进行深入讨论。<br>在基于网页的GUIagent领域，研究人员开发了专门的LAMs，以增强在网页环境中的交互和导航。这些模型经过定制，能够理解网页GUI的复杂性，包括动态内容和多样的交互模式。<br>为了满足多模态理解的需求，WebGUM通过时序和局部token将HTML理解与视觉感知相结合。它利用Flan-T5进行指令微调，并使用ViT处理视觉输入，从而能够高效地处理文本和视觉信息。这种多模态基础使得WebGUM能够有效地泛化任务，在MiniWoB++和WebShop等基准测试中显著优于先前的模型。凭借其数据高效的设计和多步骤推理能力，WebGUM强调了结合多模态输入在增强GUIagent性能方面的重要性。<br>针对GUI环境中多步骤推理和规划的挑战，研究人员引入了包含高级搜索和学习机制的框架。例如，AgentQ采用MCTS结合自我批判机制和直接偏好优化（DPO），以提高产品搜索和预订等复杂任务的成功率。通过微调LLaMA-370B模型来处理HTMLDOM表示并生成结构化的行动计划、思考过程和特定于环境的命令，该框架展示了整合推理、搜索和迭代微调在自主agent开发中的强大作用。<br>GLAINTEL利用较小的模型进行高效的网页交互，表明无需大量计算资源即可实现高性能。该模型使用具有7.8亿参数的Flan-T5模型，专注于模拟电子商务平台等动态网页环境。该模型结合了强化学习来优化查询制定和导航等操作，有效地整合了人类演示和无监督学习。GLAINTEL以远低于基于GPT-4的方法的计算成本实现了可比的结果，突显了强化学习在增强基于网页的GUIagent以进行特定任务优化方面的潜力。<br>为了实现跨不同网页领域的持续改进和泛化，OpenWebVoyager将模仿学习与迭代探索-反馈-优化循环相结合。它利用Idefics2-8B等大型多模态模型执行自主网页导航任务。通过在多样化的数据集上进行训练，并使用GPT-4反馈验证的轨迹进行微调，该agent解决了现实世界的复杂性，而无需依赖合成环境。这种方法通过展示跨不同网页领域和任务进行泛化的能力，显著推进了GUIagent框架的发展。<br>此外，为了应对稀疏训练数据和策略分布漂移等挑战，WebRL引入了自我演化的课程和强大的奖励机制，用于训练LLM作为熟练的网页agent。通过根据agent的性能动态生成任务，WebRL微调了Llama-3.1和GLM-4等模型，在WebArena环境中的网页任务中取得了显著的成功率。该框架的性能优于专有API和其他开源模型，突显了自适应任务生成和持续学习改进在开发高级GUIagent方面的有效性。<br>这些在面向网页GUIagent的LAMs方面的进展，说明了整合多模态输入、高效的模型设计和创新的训练框架对于增强agent在复杂网页环境中的能力的重要性。<br>移动平台为GUIagent带来了独特的挑战，包括不同的屏幕尺寸、触摸交互和资源限制。研究人员开发了专门的LAMs来应对这些挑战，从而增强了在移动环境中的交互和导航。<br>MobileVLM专注于详细的UI理解，引入了一种专门为移动UI操作任务设计的高级视觉语言模型。它基于Qwen-VL-Chat，结合了针对UI内部和UI之间理解的移动特定预训练任务。通过利用Mobile3M数据集——一个包含300万个UI页面和交互轨迹的综合语料库，这些数据被组织成有向图——该模型在动作预测和导航任务中表现出色。MobileVLM的新颖的两阶段预训练框架显著增强了其对移动UI的适应性，在ScreenQA和Auto-UI等基准测试中优于现有的VLM。这项工作突出了定制预训练在提高移动GUIagent性能方面的有效性。<br>为了解决动态环境中鲁棒交互的需求，DigiRL提出了一个基于强化学习的框架，该框架专为在Android环境中训练GUIagent而定制。<br>通过利用离线到在线的强化学习，DigiRL能够适应真实世界的随机性，使其适用于多样化的多步骤任务。与先前依赖于模仿学习的模型不同，DigiRL从交互数据中自主学习，不断改进自身以从错误中恢复并适应新的场景。使用具有13亿参数的预训练视觉语言模型能够高效地处理GUI截图和导航命令。其在AITW数据集上的表现表明，它比基线方法有了显著的改进，这使得DigiRL成为开发针对复杂GUI交互进行优化的智能agent的基准。<br>为了增强GUI理解并减少对文本数据的依赖，VGA采用了微调的视觉语言模型，该模型优先考虑基于图像的线索，如形状、颜色和位置。VGA使用RICO数据集进行训练，专为AndroidGUI定制，并采用两阶段微调过程，使响应与视觉数据和人类意图保持一致。该模型擅长理解GUI布局、预测设计意图并促进精确的用户交互。通过在GUI理解基准测试中优于GPT-4V等现有模型，VGA为移动GUIagent的准确性和效率设定了新标准。<br>在轻量级和高效模型的背景下，UINav展示了一个实用的系统，用于训练神经agent以自动化移动设备上的UI任务。它通过宏操作和错误驱动的演示收集过程，平衡了准确性、泛化性和计算效率。UINav使用紧凑的编码器-解码器架构和SmallBERT进行文本和屏幕元素编码，使其适用于设备上的推理。一个关键的创新之处在于，它能够通过最少的演示在不同的任务和应用程序中进行泛化，从而通过一个通用的框架解决了UI自动化中的关键挑战。<br>这些模型通过创新的训练方法、高效的模型架构和专门的数据集，共同推动了移动GUIagent领域的发展，从而应对了特定于平台的挑战。<br>在桌面和笔记本电脑环境中，GUIagent必须处理复杂的应用程序、多任务以及各种交互模式。专为计算机GUIagent设计的LAMs增强了在这些环境中的能力，从而实现更复杂的任务执行。<br>ScreenAgent集成了规划、执行和反思阶段，旨在实现与计算机屏幕的自主交互。它基于CogAgent，并使用ScreenAgent数据集进行微调，该数据集提供了跨各种任务的全面GUI交互数据。ScreenAgent以屏幕截图作为输入，并以JSON格式输出鼠标和键盘操作，实现了精确的UI元素定位，并能处理连续的多步骤任务。它利用基础模型处理实时GUI交互的能力，为LLM驱动的GUIagent树立了新的基准，使其成为未来研究构建更通用的智能agent的理想参考。<br>Octopus(Octopus:Embodiedvision-languageprogrammerfromenvironmentalfeedback)将高层规划与现实世界的操作相结合，代表了具身视觉语言编程的开创性一步。Octopus利用MPT-7B和CLIPViT-L&#x2F;14，整合了以自我为中心的视角和鸟瞰视角进行视觉理解，并生成可执行的操作代码。它使用OctoVerse套件进行训练，其数据集涵盖了像OmniGibson、Minecraft和GTA-V这样具有丰富注释的环境，涵盖了常规任务和需要推理的任务。值得注意的是，Octopus通过环境反馈的强化学习进行创新，确保了自适应的规划和执行。其依赖视觉的功能在未见场景中提供了无缝的任务泛化，突显了其作为在复杂GUI环境中运行的具身agent的统一模型的能力。<br>Wang等人(Largeactionmodels:Frominceptiontoimplementation)对LAMs进行了全面的概述，这是一种旨在在GUI环境中执行实际操作的新型AI范式，并以Windows操作系统上的UFO作为案例研究平台。LAMs基于Mistral-7B基础模型构建，通过将任务规划与可操作的输出相结合，超越了传统的LLM。LAMs利用来自UI自动化(UIA)API等工具的结构化输入，生成用于动态规划和自适应响应的可执行步骤。多阶段训练策略——包括任务计划预训练、模仿学习、自我增强探索和强化学习——确保了其稳健性和准确性。在真实GUI任务上的评估突显了LAMs相较于标准模型具有更高的任务成功率。这项创新为能够将用户请求转化为实际操作的智能GUIagent奠定了基础，推动了生产力和自动化方面的重大进展。<br>计算机GUIagent的这些发展突显了高级视觉理解、规划和动作执行的集成，为更复杂和功能强大的桌面agent铺平了道路。<br>为了实现跨各种平台的通用性，开发了跨平台LAMs，使GUIagent能够在移动设备、桌面和Web界面等多种环境中无缝运行。<br>CogAgent是一款先进的视觉语言模型，专门用于理解和导航PC、Web和Android平台上的GUI。它基于CogVLM构建，并集成了一个新的高分辨率跨模块，以高效处理GUI屏幕截图，从而能够详细理解GUI元素及其空间关系。CogAgent在需要OCR和GUI接地的任务中表现出色，并在Mind2Web和AITW等基准测试中取得了最先进的性能。它生成准确的行动规划并与GUI交互的能力，使其成为开发针对GUI环境优化的智能agent的关键一步。CogAgent进一步发展成为其beta版本GLM-PC，提供了增强的控制能力。<br>苹果公司的Ferret-UI2(Ferret-UI2解读：简介版，Ferret-UI2解读：详解版)专注于通用GUI理解，是一款最先进的多模态大型语言模型，旨在掌握包括iPhone、Android设备、iPad、Web和AppleTV在内的各种平台上的UI理解。通过采用动态高分辨率图像编码、自适应网格划分以及通过GPT-4生成的高质量多模态训练数据，它在UI指代、接地和交互任务中优于其前身和其他竞争模型。Ferret-UI2的高级数据集和创新训练技术确保了在空间理解和以用户为中心的交互方面的高精度，为跨平台UI适应性和性能树立了新的基准。<br>ShowUI推进了GUI自动化，引入了一种开创性的视觉-语言-动作模型，该模型将高分辨率视觉输入与文本理解相结合，以执行接地、导航和任务规划。ShowUI针对Web、桌面和移动环境进行了优化，利用Phi-3.5-vision-instruct主干和全面的数据集，在ScreenSpot和GUI-Odyssey等基准测试中取得了稳健的结果。它处理多帧和动态视觉输入以及JSON结构化输出操作的能力突显了其多功能性。凭借交错的图像-文本处理和函数调用功能的创新，ShowUI为LLM驱动的GUIagent设定了新标准。<br>为了满足统一动作空间的需求，OS-ATLAS引入了一种基础动作模型，专门为Windows、macOS、Linux、Android和Web等平台上的GUIagent设计。通过利用大规模多平台数据集并实施统一的动作空间，OS-ATLAS在GUI接地和分布外泛化任务中取得了最先进的性能。其可扩展的配置可适应不同的计算需求，同时保持在处理自然语言指令和GUI元素方面的多功能性。作为商业解决方案的强大开源替代方案，OS-ATLAS标志着在普及高级GUIagent方面迈出了重要一步。<br>这些跨平台LAMs展示了统一模型适应不同环境的潜力，从而增强了GUIagent在各种环境中的可扩展性和适用性。<br>对GUIagent的LAMs的探索揭示了一些关键见解，这些见解正在塑造与图形用户界面进行智能交互的未来：<br>用于设备端推理的较小模型：许多优化的LAMs都是基于较小的基础模型构建的，通常参数范围在10亿到70亿之间。这种模型尺寸的缩小提高了计算效率，使得在移动电话和边缘设备等资源受限的设备上部署这些模型成为可能。在不依赖云服务的情况下执行设备端推理的能力解决了隐私问题并减少了延迟，从而带来了更快速的用户体验。<br>增强的GUI理解减少了对结构化数据的依赖：像VGA和OmniParser这样的模型强调了视觉接地和以图像为中心的微调的重要性，以减少对结构化UI元数据的依赖。通过直接从视觉输入改进GUI理解，agent变得更适应不同的软件环境，包括那些可能无法访问或不一致的结构化数据的环境。<br>强化学习弥合了静态和动态环境之间的差距：在DigiRL等模型中应用强化学习证明了将静态训练数据与动态真实世界环境联系起来的有效性。这种方法允许agent从交互中学习、从错误中恢复并适应变化，从而增强了其在实际应用中的稳健性和可靠性。<br>统一的函数调用增强了互操作性：如xLAM等模型所示，标准化数据格式和函数调用机制的努力有助于跨不同平台进行多轮交互和推理。这种统一解决了兼容性问题，并增强了agent执行涉及多个API和服务的复杂任务的能力。<br>GUIagent的LAMs的进步突显了向专业化、高效和适应性强的模型发展的趋势，这些模型能够在各种平台上执行复杂的任务。通过专注于专业化、多模态集成和创新训练方法，研究人员正在克服通用LLM的局限性。这些见解为更智能、更快速响应且用户友好的GUIagent铺平了道路，这些agent可以改变与软件应用程序的交互方式。<br>在GUIagent领域，评估对于提升功能和用户体验至关重要，并且应该从多个方面进行。通过系统地评估这些agent在各种任务中的有效性，评估不仅衡量了它们在不同维度上的表现，还为它们的持续改进提供了框架。此外，它通过识别潜在的开发领域来鼓励创新，确保GUIagent与LLM的进步同步发展，并符合用户期望。<br>如图24所示，当一个GUIagent完成一项任务时，它会生成一个动作序列，捕获屏幕截图，提取UI结构，并记录由此产生的环境状态。这些输出是评估agent在不同平台上通过各种指标和测量来衡量其性能的基础。在接下来的章节中，将深入探讨这些评估方法，讨论用于全面评估GUIagent的指标和测量方法。还将概述针对不同平台上GUIagent的现有基准，突出它们的主要特征以及它们所解决的挑战。<br>评估GUIagent需要强大且多维的指标，以评估它们在各个维度上的性能，包括准确性、效率和合规性（例如，安全性）。在一个典型的基准测试设置中，GUIagent会收到自然语言指令作为输入，并期望自主执行动作直到任务完成。在此过程中，可以收集各种资产，例如agent采取的动作序列、逐步观察（例如，DOM或HTML结构）、屏幕截图、运行时日志、最终状态和执行时间。这些资产使评估人员能够确定任务是否已成功完成，并分析agent的性能。在本节中，总结了常用于基准测试GUIagent的关键评估指标。请注意，不同的研究工作可能会使用不同的名称来表示这些指标，但计算方式相似。在本节中，将统一它们的名称。<br>步骤成功率（StepSuccessRate）:完成一项任务可能需要多个步骤。此指标衡量的是成功步骤数与任务中总步骤数的比率。较高的步骤成功率表明对细粒度步骤的精确和准确执行，这对于涉及多个步骤的任务的可靠性能至关重要。<br>回合成功率（TurnSuccessRate）:一个回合表示用户和agent之间的一次交互。一个回合可能包含多个步骤，而完成一项任务可能包含多个回合。此指标衡量的是在交互中成功解决请求的回合数与所有回合数的比例。它侧重于agent在交互式或基于对话的任务中理解和满足用户期望的能力，确保agent在迭代交互中的响应性和可靠性，尤其是在需要动态用户-agent通信的任务中。<br>任务成功率（TaskSuccessRate）:任务成功率衡量的是在基准测试中设置的所有任务中成功完成的任务数。它评估是否达到了最终的任务完成状态，而忽略了中间步骤。此指标提供了端到端任务完成的整体衡量标准，反映了agent整体处理复杂工作流程的能力。<br>效率得分（EfficiencyScore）:效率得分评估agent在完成任务时的效率，同时考虑资源消耗、执行时间或agent可能采取的总步骤数。此指标可以细分为以下子指标：<br>根据使用的具体指标，效率得分在不同的论文中可能有不同的解释。<br>时间成本（TimeCost）:衡量完成任务所花费的时间。<br>资源成本（ResourceCost）:衡量完成任务所使用的内存&#x2F;CPU&#x2F;GPU使用率。<br>LLM成本（LLMCost）:评估任务执行期间使用的LLM调用的计算或货币成本。<br>步骤成本（StepCost）:衡量完成任务所需的总步骤数。<br>策略下的完成率（CompletionunderPolicy）:此指标衡量在遵守策略约束的情况下成功完成任务的比率。它确保agent在任务执行期间遵守用户定义或组织规则，例如安全、道德、安全、隐私或业务指南。此指标对于合规性与任务成功同等重要的应用尤其相关。<br>风险比率（RiskRatio）:与前一个指标类似，风险比率评估agent在任务执行期间的行为相关的潜在风险。它识别在任务处理过程中可能出现的漏洞、错误或安全问题。较低的风险比率表示较高的可信度和可靠性，而较高的比率可能表明需要改进的领域，以最大限度地降低风险并增强鲁棒性。<br>每个GUIagent基准中指标的实现可能会因平台和任务制定而异。在表17至表21中，将基准测试中使用的原始指标（可能具有不同的名称）映射到上面定义的类别。<br>为了有效地评估GUIagent，采用了各种测量技术来评估它们的准确性以及与预期输出的一致性。这些测量使用代码、模型，甚至agent作为评估器，验证了agent性能的不同方面，从文本和视觉正确性到交互准确性和系统状态感知。下面总结了在基准测试GUIagent中使用的关键测量方法。基于这些测量，可以相应地计算先前定义的评估指标。<br>文本匹配（TextMatch）:此测量评估agent的基于文本的输出是否与预期结果匹配。例如，当agent浏览电子商务网站时，是否达到了目标产品名称。它可以涉及不同级别的严格性，包括：<br>文本匹配广泛应用于涉及文本选择、数据输入或自然语言响应的任务中。<br>精确匹配（ExactMatch）:确保输出与预期结果完全匹配。<br>部分或模糊匹配（PartialorFuzzyMatch）:允许近似匹配，这对于处理诸如拼写错误或同义词之类的细微变化很有用。<br>语义相似性（SemanticSimilarity）:使用文本嵌入的余弦相似性或其他语义相似性度量等技术来衡量语义意义上的更深层次的一致性。<br>图像匹配（ImageMatch）:图像匹配侧重于验证agent是否在预期的页面（例如，网页、应用程序UI）上执行操作或停止，或者是否选择了正确的图像。它涉及使用图像相似性指标或视觉问答（VQA）方法将屏幕截图、选定的图形元素或视觉结果与真实图像进行比较。此测量对于需要精确视觉识别的任务至关重要。<br>元素匹配（ElementMatch）:此测量检查agent交互的特定小部件元素（例如，HTML、DOM或应用程序UI层次结构中的元素）是否与预期元素一致。这些可能包括：<br>元素匹配确保在任务执行期间与不同平台上的用户界面组件进行稳健的交互。<br>HTML标签和属性（HTMLTagsandAttributes）:确保agent识别并与正确的结构元素交互。<br>URL和链接（URLsandLinks）:验证与导航相关的元素。<br>DOM层次结构（DOMHierarchies）:确认与动态或复杂Web界面中预期DOM结构的一致性。<br>UI控件和小部件（UIControlsandWidgets）:验证与平台特定控件的交互，例如桌面和移动应用程序中的按钮、滑块、复选框、下拉菜单或其他GUI组件。<br>辅助功能标识符（AccessibilityIdentifiers）:在Android和iOS等移动平台中利用辅助功能标识符或资源ID来确保正确选择元素。<br>视图层次结构（ViewHierarchies）:评估与移动应用程序中预期视图层次结构的一致性，类似于Web应用程序中的DOM层次结构。<br>系统控件和API（SystemControlsandAPIs）:确保与操作系统控件或API的正确交互，例如桌面环境中的文件对话框、系统菜单或通知。<br>动作匹配（ActionMatch）:此测量通过将agent的动作（例如，点击、滚动或按键）与预期序列进行比较来评估其准确性。它涉及：<br>动作匹配对于评估任务完成中的逐步正确性至关重要。<br>动作准确性（ActionAccuracy）:验证每个动作（包括动作类型及其参数）是否正确执行（例如，点击正确的按钮，输入正确的输入）。<br>动作序列对齐（ActionSequenceAlignment）:确保动作以正确的顺序发生以满足任务要求。<br>位置预测（LocationPrediction）:检查空间动作（例如，鼠标点击或触摸手势）是否针对界面的预期区域。<br>状态信息（StateInformation）:状态信息捕获任务执行期间与系统环境相关的运行时数据。它提供了对可能影响agent行为的上下文因素的见解，例如：<br>此测量对于调试、性能分析以及确保在各种条件下可靠性非常有用。<br>应用程序状态（ApplicationState）:有关正在交互的应用程序状态的信息（例如，打开的文件、活动窗口、保存在给定位置的文件）。<br>系统日志（SystemLogs）:记录agent决策和交互的详细日志。<br>环境变量（EnvironmentVariables）:关于操作系统或运行时环境的上下文数据。<br>每种测量技术都有助于建立一个全面的评估框架，确保agent不仅能够完成任务，而且能够以精确、高效和适应性强的方式完成任务。它们共同帮助建立对agent在真实场景中可靠执行任务能力，同时保持对策略约束的遵守的信任。<br>评估图形用户界面(GUI)agent需要多样化的平台，以捕捉这些agent运行的各种环境。这些平台涵盖了网页、移动和桌面环境，每个环境都有其独特的特点、挑战和评估工具。本节总结了这些平台的关键方面及其在GUIagent基准测试中的作用。<br>网页(Web):网页平台是GUIagent最常见的环境之一，反映了它们在日常任务中的普及，例如浏览、填写表单和数据抓取。用于评估的网页平台的关键特征包括：<br>动态内容:网页应用程序通常涉及通过JavaScript、AJAX或类似技术生成的动态元素，这要求agent有效处理异步更新。<br>多样化的框架:各种网页技术（例如，HTML、CSS、JavaScript框架）要求agent能够与各种界面设计和结构进行交互。<br>工具和库:评估通常使用诸如Selenium、Puppeteer或Playwright之类的工具来模拟浏览器交互、收集运行时信息以及将结果与预期结果进行比较。<br>可访问性合规性:还可以评估诸如WCAG（Web内容可访问性指南）遵守情况之类的指标，以确保包容性。<br>移动(Mobile):移动平台，特别是Android和iOS，由于其受限的界面和基于触摸的交互，给GUIagent带来了独特的挑战。在移动平台上评估agent包括：<br>屏幕尺寸限制:Agent必须适应有限的屏幕空间，确保交互保持准确和高效。<br>触摸手势:评估agent模拟诸如点击、滑动和捏合等手势的能力至关重要。<br>平台多样性:Android设备在屏幕尺寸、分辨率和系统版本方面差异很大，而iOS则提供更标准化的条件。<br>评估工具:诸如Appium和Espresso（用于Android）或XCTest（用于iOS）之类的工具以及模拟器通常用于测试和评估。<br>桌面(Desktop):桌面平台为GUIagent提供了更丰富和更复杂的环境，涵盖了诸如Windows、macOS和Linux之类的多种操作系统。在桌面平台上进行的评估通常强调：<br>应用程序多样性:Agent必须处理各种桌面应用程序，包括生产力工具、网页浏览器和自定义企业软件。<br>交互复杂性:桌面界面通常包含诸如键盘快捷键、拖放和上下文菜单之类的高级功能，agent必须正确处理这些功能。<br>跨平台兼容性:评估可能涉及确保agent可以在多种操作系统和版本上运行。<br>自动化框架:诸如WindowsUIAutomation、macOSAccessibilityAPIs和Linux的AT-SPI之类的工具用于自动化和监视agent交互。<br>资源使用:内存和CPU使用率是重要的指标，特别是对于长时间运行的任务或资源密集型应用程序。<br>每个平台都为评估GUIagent提出了不同的挑战和机遇。网页平台强调可扩展性和动态交互，移动平台侧重于触摸界面和性能，而桌面平台则需要处理复杂的工作流程和跨应用程序任务。一些基准测试是跨平台的，要求agent具有稳健性、适应性并且能够跨不同环境进行泛化。<br>所有讨论的指标、测量和平台对于全面评估GUIagent的多个方面至关重要。大多数现有的基准测试都依赖它们进行评估。接下来，首先在表17到表21中概述这些GUIagent的基准测试，然后在以下小节中选择性地详细介绍它们。<br>评估网页环境中的GUIagent需要捕捉任务的复杂性。多个基准测试的开发推动了这一领域的进展。<br>MiniWoB++是开创性工作，聚焦于强化学习agent在真实交互场景中的表现，包括单击和导航。它通过工作流引导探索(WGE)提高稀疏奖励环境的效率，以成功率评估agent的适应性。<br>Mind2Web进一步提升真实环境测试，使agent能处理真实HTML内容，提供2000多个任务，涵盖从基本操作到复杂多页面工作流程。它通过元素准确率和任务成功率等指标评估端到端性能。<br>MT-Mind2Web扩展了Mind2Web的功能，引入对话式网页导航，包含720个会话和3525个指令，测试agent的对话能力。<br>WebArena设定了新标准，模拟真实人类交互，包含812个任务，重点在多标签网页的复杂交互。<br>VisualWebArena评估agent在视觉基础网页任务上的表现，包含910个分类广告等任务，增加了视觉任务的挑战。<br>VideoWebArena聚焦于agent与视频内容的交互，提供74个视频和2021个任务，强调推理和视频理解的不足。<br>VisualWebBench提供多模态基准，涵盖1.5K个样本，评估诸如OCR和推理能力等挑战。<br>EnvDistraction评估agent在非恶意干扰下的表现，揭示了高级agent的脆弱性。<br>ST-WebAgentBench专注于安全性，通过管理不安全行为的策略进行评估，包括235个任务。<br>WorkArena针对企业软件任务，强调在ServiceNow平台上的表现，包含19912个实例。<br>WebOlympus通过Chrome扩展支持实时网站交互，为agent提供评估工具。<br>这些基准测试在真实性、多模态、安全性和企业应用等多个方面推动了网页GUIagent的评估。<br>移动平台评估GUIagent面临独特挑战，多个基准测试已被开发以应对。<br>PIXELHELP早期工作将自然语言与移动UI操作关联，提供187个多步骤指令，评估任务准确性。<br>ANDROIDLAB为Androidagent建立了框架，支持文本和多模态模型的评估，涵盖138个任务。<br>Mobile-Bench整合API和UI操作，测试简单与复杂移动交互的能力。<br>MobileSafetyBench强调安全性，提供结构化评估框架，测试常见移动任务中的agent表现。<br>SPA-BENCH针对多种语言和应用场景，评估单应用和跨应用任务的能力。<br>MobileAgentBench提供高效评估，涵盖100个任务，注重用户友好性。<br>LlamaTouch引入状态注释，提供真实Android环境中的任务自动化评估。<br>这些基准测试推动了移动端GUIagent的评估，解决了任务复杂性、安全性和效率等挑战。<br>在桌面计算机上评估GUIagent需要应对复杂工作流程，多个基准测试已针对特定挑战而开发。<br>Act2Cap记录光标操作，评估GUI交互的细节，涵盖4189个样本。<br>OSWorld提供跨系统任务设置，支持多模态agent的评估，包含多种环境的任务。<br>WindowsArena为Windows创建150多个任务，专注于多步骤任务的规划和屏幕理解。<br>OFFICEBENCH在办公应用中评估agent，使用复杂任务考验其能力。<br>Spider2-V针对数据科学工作流程，涵盖494个真实任务，评估agent在企业环境中的表现。<br>AssistGUI引入具身agent框架，强调复杂任务规划和操作生成。<br>这些基准测试为桌面平台的GUIagent提供全面评估，推动了多应用程序自动化和可扩展性的发展。<br>跨平台基准测试对于评估多环境下的GUIagent至关重要。<br>VisualAgentBench(VAB)评估不同平台的agent，采用多层次数据收集，确保全面性能评估。<br>CRAB评估多模态agent在跨环境交互中的表现，支持无缝多设备任务执行。<br>ScreenSpot强调视觉agent的GUI定位，包含600多个屏幕截图，评估点击准确性和定位精度。<br>这些基准测试推动了跨平台GUIagent的发展，提升了通用性和适应性。<br>GUIagent基准测试的演变反映了向更真实、交互式评估环境的转变。主要趋势包括：<br>真实交互环境的进展。<br>跨平台评估的出现，简化了基准测试过程。<br>融入人类交互，严格测试agent的动态处理能力。<br>可扩展性和自动化的挑战，提升评估效率。<br>安全性和合规性的重要性，确保agent的合法性和道德标准。<br>这些发展为构建更复杂的GUIagent铺平了道路，持续的创新和协作至关重要。<br>随着LLM驱动的GUIagent的不断发展，越来越多的应用程序利用这一概念创建更智能、用户友好的界面。这些应用主要包括：<br>GUI测试：从传统脚本方法转变为基于自然语言的交互。<br>虚拟助手：通过自然语言界面自动化用户的日常任务。<br>GUI测试评估软件应用的图形用户界面，以确保符合规范、功能和用户体验标准。最初手动进行，后通过自动化工具如Selenium和Appium实现。LLM驱动的GUIagent允许非专业人员通过自然语言测试GUI，涵盖通用测试、输入生成和错误重现。<br>图25显示了如何使用LLMagent在Windows上测试字体大小调整，减少了人工和脚本测试的工作量。<br>研究表明，LLM能通过自然语言测试用例自动化GUI测试。GPT-3和后续版本结合Selenium实现了更高的测试覆盖率。GPTDroid和DROIDAGENT等工具进一步提高了测试覆盖率和效率。AUITestAgent和VisionDroid通过多模态分析和视觉对齐改进了测试过程。AXNav通过自然语言指令自动执行可访问性测试。<br>Cui等人展示了如何利用GPT-3.5和GPT-4为UI字段生成上下文感知的文本，从而提高Android应用程序的测试覆盖率。QTypist也通过填空任务提高了覆盖率。<br>CrashTranslator结合强化学习和LLM自动重现崩溃，显著减少调试时间。AdbGPT通过动态推断GUI操作提供高效的错误重现解决方案。<br>MagicWand展示了LLM在自动化“操作指南”验证方面的潜力，提升了工作流程的可靠性。<br>总之，LLM驱动的GUIagent通过自然语言方法、视觉对齐和自动化错误重现，改变了GUI测试的面貌。<br>虚拟助手如Siri是AI驱动的应用，帮助用户通过自然语言命令完成任务。随着LLM和agent的发展，虚拟助手变得更加智能，通过上下文感知的交互提高用户生产力。<br>图26展示了基于GUIagent的虚拟助手概念，其简化了复杂任务的执行。<br>研究显示基于LLM的GUIagent在多种应用中实现智能交互。例如，Proagent系统引入了Agentic流程自动化，能够自动创建和执行GUI工作流程。LLMPA和PromptRPA通过自然语言提示提升了移动平台的任务自动化能力。VizAbility和EasyAsk通过增强可访问性来改善用户体验。<br>开源项目如OpenAdapt和AgentSea为LLMGUIagent的发展提供支持，促进了智能虚拟助手的定制和应用。OpenInterpreter允许用户通过自然语言命令执行代码，增强了灵活性和控制。<br>基于LLM的GUIagent在生产环境中展现出实际应用价值。例如，PowerAutomate通过自然语言描述任务增强了用户与桌面应用的互动。MultiOn和YOYOAgent通过智能化操作提高了网络和移动平台上的用户体验。<br>基于LLM的GUIagent正在引入自然语言交互和自动化，改变用户与软件应用的互动方式。尽管仍处于早期阶段，但这些技术的进步为未来设定了新的基准。<br>尽管LLM驱动的GUIagent已取得显著进展，但仍存在技术挑战和局限性，需要解决以提高其有效性和用户接受度。<br>LLMGUIagent通常需要访问用户敏感数据，增加隐私风险。解决方案包括设备端推理和隐私保护技术的实施。<br>高计算需求可能导致高延迟和用户体验不佳。未来应优化模型架构和探索边缘计算等技术。<br>错误操作可能导致数据损坏或安全漏洞。应加强错误检测机制和权限管理。<br>用户与agent的交互复杂，可能导致误解。应设计以用户为中心的系统以提高任务准确性。<br>agent需理解用户偏好以提供最佳体验。未来研究应关注用户建模和偏好学习。<br>部署LLMGUIagent引发伦理问题。应建立明确的道德准则和监管框架。<br>现有agent多为特定应用定制，限制了可扩展性。应创建多样化数据集并探索迁移学习技术。<br>解决上述局限性对实现LLMGUIagent的潜力至关重要。跨学科合作将促进更强大、广泛采用的agent开发。<br>LLM与GUI自动化的结合标志着人机交互的变革，提供了以自然语言控制应用程序的新范式。本文全面概述了LLMGUIagent的核心组件、挑战及未来方向，期待这一技术改善日常生活的生产力和可访问性。<br>进技术交流群请添加AINLP小助手微信（id:ainlp2)<br>请备注具体方向+所用到的相关技术点<br>关于AINLP<br>AINLP是一个有趣有AI的自然语言处理社区，专注于AI、NLP、机器学习、深度学习、推荐算法等相关技术的分享，主题包括LLM、预训练模型、自动生成、文本摘要、智能问答、聊天机器人、机器翻译、知识图谱、推荐系统、计算广告、招聘信息、求职经验分享等，欢迎关注！加技术交流群请添加AINLP小助手微信(id：ainlp2)，备注工作&#x2F;研究方向+加群目的。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ZejunCao</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://zejuncao.github.io/2025/01/12/1000002194-2650447133-3/">https://zejuncao.github.io/2025/01/12/1000002194-2650447133-3/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ZejunCao</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
                                    <span class="chip bg-color">开源项目</span>
                                </a>
                            
                                <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0/">
                                    <span class="chip bg-color">微信公众号聚合平台</span>
                                </a>
                            
                                <a href="/tags/AINLP/">
                                    <span class="chip bg-color">AINLP</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/01/12/1000002194-2650447133-4/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000002194_2650447133_4.jpg" class="responsive-img" alt="【多模态&amp;LLM】LLaVA系列算法架构演进：LLaVA（1.0-&gt;1.5-&gt;Next(1.6)-&gt;NeXT(Video)）">
                        
                        <span class="card-title">【多模态&amp;LLM】LLaVA系列算法架构演进：LLaVA（1.0-&gt;1.5-&gt;Next(1.6)-&gt;NeXT(Video)）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-01-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
                        <span class="chip bg-color">开源项目</span>
                    </a>
                    
                    <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0/">
                        <span class="chip bg-color">微信公众号聚合平台</span>
                    </a>
                    
                    <a href="/tags/AINLP/">
                        <span class="chip bg-color">AINLP</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/01/12/1000000233-2247492130-1/">
                    <div class="card-image">
                        
                        <img src="/medias/frontcover/1000000233_2247492130_1.jpg" class="responsive-img" alt="Github热门项目周报 | 第2周">
                        
                        <span class="card-title">Github热门项目周报 | 第2周</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-01-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ZejunCao
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
                        <span class="chip bg-color">开源项目</span>
                    </a>
                    
                    <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0/">
                        <span class="chip bg-color">微信公众号聚合平台</span>
                    </a>
                    
                    <a href="/tags/AIGC%E5%88%9B%E6%83%B3%E8%80%85/">
                        <span class="chip bg-color">AIGC创想者</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">ZejunCao</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZejunCao" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:caozejun369@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1378463428" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1378463428" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5915009280" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5915009280" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>





</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
